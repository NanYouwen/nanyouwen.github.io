<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>dayjs库的使用</title>
    <link href="/js-dayjs%E5%BA%93/"/>
    <url>/js-dayjs%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="day-js库的使用"><a href="#day-js库的使用" class="headerlink" title="day.js库的使用"></a>day.js库的使用</h1><p><strong>npm install dayjs直接安装</strong></p><h1 id="基础日期解析和格式化"><a href="#基础日期解析和格式化" class="headerlink" title="基础日期解析和格式化"></a>基础日期解析和格式化</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> dayjs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;dayjs&#x27;</span><br> <br><span class="hljs-comment">// 1. 创建日期对象</span><br><span class="hljs-keyword">const</span> now = <span class="hljs-title function_">dayjs</span>()                    <span class="hljs-comment">// 当前时间</span><br><span class="hljs-keyword">const</span> date1 = <span class="hljs-title function_">dayjs</span>(<span class="hljs-string">&#x27;2024-03-14&#x27;</span>)      <span class="hljs-comment">// 从字符串创建</span><br><span class="hljs-keyword">const</span> date2 = <span class="hljs-title function_">dayjs</span>(<span class="hljs-string">&#x27;2024-03-14 10:30:00&#x27;</span>) <span class="hljs-comment">// 带时间的字符串</span><br><span class="hljs-keyword">const</span> date3 = <span class="hljs-title function_">dayjs</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>())        <span class="hljs-comment">// 从 Date 对象创建</span><br><span class="hljs-keyword">const</span> date4 = <span class="hljs-title function_">dayjs</span>(<span class="hljs-number">1710400000000</span>)     <span class="hljs-comment">// 从时间戳创建</span><br> <br><span class="hljs-comment">// 2. 常用格式化</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(now.<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))           <span class="hljs-comment">// 2024-03-14</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(now.<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY年MM月DD日&#x27;</span>))       <span class="hljs-comment">// 2024年03月14日</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(now.<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>))  <span class="hljs-comment">// 2024-03-14 10:30:00</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(now.<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;dddd&#x27;</span>))                 <span class="hljs-comment">// 星期四</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(now.<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;MM/DD/YYYY&#x27;</span>))           <span class="hljs-comment">// 03/14/2024</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(now.<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;HH:mm&#x27;</span>))                <span class="hljs-comment">// 10:30</span><br></code></pre></td></tr></table></figure><h1 id="日期获取和修改"><a href="#日期获取和修改" class="headerlink" title="日期获取和修改"></a>日期获取和修改</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 获取日期部分</span><br><span class="hljs-keyword">const</span> date = <span class="hljs-title function_">dayjs</span>(<span class="hljs-string">&#x27;2024-03-14 10:30:00&#x27;</span>)<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">year</span>())      <span class="hljs-comment">// 2024</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">month</span>())     <span class="hljs-comment">// 2 (0-11)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">date</span>())      <span class="hljs-comment">// 14</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">day</span>())       <span class="hljs-comment">// 4 (0-6, 0是星期天)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">hour</span>())      <span class="hljs-comment">// 10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">minute</span>())    <span class="hljs-comment">// 30</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">second</span>())    <span class="hljs-comment">// 0</span><br> <br><span class="hljs-comment">// 2. 修改日期</span><br><span class="hljs-keyword">const</span> newDate = date<br>  .<span class="hljs-title function_">year</span>(<span class="hljs-number">2025</span>)                 <span class="hljs-comment">// 设置年份</span><br>  .<span class="hljs-title function_">month</span>(<span class="hljs-number">3</span>)                   <span class="hljs-comment">// 设置月份</span><br>  .<span class="hljs-title function_">date</span>(<span class="hljs-number">15</span>)                   <span class="hljs-comment">// 设置日期</span><br>  .<span class="hljs-title function_">hour</span>(<span class="hljs-number">14</span>)                   <span class="hljs-comment">// 设置小时</span><br>  .<span class="hljs-title function_">minute</span>(<span class="hljs-number">45</span>)                 <span class="hljs-comment">// 设置分钟</span><br>  .<span class="hljs-title function_">second</span>(<span class="hljs-number">30</span>)                 <span class="hljs-comment">// 设置秒数</span><br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newDate.<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>))<br></code></pre></td></tr></table></figure><h1 id="日期操作和计算"><a href="#日期操作和计算" class="headerlink" title="日期操作和计算"></a>日期操作和计算</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date = <span class="hljs-title function_">dayjs</span>(<span class="hljs-string">&#x27;2024-03-14&#x27;</span>)<br> <br><span class="hljs-comment">// 1. 增加时间</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;day&#x27;</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))    <span class="hljs-comment">// 增加1天</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;week&#x27;</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))   <span class="hljs-comment">// 增加1周</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;month&#x27;</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))  <span class="hljs-comment">// 增加1月</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;year&#x27;</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))   <span class="hljs-comment">// 增加1年</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;hours&#x27;</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;HH:mm&#x27;</span>))       <span class="hljs-comment">// 增加2小时</span><br> <br><span class="hljs-comment">// 2. 减少时间</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">subtract</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;day&#x27;</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))    <span class="hljs-comment">// 减少1天</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">subtract</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;month&#x27;</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))  <span class="hljs-comment">// 减少1月</span><br> <br><span class="hljs-comment">// 3. 开始和结束时间</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">startOf</span>(<span class="hljs-string">&#x27;year&#x27;</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))   <span class="hljs-comment">// 年初</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">startOf</span>(<span class="hljs-string">&#x27;month&#x27;</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))  <span class="hljs-comment">// 月初</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">startOf</span>(<span class="hljs-string">&#x27;week&#x27;</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))   <span class="hljs-comment">// 周初</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">startOf</span>(<span class="hljs-string">&#x27;day&#x27;</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;HH:mm:ss&#x27;</span>))      <span class="hljs-comment">// 天初</span><br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">endOf</span>(<span class="hljs-string">&#x27;year&#x27;</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))     <span class="hljs-comment">// 年末</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">endOf</span>(<span class="hljs-string">&#x27;month&#x27;</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))    <span class="hljs-comment">// 月末</span><br></code></pre></td></tr></table></figure><h1 id="日期比较"><a href="#日期比较" class="headerlink" title="日期比较"></a>日期比较</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date1 = <span class="hljs-title function_">dayjs</span>(<span class="hljs-string">&#x27;2024-03-14&#x27;</span>)<br><span class="hljs-keyword">const</span> date2 = <span class="hljs-title function_">dayjs</span>(<span class="hljs-string">&#x27;2024-03-15&#x27;</span>)<br> <br><span class="hljs-comment">// 1. 基础比较</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date1.<span class="hljs-title function_">isBefore</span>(date2))           <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date1.<span class="hljs-title function_">isAfter</span>(date2))            <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date1.<span class="hljs-title function_">isSame</span>(date2))             <span class="hljs-comment">// false</span><br> <br><span class="hljs-comment">// 2. 具体单位的比较</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date1.<span class="hljs-title function_">isSame</span>(date2, <span class="hljs-string">&#x27;month&#x27;</span>))    <span class="hljs-comment">// true (同月)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date1.<span class="hljs-title function_">isSame</span>(date2, <span class="hljs-string">&#x27;year&#x27;</span>))     <span class="hljs-comment">// true (同年)</span><br> <br><span class="hljs-comment">// 3. 比较大小</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date1.<span class="hljs-title function_">diff</span>(date2))               <span class="hljs-comment">// 时间差（毫秒）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date1.<span class="hljs-title function_">diff</span>(date2, <span class="hljs-string">&#x27;day&#x27;</span>))        <span class="hljs-comment">// 时间差（天）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date1.<span class="hljs-title function_">diff</span>(date2, <span class="hljs-string">&#x27;month&#x27;</span>))      <span class="hljs-comment">// 时间差（月）</span><br></code></pre></td></tr></table></figure><h1 id="实用插件功能"><a href="#实用插件功能" class="headerlink" title="实用插件功能"></a>实用插件功能</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 相对时间插件</span><br><span class="hljs-keyword">import</span> relativeTime <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;dayjs/plugin/relativeTime&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dayjs/locale/zh-cn&#x27;</span><br> <br>dayjs.<span class="hljs-title function_">extend</span>(relativeTime)<br>dayjs.<span class="hljs-title function_">locale</span>(<span class="hljs-string">&#x27;zh-cn&#x27;</span>)<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dayjs</span>().<span class="hljs-title function_">fromNow</span>())                <span class="hljs-comment">// 几秒前</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dayjs</span>().<span class="hljs-title function_">from</span>(<span class="hljs-title function_">dayjs</span>(<span class="hljs-string">&#x27;2024-01-01&#x27;</span>))) <span class="hljs-comment">// 2个月前</span><br> <br><span class="hljs-comment">// 2. 是否相同或之前/之后插件</span><br><span class="hljs-keyword">import</span> isSameOrBefore <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;dayjs/plugin/isSameOrBefore&#x27;</span><br><span class="hljs-keyword">import</span> isSameOrAfter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;dayjs/plugin/isSameOrAfter&#x27;</span><br> <br>dayjs.<span class="hljs-title function_">extend</span>(isSameOrBefore)<br>dayjs.<span class="hljs-title function_">extend</span>(isSameOrAfter)<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date1.<span class="hljs-title function_">isSameOrBefore</span>(date2))  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date1.<span class="hljs-title function_">isSameOrAfter</span>(date2))   <span class="hljs-comment">// false</span><br> <br><span class="hljs-comment">// 3. 周数插件</span><br><span class="hljs-keyword">import</span> weekOfYear <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;dayjs/plugin/weekOfYear&#x27;</span><br> <br>dayjs.<span class="hljs-title function_">extend</span>(weekOfYear)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dayjs</span>().<span class="hljs-title function_">week</span>())  <span class="hljs-comment">// 获取当前是第几周</span><br></code></pre></td></tr></table></figure><h1 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 格式化日期显示</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">formatDate</span> = (<span class="hljs-params">date</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">dayjs</span>(date).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>)<br>&#125;<br> <br><span class="hljs-comment">// 2. 计算剩余时间</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getRemainingTime</span> = (<span class="hljs-params">endDate</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> end = <span class="hljs-title function_">dayjs</span>(endDate)<br>  <span class="hljs-keyword">const</span> now = <span class="hljs-title function_">dayjs</span>()<br>  <span class="hljs-keyword">const</span> days = end.<span class="hljs-title function_">diff</span>(now, <span class="hljs-string">&#x27;day&#x27;</span>)<br>  <span class="hljs-keyword">const</span> hours = end.<span class="hljs-title function_">diff</span>(now, <span class="hljs-string">&#x27;hour&#x27;</span>) % <span class="hljs-number">24</span><br>  <span class="hljs-keyword">const</span> minutes = end.<span class="hljs-title function_">diff</span>(now, <span class="hljs-string">&#x27;minute&#x27;</span>) % <span class="hljs-number">60</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;days&#125;</span>天<span class="hljs-subst">$&#123;hours&#125;</span>小时<span class="hljs-subst">$&#123;minutes&#125;</span>分钟`</span><br>&#125;<br> <br><span class="hljs-comment">// 3. 获取日期范围</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getDateRange</span> = (<span class="hljs-params">start, end</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> dates = []<br>  <span class="hljs-keyword">let</span> current = <span class="hljs-title function_">dayjs</span>(start)<br>  <br>  <span class="hljs-keyword">while</span> (current.<span class="hljs-title function_">isBefore</span>(end) || current.<span class="hljs-title function_">isSame</span>(end)) &#123;<br>    dates.<span class="hljs-title function_">push</span>(current.<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))<br>    current = current.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;day&#x27;</span>)<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> dates<br>&#125;<br> <br><span class="hljs-comment">// 4. 判断是否是工作日</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isWorkday</span> = (<span class="hljs-params">date</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> day = <span class="hljs-title function_">dayjs</span>(date).<span class="hljs-title function_">day</span>()<br>  <span class="hljs-keyword">return</span> day !== <span class="hljs-number">0</span> &amp;&amp; day !== <span class="hljs-number">6</span><br>&#125;<br> <br><span class="hljs-comment">// 5. 获取月份天数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getDaysInMonth</span> = (<span class="hljs-params">date</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">dayjs</span>(date).<span class="hljs-title function_">daysInMonth</span>()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>&lt;keep-alive&gt;的原理和使用场景</title>
    <link href="/vue%E8%BF%9B%E9%98%B6-keepAlive%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/vue%E8%BF%9B%E9%98%B6-keepAlive%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><keep-alive>是Vue的内置组件，用于对动态组件进行缓存，核心原理是通过缓存组件实例，避免不必要的销毁和重新创建,从而优化性能。</p><p><strong>1.关键机制:</strong></p><ul><li>缓存机制<ul><li>keep-alive对象内部维护了一个缓存对象（cache）,用于存储已经被渲染过的组件实例</li><li>当组件被换成时，其mounted钩子只会执行一次，而切换回来时只会触发activated钩子</li><li>被移除的组件不会销毁，而是保存在内存中</li></ul></li><li>匹配规则<ul><li>通过include和exclude属性控制需要缓存或者不需要缓存的组件</li><li>使用正则表达式、字符串或数组来匹配组件名</li></ul></li><li>生命周期钩子<ul><li>配合activated和deactivated钩子处理业务逻辑</li><li>activated：当组件从缓存中激活时触发</li><li>deactivated：当组件被缓存而不是销毁时触发</li></ul></li></ul><p>2.工作流程</p><ul><li>渲染时，keep-alive检查组件名是否需要缓存</li><li>如果需要：缓存实例，直接从缓存中读取，避免重复创建实例</li><li>如果不需要：销毁该组件，正常执行生命周期</li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p><strong>keep-alive通常用于需要频繁切换的组件场景，避免重复加载和渲染，从而提升性能</strong><br><strong>1.典型场景</strong></p><ul><li>多页签切换：例如后台管理系统中，多个tab页面之间的频繁切换，使用keep-alive可以避免每次切换时重新加载数据</li><li>表单场景：当填写表单后切换到其他组件再切回来时表单内容保持不变</li><li>性能优化：对数据量较大的组件，例如长列表或复杂图表组件进行缓存，减少渲染开销</li></ul><p><strong>2.注意事项</strong></p><ul><li>缓存大小：如果换成组件过多，可能导致内存占用过高</li><li>动态条件：include和exclude需要合理配置，避免缓存无用组件</li><li>生命周期管理:配合activated和deactivated管理组件状态，比如清理定时器、停止动画等</li></ul><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&#x27;HelloWorld&#x27;&gt;<br>    &lt;div class=&quot;nav-buttons&quot;&gt;<br>      &lt;button @click=&quot;currentView = &#x27;ViewA&#x27;&quot;&gt;视图A&lt;/button&gt;<br>      &lt;button @click=&quot;currentView = &#x27;ViewB&#x27;&quot;&gt;视图B&lt;/button&gt;<br>    &lt;/div&gt;<br><br>    &lt;keep-alive&gt;<br>      &lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;<br>    &lt;/keep-alive&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&#x27;ts&#x27;&gt;<br>import &#123; ref, defineComponent, h, computed &#125; from &#x27;vue&#x27;<br><br>// 定义两个示例组件<br>const ViewA = defineComponent(&#123;<br>  name: &#x27;ViewA&#x27;,<br>  setup() &#123;<br>    const count = ref(0)<br>    return () =&gt; h(&#x27;div&#x27;, &#123; class: &#x27;view&#x27; &#125;, [<br>      h(&#x27;h2&#x27;, &#x27;View A&#x27;),<br>      h(&#x27;p&#x27;, `计数器: $&#123;count.value&#125;`),<br>      h(&#x27;button&#x27;, &#123; onClick: () =&gt; count.value++ &#125;, &#x27;增加&#x27;)<br>    ])<br>  &#125;<br>&#125;)<br><br>const ViewB = defineComponent(&#123;<br>  name: &#x27;ViewB&#x27;,<br>  setup() &#123;<br>    const message = ref(&#x27;&#x27;)<br>    return () =&gt; h(&#x27;div&#x27;, &#123; class: &#x27;view&#x27; &#125;, [<br>      h(&#x27;h2&#x27;, &#x27;View B&#x27;),<br>      h(&#x27;input&#x27;, &#123;<br>        value: message.value,<br>        onInput: (e: Event) =&gt; &#123;<br>          message.value = (e.target as HTMLInputElement).value<br>        &#125;<br>      &#125;),<br>      h(&#x27;p&#x27;, `输入的内容: $&#123;message.value&#125;`)<br>    ])<br>  &#125;<br>&#125;)<br><br>// 当前视图<br>const currentView = ref&lt;&#x27;ViewA&#x27; | &#x27;ViewB&#x27;&gt;(&#x27;ViewA&#x27;)<br><br>// 视图映射<br>const views = &#123;<br>  ViewA,<br>  ViewB<br>&#125;<br><br>const currentComponent = computed(() =&gt; &#123;<br>  return views[currentView.value]<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.HelloWorld &#123;<br>  padding: 20px;<br>  max-width: 500px;<br>  margin: 0 auto;<br>&#125;<br><br>.nav-buttons &#123;<br>  margin-bottom: 20px;<br>  display: flex;<br>  gap: 10px;<br>  justify-content: center;<br>&#125;<br><br>button &#123;<br>  padding: 8px 16px;<br>  background-color: #4CAF50;<br>  color: white;<br>  border: none;<br>  border-radius: 4px;<br>  cursor: pointer;<br>&#125;<br><br>button:hover &#123;<br>  background-color: #45a049;<br>&#125;<br><br>.view &#123;<br>  padding: 20px;<br>  border: 1px solid #ddd;<br>  border-radius: 8px;<br>  margin-top: 20px;<br>&#125;<br><br>input &#123;<br>  padding: 8px;<br>  margin: 10px 0;<br>  width: 100%;<br>  border: 1px solid #ddd;<br>  border-radius: 4px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js与jQuery</title>
    <link href="/web-js%E4%B8%8EjQuery/"/>
    <url>/web-js%E4%B8%8EjQuery/</url>
    
    <content type="html"><![CDATA[<h1 id="1-原生-JavaScript"><a href="#1-原生-JavaScript" class="headerlink" title="1.原生 JavaScript"></a>1.原生 JavaScript</h1><h4 id="1-1-DOM-选择器"><a href="#1-1-DOM-选择器" class="headerlink" title="1.1 DOM 选择器"></a>1.1 DOM 选择器</h4><p>原生 JavaScript 通过 <code>document</code> 对象来访问 DOM 元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取元素</span><br><span class="hljs-keyword">let</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;id&#x27;</span>); <span class="hljs-comment">// 通过 id 获取元素</span><br><span class="hljs-keyword">let</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;class&#x27;</span>); <span class="hljs-comment">// 通过 class 获取元素</span><br><span class="hljs-keyword">let</span> divs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;div&#x27;</span>); <span class="hljs-comment">// 通过标签名获取元素</span><br><br><span class="hljs-comment">// 获取所有符合选择器的元素</span><br><span class="hljs-keyword">let</span> selectedElements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.class&#x27;</span>); <span class="hljs-comment">// 获取所有 class 为 &#x27;class&#x27; 的元素</span><br><span class="hljs-keyword">let</span> firstDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>); <span class="hljs-comment">// 获取第一个 div 元素</span><br></code></pre></td></tr></table></figure><h4 id="1-2-样式操作"><a href="#1-2-样式操作" class="headerlink" title="1.2 样式操作"></a>1.2 样式操作</h4><p>原生 JavaScript 可以通过 <code>.style</code> 属性来操作样式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;id&#x27;</span>);<br>element.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;red&#x27;</span>; <span class="hljs-comment">// 改变背景色</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&#x27;200px&#x27;</span>; <span class="hljs-comment">// 设置宽度</span><br></code></pre></td></tr></table></figure><h4 id="1-3-属性操作"><a href="#1-3-属性操作" class="headerlink" title="1.3 属性操作"></a>1.3 属性操作</h4><p>可以通过 <code>.getAttribute()</code> 和 <code>.setAttribute()</code> 来获取和设置元素属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> link = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">let</span> href = link.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;href&#x27;</span>); <span class="hljs-comment">// 获取链接地址</span><br>link.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-string">&#x27;https://www.example.com&#x27;</span>); <span class="hljs-comment">// 设置新的链接地址</span><br></code></pre></td></tr></table></figure><h4 id="1-4-事件处理"><a href="#1-4-事件处理" class="headerlink" title="1.4 事件处理"></a>1.4 事件处理</h4><p>JavaScript 通过 <code>addEventListener()</code> 来绑定事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);<br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Button clicked!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="1-5-动态创建元素"><a href="#1-5-动态创建元素" class="headerlink" title="1.5 动态创建元素"></a>1.5 动态创建元素</h4><p>使用 <code>document.createElement()</code> 和 <code>.appendChild()</code> 来动态创建和插入元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> newDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>newDiv.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;Hello, World!&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(newDiv);<br></code></pre></td></tr></table></figure><h1 id="2-jQuery-库"><a href="#2-jQuery-库" class="headerlink" title="2. jQuery 库"></a>2. <strong>jQuery 库</strong></h1><p>​jQuery 提供了更加简洁和跨浏览器兼容的 DOM 操作接口。你需要引入 jQuery 库来使用它的功能。</p><h4 id="2-1-选择器"><a href="#2-1-选择器" class="headerlink" title="2.1 选择器"></a>2.1 选择器</h4><p>jQuery 选择器非常强大且简洁，常用的选择器如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 通过 ID 获取</span><br>$(<span class="hljs-string">&#x27;#id&#x27;</span>); <span class="hljs-comment">// 获取 id 为 &#x27;id&#x27; 的元素</span><br><br><span class="hljs-comment">// 通过 class 获取</span><br>$(<span class="hljs-string">&#x27;.class&#x27;</span>); <span class="hljs-comment">// 获取 class 为 &#x27;class&#x27; 的所有元素</span><br><br><span class="hljs-comment">// 通过标签名获取</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>); <span class="hljs-comment">// 获取所有 div 元素</span><br><br><span class="hljs-comment">// 属性选择器</span><br>$(<span class="hljs-string">&#x27;a[href=&quot;https://www.example.com&quot;]&#x27;</span>); <span class="hljs-comment">// 获取所有 href 为指定值的 a 元素</span><br></code></pre></td></tr></table></figure><h4 id="2-2-样式操作"><a href="#2-2-样式操作" class="headerlink" title="2.2 样式操作"></a>2.2 样式操作</h4><p>使用 <code>.css()</code> 方法来操作样式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#id&#x27;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;background-color&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>); <span class="hljs-comment">// 设置背景色</span><br>$(<span class="hljs-string">&#x27;#id&#x27;</span>).<span class="hljs-title function_">css</span>(&#123;<span class="hljs-string">&#x27;background-color&#x27;</span>: <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-string">&#x27;200px&#x27;</span>&#125;); <span class="hljs-comment">// 批量设置样式</span><br></code></pre></td></tr></table></figure><h4 id="2-3-属性操作"><a href="#2-3-属性操作" class="headerlink" title="2.3 属性操作"></a>2.3 属性操作</h4><p>jQuery 提供了 <code>.attr()</code> 方法来获取和设置属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> href = $(<span class="hljs-string">&#x27;a&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;href&#x27;</span>); <span class="hljs-comment">// 获取 href 属性值</span><br>$(<span class="hljs-string">&#x27;a&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-string">&#x27;https://www.example.com&#x27;</span>); <span class="hljs-comment">// 设置 href 属性值</span><br></code></pre></td></tr></table></figure><h4 id="2-4-事件处理"><a href="#2-4-事件处理" class="headerlink" title="2.4 事件处理"></a>2.4 事件处理</h4><p>jQuery 简化了事件绑定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#btn&#x27;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Button clicked!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>还支持链式调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#btn&#x27;</span>).<span class="hljs-title function_">hover</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  $(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;background-color&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>);<br>&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  $(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;background-color&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="2-5-动画效果"><a href="#2-5-动画效果" class="headerlink" title="2.5 动画效果"></a>2.5 动画效果</h4><p>jQuery 提供了非常简洁的动画效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#id&#x27;</span>).<span class="hljs-title function_">fadeIn</span>(); <span class="hljs-comment">// 渐显</span><br>$(<span class="hljs-string">&#x27;#id&#x27;</span>).<span class="hljs-title function_">fadeOut</span>(); <span class="hljs-comment">// 渐隐</span><br>$(<span class="hljs-string">&#x27;#id&#x27;</span>).<span class="hljs-title function_">slideUp</span>(); <span class="hljs-comment">// 向上滑动隐藏</span><br>$(<span class="hljs-string">&#x27;#id&#x27;</span>).<span class="hljs-title function_">slideDown</span>(); <span class="hljs-comment">// 向下滑动显示</span><br></code></pre></td></tr></table></figure><h4 id="2-6-DOM-操作"><a href="#2-6-DOM-操作" class="headerlink" title="2.6 DOM 操作"></a>2.6 DOM 操作</h4><p>jQuery 可以很方便地动态创建、修改和删除 DOM 元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建元素并添加到 DOM</span><br>$(<span class="hljs-string">&#x27;&lt;div&gt;&#x27;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>).<span class="hljs-title function_">appendTo</span>(<span class="hljs-string">&#x27;body&#x27;</span>);<br><br><span class="hljs-comment">// 修改元素内容</span><br>$(<span class="hljs-string">&#x27;#id&#x27;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&#x27;New Content&#x27;</span>);<br>$(<span class="hljs-string">&#x27;#id&#x27;</span>).<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;&lt;p&gt;New HTML content&lt;/p&gt;&#x27;</span>);<br><br><span class="hljs-comment">// 删除元素</span><br>$(<span class="hljs-string">&#x27;#id&#x27;</span>).<span class="hljs-title function_">remove</span>();<br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>原生 JavaScript</strong>：需要更多的代码来处理 DOM 操作，事件绑定，样式修改等，但它是原生语言，跨平台性更强。</li><li><strong>jQuery</strong>：提供了简洁的语法来完成各种 DOM 操作、事件绑定和动画效果等，尤其适合简化跨浏览器的兼容性问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>web-less预处理器进阶</title>
    <link href="/web-less%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%9B%E9%98%B6/"/>
    <url>/web-less%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Less-css预处理器-进阶用法"><a href="#Less-css预处理器-进阶用法" class="headerlink" title="Less(css预处理器)进阶用法"></a>Less(css预处理器)进阶用法</h1><h4 id="作用域与命名空间"><a href="#作用域与命名空间" class="headerlink" title="作用域与命名空间"></a>作用域与命名空间</h4><p>​Less 中可以定义局部变量，防止变量污染。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@outer-variable</span>: #f00;<br><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-keyword">@inner-variable</span>: #<span class="hljs-number">0</span>f0;<br><br>  <span class="hljs-selector-class">.inner</span> &#123;<br>    <span class="hljs-attribute">color</span>: @inner-variable;<br>    <span class="hljs-attribute">background-color</span>: @outer-variable;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="嵌套媒体查询"><a href="#嵌套媒体查询" class="headerlink" title="嵌套媒体查询"></a>嵌套媒体查询</h4><p>​通过嵌套语法控制不同屏幕尺寸样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br><br>  <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">750px</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1024px</span>) &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">970px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生成-CSS-Sprites"><a href="#生成-CSS-Sprites" class="headerlink" title="生成 CSS Sprites"></a>生成 CSS Sprites</h4><p>​使用 mixin 来管理 CSS Sprites。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@sprite-path</span>: <span class="hljs-string">&quot;path/to/sprites.png&quot;</span>;<br><br><span class="hljs-selector-class">.icon</span>(<span class="hljs-keyword">@name</span>, @position) &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">@sprite-path</span>);<br>  <span class="hljs-attribute">background-position</span>: @position;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">32px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">32px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.icon-home</span> &#123;<br>  <span class="hljs-selector-class">.icon</span>(home, <span class="hljs-number">0</span> <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>​Less 支持自定义函数以增强样式动态性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">darken-<span class="hljs-attribute">color</span>(<span class="hljs-keyword">@color</span>, @amount) &#123;<br>  return darken(<span class="hljs-keyword">@color</span>, @amount);<br>&#125;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">darken-color</span>(<span class="hljs-number">#4CAF50</span>, <span class="hljs-number">15%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态生成类名"><a href="#动态生成类名" class="headerlink" title="动态生成类名"></a>动态生成类名</h4><p>​根据条件动态生成不同样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@color</span>: blue;<br><span class="hljs-keyword">@is-active</span>: true;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: @color;<br><br>  &amp;<span class="hljs-selector-class">.active</span> when (<span class="hljs-keyword">@is-active</span>) &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">darken</span>(@color, <span class="hljs-number">20%</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="遍历数据结构"><a href="#遍历数据结构" class="headerlink" title="遍历数据结构"></a>遍历数据结构</h4><p>​通过循环生成多个类。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@colors</span>: red, green, blue;<br><br><span class="hljs-selector-class">.each-color</span> &#123;<br>  each(<span class="hljs-keyword">@colors</span>, &#123;<br>    <span class="hljs-selector-class">.color-</span>@&#123;value&#125; &#123;<br>      <span class="hljs-attribute">background-color</span>: @value;<br>      <span class="hljs-attribute">color</span>: white;<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Less-的优势"><a href="#Less-的优势" class="headerlink" title="Less 的优势"></a>Less 的优势</h3><ul><li><strong>可维护性</strong>：变量、嵌套和混合使代码更具可读性和维护性。</li><li><strong>灵活性</strong>：Less 提供的运算、条件和循环功能提高了样式管理的灵活性。</li><li><strong>重用性</strong>：通过混合和导入，开发者可轻松复用代码。</li><li><strong>社区支持</strong>：广泛的社区资源和工具支持。</li></ul><h3 id="实用建议"><a href="#实用建议" class="headerlink" title="实用建议"></a>实用建议</h3><ol><li><p>控制嵌套层级：嵌套层级过深会降低代码可读性，建议控制在 3 层以内。</p></li><li><p>模块化样式：将样式拆分为多个文件，使用 @import 引入，保持项目清晰。</p></li><li><p>合理使用变量：将常用颜色、字体大小定义为变量，便于全局管理。</p></li><li><p>混合与命名规范：使用 BEM 命名规范有助于代码的复用和清晰度。</p></li><li><p>定期优化：在项目迭代时，重构 Less 代码，确保代码质量和维护性</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>web-less预处理器</title>
    <link href="/web-less%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/web-less%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Less-css预处理器-详解"><a href="#Less-css预处理器-详解" class="headerlink" title="Less(css预处理器)详解"></a>Less(css预处理器)详解</h1><p><strong>Less介绍</strong></p><p>​Less 是一种动态样式语言，扩展了 CSS 语法，支持变量、嵌套、混合、函数等特性。利用 Less，可创建更具可维护性、可读性的样式代码。</p><p><strong>Less 的安装</strong></p><p>​项目中安装 Less 可通过 npm 或直接使用 CDN 引入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install less --save-dev<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;link rel=&quot;stylesheet/less&quot; type=&quot;<span class="hljs-selector-tag">text</span>/css&quot; href=&quot;styles<span class="hljs-selector-class">.less</span>&quot; /&gt;<br>&lt;script <span class="hljs-attribute">src</span>=&quot;https://cdn.jsdelivr.net/npm/less<span class="hljs-string">&quot;&gt;&lt;/script&gt;</span><br></code></pre></td></tr></table></figure><p><strong>变量:利用变量定义颜色、字体等样式属性，便于全局修改。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@primary-color</span>: #<span class="hljs-number">4</span>CAF50;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: @primary-color;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>嵌套:支持层级嵌套，使代码结构更清晰。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.nav</span> &#123;<br>  <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">list-style</span>: none;<br>    <span class="hljs-selector-tag">li</span> &#123;<br>      <span class="hljs-attribute">display</span>: inline-block;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>混合（Mixins）:使用混合创建可复用的样式块。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.border-radius</span>(<span class="hljs-keyword">@radius</span>) &#123;<br>  <span class="hljs-attribute">border-radius</span>: @radius;<br>&#125;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-selector-class">.border-radius</span>(<span class="hljs-number">5px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运算:支持算术运算，便于动态调整样式。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@base</span>: <span class="hljs-number">5px</span>;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">margin</span>: @base * <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">padding</span>: @base + <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>媒体查询:支持嵌套的媒体查询写法。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">750px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>颜色函数:内置多种颜色处理函数。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@color</span>: #ff0000;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">lighten</span>(@color, <span class="hljs-number">20%</span>);<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">darken</span>(@color, <span class="hljs-number">10%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>链接伪类:简洁的伪类写法。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.link</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>  &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">text-decoration</span>: underline;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>嵌套列表:嵌套写法使得结构更清晰。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.nav</span> &#123;<br>  <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">list-style</span>: none;<br>    <span class="hljs-selector-tag">li</span> &#123;<br>      <span class="hljs-attribute">display</span>: inline-block;<br>      &amp;<span class="hljs-selector-class">.active</span> &#123;<br>        <span class="hljs-attribute">font-weight</span>: bold;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据代理与数据劫持</title>
    <link href="/vue%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81/"/>
    <url>/vue%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81/</url>
    
    <content type="html"><![CDATA[<h1 id="数据代理和数据劫持概述"><a href="#数据代理和数据劫持概述" class="headerlink" title="数据代理和数据劫持概述"></a>数据代理和数据劫持概述</h1><p>​在 Vue.js 中，数据代理（Data Proxy）和数据劫持（Data Interception）是两个核心概念，它们在实现 Vue 的双向绑定和响应式数据流方面发挥了重要作用。</p><p>​<strong>数据代理（Data Proxy）：</strong> 数据代理是一种机制，使得我们可以通过一个对象来访问另一个对象的属性。在 Vue 中，数据代理用于将 Vue 实例的属性访问代理到其 <code>data</code> 对象中的属性上。这样一来，我们可以通过直接访问 Vue 实例来访问和修改其数据属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">const vm = new Vue(&#123;<br>  data: &#123;<br>    message: &quot;Hello, World!&quot;<br>  &#125;<br>&#125;);<br> <br>console.log(vm.message); // 通过数据代理访问属性<br></code></pre></td></tr></table></figure><p>​在上述示例中，vm.messgae 实际上是访问了 <code>vm._data.message</code>，其中 <code>_data</code> 是一个保存着实际数据的对象，通过数据代理，我们可以像直接访问属性一样访问 Vue 实例的属性。</p><p><img src="/../img/vue%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81/image-20241228024354152.png" alt="image-20241228024354152"></p><p>​<strong>数据劫持（Data Interception）：</strong> 数据劫持是指在访问或修改对象的属性时，对这些操作进行拦截和监视，以便在属性发生变化时能够触发相关的操作。在 Vue 中，数据劫持用于监听数据的变化，以实现双向绑定和响应式更新。</p><p>​Vue 通过在数据对象的属性上使用 <code>Object.defineProperty</code> 来实现数据劫持。每当访问属性或修改属性时，Vue 会触发相应的 <code>get</code> 和 <code>set</code> 拦截器，从而实现对数据变化的监听。</p><p>​通过数据劫持，Vue 能够在属性发生变化时自动触发视图的更新，从而实现了响应式的特性</p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p>​<code>Object.defineProperty</code> 是 JavaScript 中的一个方法，用于在对象上定义或修改属性的特性。通过 <code>Object.defineProperty</code>，您可以精确地控制属性的行为，包括设置属性的值、可枚举性、可配置性、可写性以及获取和设置属性的方法（即 getter 和 setter）。</p><p>该方法接受三个参数：</p><ol><li><strong>对象（Object）：</strong> 要在其上定义或修改属性的对象。</li><li><strong>属性名（Property Name）：</strong> 要定义或修改的属性的名称。</li><li><strong>属性描述符（Property Descriptor）：</strong> 一个对象，用于设置属性的特性。</li></ol><p>属性描述符对象可以包含以下属性：</p><ul><li><code>value</code>：属性的值（默认为 <code>undefined</code>）。</li><li><code>writable</code>：属性是否可写（默认为 <code>false</code>）。</li><li><code>enumerable</code>：属性是否可枚举（使用for…in或Object.keys()）（默认为 <code>false</code>）。</li><li><code>configurable</code>：属性是否可配置（默认为 <code>false</code>），是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。</li><li><code>get</code>：获取属性值的函数。当访问该属性时，该方法会被执行。函数的返回值会作为该属性的值返回。</li><li><code>set</code>：设置属性值的函数。当属性值修改时，该方法会被执行。该方法将接受唯一参数，即该属性新的参数值。</li></ul><p>注意：</p><ol><li>当使用了getter或setter方法，不允许使用writable和value这两个属性；</li><li>不要在getter中再次获取该属性值，也不要在setter中再次设置该属性，否则会栈溢出。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;prop&quot;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">123</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">prop</span>); <span class="hljs-comment">// 输出: 123</span><br>obj.<span class="hljs-property">prop</span> = <span class="hljs-number">456</span>; <span class="hljs-comment">// 报错，因为属性不可写&#x27;</span><br></code></pre></td></tr></table></figure><p>​在上述示例中，<code>Object.defineProperty</code> 将一个名为 <code>prop</code> 的属性定义在 <code>obj</code> 对象上，设置了属性的值、可枚举性以及是否可写。由于 <code>writable</code> 被设置为 <code>false</code>，所以尝试修改 <code>prop</code> 的值会报错。</p><p>​<code>Object.defineProperty</code> 主要用于对单个属性进行操作，它可以用于实现一些高级的对象操作，例如创建只读属性、定义计算属性、实现拦截器等。在 Vue.js 中，<code>Object.defineProperty</code> 在实现数据劫持（响应式）方面发挥了重要作用。</p><h1 id="实现数据代理"><a href="#实现数据代理" class="headerlink" title="实现数据代理"></a>实现数据代理</h1><p>​使用 <code>Object.defineProperty</code> 来模拟实现 Vue 的数据代理时，需要将 Vue 实例的属性访问代理到其 <code>data</code> 对象中的属性上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_data</span> = options.<span class="hljs-property">data</span>;<br>  <span class="hljs-comment">// 实现数据代理</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_data</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>, key, &#123;<br>      <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_data</span>[key];<br>      &#125;,<br>      <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_data</span>[key] = value;<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello, Vue!&quot;</span><br>  &#125;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">message</span>); <span class="hljs-comment">// 通过数据代理访问属性</span><br>vm.<span class="hljs-property">message</span> = <span class="hljs-string">&quot;Hello, Vue 2.0!&quot;</span>; <span class="hljs-comment">// 通过数据代理修改属性</span><br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">_data</span>.<span class="hljs-property">message</span>); <span class="hljs-comment">// 通过原始 data 访问属性（仍然可行）</span><br></code></pre></td></tr></table></figure><p>​在上述示例中，<code>Vue</code> 构造函数接受一个 <code>options</code> 对象，其中包含一个 <code>data</code> 属性。在构造函数中，我们将 <code>options.data</code> 赋值给 <code>_data</code> 属性，并使用 <code>Object.defineProperty</code> 循环遍历 <code>_data</code> 中的属性，为每个属性设置 <code>get</code> 和 <code>set</code> 拦截器，从而实现了属性访问的代理。</p><p>​请注意，这个示例只是一个简化版的模拟，Vue 的实际实现涉及更多的细节和功能。这里的目的是演示使用 <code>Object.defineProperty</code> 实现数据代理的基本原理。</p><h1 id="实现数据劫持"><a href="#实现数据劫持" class="headerlink" title="实现数据劫持"></a>实现数据劫持</h1><p>​使用 <code>Object.defineProperty</code> 来模拟实现 Vue 的数据劫持（响应式）是一个复杂的过程，涉及到对象属性的拦截、依赖追踪、触发更新等。以下是一个简化版的使用 <code>Object.defineProperty</code> 模拟实现数据劫持的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!data || <span class="hljs-keyword">typeof</span> data !== <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br> <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123;<br>    <span class="hljs-keyword">let</span> value = data[key];<br> <br>    <span class="hljs-comment">// 为每个属性创建依赖数组</span><br>    <span class="hljs-keyword">let</span> dep = [];<br> <br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>      <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (dep.<span class="hljs-property">target</span>) &#123;<br>          <span class="hljs-comment">// 添加依赖</span><br>          dep.<span class="hljs-title function_">push</span>(dep.<span class="hljs-property">target</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>      &#125;,<br>      <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) &#123;<br>        <span class="hljs-keyword">if</span> (value !== newValue) &#123;<br>          value = newValue;<br> <br>          <span class="hljs-comment">// 通知依赖更新</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dep.<span class="hljs-property">length</span>; i++) &#123;<br>            dep[i](newValue);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_data</span> = options.<span class="hljs-property">data</span>;<br> <br>  <span class="hljs-comment">// 进行数据劫持（响应式）</span><br>  <span class="hljs-title function_">observe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_data</span>);<br>&#125;<br> <br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$watch</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key, callback</span>) &#123;<br>  <span class="hljs-comment">// 在数据变化时执行回调</span><br>  dep.<span class="hljs-property">target</span> = callback;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_data</span>[key]; <span class="hljs-comment">// 触发 getter，建立依赖</span><br>  dep.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br>&#125;;<br> <br><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello, Vue!&quot;</span><br>  &#125;<br>&#125;);<br> <br>vm.$watch(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Message updated:&quot;</span>, newVal);<br>&#125;);<br><br>vm.<span class="hljs-property">_data</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&quot;Hello, Vue 2.0!&quot;</span>; <span class="hljs-comment">// 触发数据更新，触发 watch 回调</span><br></code></pre></td></tr></table></figure><p>​在上述示例中，我们定义了一个 <code>observe</code> 函数，它遍历 <code>data</code> 对象的属性，并使用 <code>Object.defineProperty</code> 对属性进行拦截。我们还定义了一个 <code>Vue</code> 构造函数，其中创建了一个数据对象并应用了数据劫持。我们还添加了一个简单的 <code>$watch</code> 方法，用于监听数据变化。</p><p>​请注意，这只是一个基本的模拟示例，Vue 的实际实现更为复杂，涉及到异步更新、依赖追踪、虚拟 DOM 等。这里的目的是演示使用 <code>Object.defineProperty</code> 实现简单的数据劫持的基本原理。</p>]]></content>
    
    
    <categories>
      
      <category>vue进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于v-model的用法与底层机制</title>
    <link href="/vue%E8%BF%9B%E9%98%B6-v-model/"/>
    <url>/vue%E8%BF%9B%E9%98%B6-v-model/</url>
    
    <content type="html"><![CDATA[<h1 id="组件-v-model"><a href="#组件-v-model" class="headerlink" title="组件 v-model"></a>组件 v-model</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>​<code>v-model</code> 可以在组件上使用以实现双向绑定。</p><p>​从 Vue 3.4 开始，推荐的实现方式是使用 <a href="https://cn.vuejs.org/api/sfc-script-setup.html#definemodel"><code>defineModel()</code></a> 宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- Child.vue --&gt;<br>&lt;script setup&gt;<br>const model = defineModel()<br><br>function update() &#123;<br>  model.value++<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div&gt;Parent bound v-model is: &#123;&#123; model &#125;&#125;&lt;/div&gt;<br>  &lt;button @click=&quot;update&quot;&gt;Increment&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>父组件可以用 <code>v-model</code> 绑定一个值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- Parent.vue --&gt;<br>&lt;Child v-model=&quot;countModel&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​<code>defineModel()</code> 返回的值是一个 ref。它可以像其他 ref 一样被访问以及修改，不过它能起到在父组件和当前变量之间的双向绑定的作用：</p><ul><li>它的 <code>.value</code> 和父组件的 <code>v-model</code> 的值同步；</li><li>当它被子组件变更了，会触发父组件绑定的值一起更新。</li></ul><p>​这意味着你也可以用 <code>v-model</code> 把这个 ref 绑定到一个原生 input 元素上，在提供相同的 <code>v-model</code> 用法的同时轻松包装原生 input 元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const model = defineModel()<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input v-model=&quot;model&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNqFUtFKwzAU/ZWYl06YLbK30Q10DFSYigq+5KW0t11mmoQknZPSf/cm3eqEsT0l555zuefmpKV3WsfbBuiUpjY3XDtiwTV6ziSvtTKOLNZcFKQ0qiZRnATkG6JB0BIDJen2kp5iMlfSOlLbisw8P4oeQAhFPpURxVV0zWSa9PNwEgIHtRaZA0SEpOvbeduG5q5LE0Sh2jvZ3tSqADFjFHlGSYJkmhz10zF1FseXvIo3VklcrfX9jOaq1lyAedGOoz1GpyQwnsvQ3fdTqDnTwPhQz9eQf52ob+zO1xh9NWDBbIHRgXOZqcD19PL9GXZ4H0h03whUnyHfwCrReI+97L6RBdo+0gW3j+H9uaw+7HLnQNrDUt6oV3ZBzyhmsjiz+p/dSTwJfUx2+IpD1ic+xz5enwQGXEDJJaw8Gl2I1upMzlc/hEvdOBR6SNKAjqP1J6P/o6XdL11L5h4=">演练场示例</a></p><h1 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h1><p><code>defineModel</code> 是一个便利宏。编译器将其展开为以下内容：</p><ul><li>一个名为 <code>modelValue</code> 的 prop，本地 ref 的值与其同步；</li><li>一个名为 <code>update:modelValue</code> 的事件，当本地 ref 的值发生变更时触发。</li></ul><p>在 3.4 版本之前，你一般会按照如下的方式来实现上述相同的子组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- Child.vue --&gt;<br>&lt;script setup&gt;<br>const props = defineProps([&#x27;modelValue&#x27;])<br>const emit = defineEmits([&#x27;update:modelValue&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    :value=&quot;modelValue&quot;<br>    @input=&quot;emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>​然后，父组件中的 <code>v-model=&quot;foo&quot;</code> 将被编译为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- Parent.vue --&gt;<br>&lt;Child<br>  :modelValue=&quot;foo&quot;<br>  @update:modelValue=&quot;$event =&gt; (foo = $event)&quot;<br>/&gt;<br></code></pre></td></tr></table></figure><p>​如你所见，这显得冗长得多。然而，这样写有助于理解其底层机制。</p><p>​因为 <code>defineModel</code> 声明了一个 prop，你可以通过给 <code>defineModel</code> 传递选项，来声明底层 prop 的选项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使 v-model 必填</span><br><span class="hljs-keyword">const</span> model = <span class="hljs-title function_">defineModel</span>(&#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;)<br><br><span class="hljs-comment">// 提供一个默认值</span><br><span class="hljs-keyword">const</span> model = <span class="hljs-title function_">defineModel</span>(&#123; <span class="hljs-attr">default</span>: <span class="hljs-number">0</span> &#125;)<br></code></pre></td></tr></table></figure><p>​如果为 <code>defineModel</code> prop 设置了一个 <code>default</code> 值且父组件没有为该 prop 提供任何值，会导致父组件与子组件之间不同步。在下面的示例中，父组件的 <code>myRef</code> 是 undefined，而子组件的 <code>model</code> 是 1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 子组件：</span><br><span class="hljs-keyword">const</span> model = <span class="hljs-title function_">defineModel</span>(&#123; <span class="hljs-attr">default</span>: <span class="hljs-number">1</span> &#125;)<br><br><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">const</span> myRef = <span class="hljs-title function_">ref</span>()<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;myRef&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="v-model-的参数"><a href="#v-model-的参数" class="headerlink" title="v-model 的参数"></a><code>v-model</code> 的参数</h2><p>​组件上的 <code>v-model</code> 也可以接受一个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​在子组件中，我们可以通过将字符串作为第一个参数传递给 <code>defineModel()</code> 来支持相应的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- MyComponent.vue --&gt;<br>&lt;script setup&gt;<br>const title = defineModel(&#x27;title&#x27;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input type=&quot;text&quot; v-model=&quot;title&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNqFklFPwjAUhf9K05dhgiyGNzJI1PCgCWqUx77McQeFrW3aOxxZ9t+9LTAXA/q2nnN6+t12Db83ZrSvgE944jIrDTIHWJmZULI02iJrmIWctSy3umQRRaPOWhweNX0pUHiyR3FP870UZkyoTCuH7FPr3VJiAWzqSwfR/rbUKyhYatdV6VugTktTQHQjVBIfeYiEFgikpwi0YizZ3M2aplfXtklMWvD6UKf+CfrUVPBuh+AspngSd718yH+hX7iS4xihjUZYQS4VLPwJgyiI/3FLZSrafzAeBqFG4jgxeuEqGTo6OZfr0dZpRVxNuFWeEa4swL4alEQm+IQFx3tpUeiv56ChrWB41rMNZLsL+tbVXhP8zYIDuyeQzkN6HyBWb88/XgJ3ZxJ95bH/MN/B6aLyjMfYQ6VWhN3LBdqn8FdJtV66eY2g3HkoD+qTbcgLTo/jX+ra6D+449E47BOq5e039mr+gA==">在演练场中尝试一下</a></p><p>​如果需要额外的 prop 选项，应该在 model 名称之后传递：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> title = <span class="hljs-title function_">defineModel</span>(<span class="hljs-string">&#x27;title&#x27;</span>, &#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;)<br></code></pre></td></tr></table></figure><details style="box-sizing: border-box; display: block;"><summary style="box-sizing: border-box; display: list-item; touch-action: manipulation; margin-bottom: 1.2em; width: fit-content; cursor: pointer;">3.4 之前的用法</summary><div class="language-vue" style="box-sizing: border-box; position: relative; margin: 28px 0px; background-color: rgb(41, 45, 62); overflow-x: auto; transition: background-color 0.5s; border-radius: 8px;"><button title="Copy Code" class="copy" style="box-sizing: border-box; font-family: inherit; font-size: 16px; line-height: inherit; margin: 0px; overflow: visible; text-transform: none; appearance: button; touch-action: manipulation; border: 0px; padding: 0px; color: inherit; background-color: rgb(41, 45, 62); background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='20' width='20' stroke='rgba(128,128,128,1)' stroke-width='2' viewBox='0 0 24 24'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2M9 5a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2M9 5a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2'/%3E%3C/svg%3E&quot;); cursor: pointer; position: absolute; top: 4px; right: 4px; z-index: 3; display: block; justify-content: center; align-items: center; border-radius: 4px; width: 40px; height: 40px; opacity: 0; background-position: 50% center; background-size: 20px; background-repeat: no-repeat; transition: opacity 0.4s;"></button><span class="lang" style="box-sizing: border-box; position: absolute; top: 4px; right: 10px; z-index: 2; font-size: 12px; font-weight: 500; color: var(--vt-c-text-dark-3); transition: color 0.5s;"></span><pre class="shiki github-dark vp-code" tabindex="0" style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: 1em; margin: 0px; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; position: relative; z-index: 1; padding: 14px 0px; background: transparent; overflow-x: auto;"><code style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: var(--vt-doc-code-font-size); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; display: block; padding: 0px 24px; width: fit-content; min-width: 100%; line-height: var(--vt-doc-code-line-height); color: rgb(166, 172, 205); transition: color 0.5s;"><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(106, 115, 125);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(121, 184, 255);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span></code></pre></div><p style="box-sizing: border-box; margin: 0px 0px 1.2em;"><a href="https://play.vuejs.org/#eNp9kE1rwzAMhv+KMIW00DXsGtKyMXYc7D7vEBplM8QfOHJoCfnvk+1QsjJ2svVKevRKk3h27jAGFJWoh7NXjmBACu4kjdLOeoIJPHYwQ+ethoJLi1vq7fpi+WfQ0JI+lCstcrkYQJqzNQMBKeoRjhG4LcYHbVvsofFfQUcCXhrteix20tRl9sIuOCBkvSHkCKD+fjxN04Ka57rkOOlrMwu7SlVHKdIrBZRcWpc3ntiLO7t/nKHFThl899YN248ikYpP9pj1V60o6sG1TMwDU/q/FZRxgeIPgK4uGcQLSZGlamz6sHKd1afUxOoGeeT298A9bHCMKxBfE3mTSNjl1vud5x8qNa76" target="_blank" rel="noreferrer" style="box-sizing: border-box; background-color: transparent; touch-action: manipulation; color: var(--vt-c-brand); text-decoration-line: inherit; text-decoration-thickness: inherit; text-decoration-style: dotted; text-decoration-color: inherit; font-weight: 500; transition: color 0.25s;"></a></p></details><h2 id="示例-父子组件实现双向绑定"><a href="#示例-父子组件实现双向绑定" class="headerlink" title="示例(父子组件实现双向绑定)"></a>示例(父子组件实现双向绑定)</h2><p>​<strong>大概过程:父组件通过props传递参数给子组件，然后通过自定义事件调用子组件的返回的事件。子组件通过defineProps获取到父组件参数绑定到input中后，通过input的@input事件将input的值返回给父组件，代码如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue">//父组件<br>&lt;template&gt;<br>  &lt;div class=&quot;&quot;&gt;<br>    &lt;ChildComponent :port @updateModelValue=&quot;Channel($event)&quot; /&gt;<br>    &lt;br&gt;父组件：&#123;&#123; port &#125;&#125;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref &#125; from &quot;vue&quot;<br>import ChildComponent from &quot;./ChildComponent.vue&quot;;<br>const port = ref(&quot;测试数据&quot;);<br>function Channel(e: any) &#123;<br>  console.log(e);<br>  port.value = e.target.value;<br>&#125;<br>&lt;/script&gt;<br>&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;<br><br><br>//子组件<br>&lt;template&gt;<br>  &lt;div&gt;子组件：&lt;input :value=&quot;port&quot; type=&quot;text&quot; @input=&quot;$emit(&#x27;updateModelValue&#x27;, $event)&quot;&gt;&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script setup lang=&quot;ts&quot;&gt;<br>defineProps([&#x27;port&#x27;])<br>&lt;/script&gt;<br>&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><h2 id="多个-v-model-绑定"><a href="#多个-v-model-绑定" class="headerlink" title="多个 v-model 绑定"></a>多个 <code>v-model</code> 绑定</h2><p>​利用刚才在 <a href="https://cn.vuejs.org/guide/components/v-model.html#v-model-arguments"><code>v-model</code> 的参数</a>小节中学到的指定参数与事件名的技巧，我们可以在单个组件实例上创建多个 <code>v-model</code> 双向绑定。</p><p>​组件上的每一个 <code>v-model</code> 都会同步不同的 prop，而无需额外的选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;UserName<br>  v-model:first-name=&quot;first&quot;<br>  v-model:last-name=&quot;last&quot;<br>/&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const firstName = defineModel(&#x27;firstName&#x27;)<br>const lastName = defineModel(&#x27;lastName&#x27;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; /&gt;<br>  &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNqFkstuwjAQRX/F8iZUAqKKHQpIfbAoUmnVx86bKEzANLEt26FUkf+9Y4MDSAg2UWbu9fjckVv6oNRw2wAd08wUmitLDNhGTZngtZLakpZoKIkjpZY1SdCadNK3Ab3IazhowzQ2/ES0MVFIYSwpucbvxA/qJXO5FsldlKr8qDxL8EKW7kEQAQsLtapyC1gRkq3vp217mOccwf8wwLksRSlYIoMvCNkOarmEahyODAT2J4yGgtFzhx8UDf5/r6c4NEs7CNqnpxkvbO0kcVjNhCyh5AJe/SW9pBPOV3DJGvu3dsKFaiyxf8qTW9gheQwVs4Z90BDm5oF47cF/Ht4aZC75argxUmD61g9ktJC14hXoN2U5ZmJ0TILitbyq5O889KxuoB/7xRqKnwv9jdn5HqPvGnDVWwTpNJvrFSCul2efi4DeiRigqdB9RfwAI6vGM+5tj41YIvaJL9C+hOfNxerLzHYWhImhPKh3uuBnFJ/A05XoR9zRcBTOMeGo+wcs+yse">在演练场中尝试一下</a></p><details style="box-sizing: border-box; display: block;"><summary style="box-sizing: border-box; display: list-item; touch-action: manipulation; margin-bottom: 1.2em; width: fit-content; cursor: pointer;">3.4 之前的用法</summary><div class="language-vue" style="box-sizing: border-box; position: relative; margin: 28px 0px; background-color: rgb(41, 45, 62); overflow-x: auto; transition: background-color 0.5s; border-radius: 8px;"><button title="Copy Code" class="copy" style="box-sizing: border-box; font-family: inherit; font-size: 16px; line-height: inherit; margin: 0px; overflow: visible; text-transform: none; appearance: button; touch-action: manipulation; border: 0px; padding: 0px; color: inherit; background-color: rgb(41, 45, 62); background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='20' width='20' stroke='rgba(128,128,128,1)' stroke-width='2' viewBox='0 0 24 24'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2M9 5a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2M9 5a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2'/%3E%3C/svg%3E&quot;); cursor: pointer; position: absolute; top: 4px; right: 4px; z-index: 3; display: block; justify-content: center; align-items: center; border-radius: 4px; width: 40px; height: 40px; opacity: 0; background-position: 50% center; background-size: 20px; background-repeat: no-repeat; transition: opacity 0.4s;"></button><span class="lang" style="box-sizing: border-box; position: absolute; top: 4px; right: 10px; z-index: 2; font-size: 12px; font-weight: 500; color: var(--vt-c-text-dark-3); transition: color 0.5s;"></span><pre class="shiki github-dark vp-code" tabindex="0" style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: 1em; margin: 0px; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; position: relative; z-index: 1; padding: 14px 0px; background: transparent; overflow-x: auto;"><code style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: var(--vt-doc-code-font-size); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; display: block; padding: 0px 24px; width: fit-content; min-width: 100%; line-height: var(--vt-doc-code-line-height); color: rgb(166, 172, 205); transition: color 0.5s;"><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span></code></pre></div><p style="box-sizing: border-box; margin: 0px 0px 1.2em;"><a href="https://play.vuejs.org/#eNqNUc1qwzAMfhVjCk6hTdg1pGWD7bLDGIydlh1Cq7SGxDaOEjaC332yU6cdFNpLsPRJ348y8idj0qEHnvOi21lpkHWAvdmWSrZGW2Qjs1Azx2qrWyZoVMzQZwf2rWrhhKVZbHhGGivVTqsOWS0tfTeeKBGv+qjEMkJNdUaeNXigyCYjZIEKhNY0FQJVjBXHh+04nvicY/QOBM4VGUFhJHrwBWPDutV7aPKwslbU35Q8FCX/P+GJ4oB/T3hGpEU2m+ArfpnxytX2UEsF71abLhk9QxDzCzn7QCvVYeW7XuGyWSpH0eP6SyuxS75Eb/akOpn302LFYi8SiO8bJ5PK9DhFxV/j0yH8zOnzoWr6+SbhbifkMSwSsgByk1zzsoABFKZY2QNgGpiW57Pdrx2z3JCeI99Svvxh7g8muf2x" target="_blank" rel="noreferrer" style="box-sizing: border-box; background-color: transparent; touch-action: manipulation; color: var(--vt-c-brand); text-decoration-line: inherit; text-decoration-thickness: inherit; text-decoration-style: dotted; text-decoration-color: inherit; font-weight: 500; transition: color 0.25s;"></a></p></details><h2 id="处理-v-model-修饰符"><a href="#处理-v-model-修饰符" class="headerlink" title="处理 v-model 修饰符"></a>处理 <code>v-model</code> 修饰符</h2><p>​在学习输入绑定时，我们知道了 <code>v-model</code> 有一些<a href="https://cn.vuejs.org/guide/essentials/forms.html#modifiers">内置的修饰符</a>，例如 <code>.trim</code>，<code>.number</code> 和 <code>.lazy</code>。在某些场景下，你可能想要一个自定义组件的 <code>v-model</code> 支持自定义的修饰符。</p><p>​我们来创建一个自定义的修饰符 <code>capitalize</code>，它会自动将 <code>v-model</code> 绑定输入的字符串值第一个字母转为大写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent v-model.capitalize=&quot;myText&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​通过像这样解构 <code>defineModel()</code> 的返回值，可以在子组件中访问添加到组件 <code>v-model</code> 的修饰符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const [model, modifiers] = defineModel()<br><br>console.log(modifiers) // &#123; capitalize: true &#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input type=&quot;text&quot; v-model=&quot;model&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>​为了能够基于修饰符选择性地调节值的读取和写入方式，我们可以给 <code>defineModel()</code> 传入 <code>get</code> 和 <code>set</code> 这两个选项。这两个选项在从模型引用中读取或设置值时会接收到当前的值，并且它们都应该返回一个经过处理的新值。下面是一个例子，展示了如何利用 <code>set</code> 选项来应用 <code>capitalize</code> (首字母大写) 修饰符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const [model, modifiers] = defineModel(&#123;<br>  set(value) &#123;<br>    if (modifiers.capitalize) &#123;<br>      return value.charAt(0).toUpperCase() + value.slice(1)<br>    &#125;<br>    return value<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input type=&quot;text&quot; v-model=&quot;model&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNp9UsFu2zAM/RVClzhY5mzoLUgHdEUPG9Bt2LLTtIPh0Ik6WxIkyosb5N9LybFrFG1OkvgeyccnHsWNtXkbUKzE2pdOWQKPFOwnqVVjjSM4gsMKTlA508CMqbMRuu9uDd80ajrD+XISi3WZDCB1abQnaLoNHgiuY8VsNptLvV72TbkdPwgbWxeE/ALY7JUHpW0gKAurqKjVI3rAFl1He6V30JkA3AbdKvLXUzXt+8Zssc6fM6+l6NtLAUtusF6O3cRCvFB9yY2SiYFw+8KSYcY/qfEC+FCVQuf/8rxbrJTG+4hkxyiWq2ZtUQecQ3oDqAqyMWeieyQAu0bBaUh5ebkv3A1lH+Y5md/WorstPGZzeHfGfa1KzD6yxzH11B/TCjHC4dPlX1j3P0CdjQ5S79/Z3WhpPF91lDz7Uald/uCNZj/TFFJE91SN7rslxX5JsRrmk6Koa/P/a4qRC7gY4uUey3+vxB/8Icak+OHQo2tRihGjwu2QtUb47te3pHsEWXWomX0B/Ine1CFq7Gmfg96y7Akvqf2StoKXcePvDoTaD0NFocnhxJeClyRu2FujP8u9yq+GnxGnJxSEO+M=">在演练场中尝试一下</a></p><details style="box-sizing: border-box; display: block;"><summary style="box-sizing: border-box; display: list-item; touch-action: manipulation; margin-bottom: 1.2em; width: fit-content; cursor: pointer;">3.4 之前的用法</summary><div class="language-vue" style="box-sizing: border-box; position: relative; margin: 28px 0px; background-color: rgb(41, 45, 62); overflow-x: auto; transition: background-color 0.5s; border-radius: 8px;"><button title="Copy Code" class="copy" style="box-sizing: border-box; font-family: inherit; font-size: 16px; line-height: inherit; margin: 0px; overflow: visible; text-transform: none; appearance: button; touch-action: manipulation; border: 0px; padding: 0px; color: inherit; background-color: rgb(41, 45, 62); background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='20' width='20' stroke='rgba(128,128,128,1)' stroke-width='2' viewBox='0 0 24 24'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2M9 5a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2M9 5a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2'/%3E%3C/svg%3E&quot;); cursor: pointer; position: absolute; top: 4px; right: 4px; z-index: 3; display: block; justify-content: center; align-items: center; border-radius: 4px; width: 40px; height: 40px; opacity: 0; background-position: 50% center; background-size: 20px; background-repeat: no-repeat; transition: opacity 0.4s;"></button><span class="lang" style="box-sizing: border-box; position: absolute; top: 4px; right: 10px; z-index: 2; font-size: 12px; font-weight: 500; color: var(--vt-c-text-dark-3); transition: color 0.5s;"></span><pre class="shiki github-dark vp-code" tabindex="0" style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: 1em; margin: 0px; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; position: relative; z-index: 1; padding: 14px 0px; background: transparent; overflow-x: auto;"><code style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: var(--vt-doc-code-font-size); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; display: block; padding: 0px 24px; width: fit-content; min-width: 100%; line-height: var(--vt-doc-code-line-height); color: rgb(166, 172, 205); transition: color 0.5s;"><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(121, 184, 255);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(121, 184, 255);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(255, 171, 112);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line highlighted" style="box-sizing: border-box; background-color: rgba(0, 0, 0, 0.3); transition: background-color 0.5s; margin: 0px -24px; padding: 0px 24px; width: calc(100% + 48px); display: inline-block;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line highlighted" style="box-sizing: border-box; background-color: rgba(0, 0, 0, 0.3); transition: background-color 0.5s; margin: 0px -24px; padding: 0px 24px; width: calc(100% + 48px); display: inline-block;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(121, 184, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(121, 184, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line highlighted" style="box-sizing: border-box; background-color: rgba(0, 0, 0, 0.3); transition: background-color 0.5s; margin: 0px -24px; padding: 0px 24px; width: calc(100% + 48px); display: inline-block;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span></code></pre></div><p style="box-sizing: border-box; margin: 0px 0px 1.2em;"><a href="https://play.vuejs.org/#eNp9Us1Og0AQfpUJF5ZYqV4JNTaNxyYmVi/igdCh3QR2N7tDIza8u7NLpdU0nmB+v5/ZY7Q0Jj10GGVR7iorDYFD6sxDoWRrtCU4gsUaBqitbiHm1ngqrfuV5j+Fik7ldH6R83u5GaBQlVaOoO03+Emw8BtFHCeFyucjKMNxQNiapiTkCGCzlw6kMh1BVRpJZSO/0AEe0Pa0l2oHve6AYdBmvj+/ZHO4bfUWm/Q8uSiiEb6IYM4A+XxCi2bRH9ZX3BgVGKuNYwFbrKXCZx+Jo0cPcG9l02EGL2SZ3mxKr/VW1hKty9hMniy7hjIQCSweQByHBIZCDWzGDwi20ps0Yjxx4MR73Jktc83OOPFHGKk7VZHUKkyFgsAEAqcG2Qif4WWYUml3yOp8wldlDSLISX+TvPDstAemLeGbVvvSLkncJSnpV2PQrkqHLOfmVHeNrFDcMz3w0iBQE1cUzMYBbuS2f55CPj4D6o0/I41HzMKsP+u0kLOPoZWzkx1X7j18A8s0DEY=" target="_blank" rel="noreferrer" style="box-sizing: border-box; background-color: transparent; touch-action: manipulation; color: var(--vt-c-brand); text-decoration-line: inherit; text-decoration-thickness: inherit; text-decoration-style: dotted; text-decoration-color: inherit; font-weight: 500; transition: color 0.25s;"></a></p></details><h3 id="带参数的-v-model-修饰符"><a href="#带参数的-v-model-修饰符" class="headerlink" title="带参数的 v-model 修饰符"></a>带参数的 <code>v-model</code> 修饰符</h3><p>​这里是另一个例子，展示了如何在使用多个不同参数的 <code>v-model</code> 时使用修饰符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;UserName<br>  v-model:first-name.capitalize=&quot;first&quot;<br>  v-model:last-name.uppercase=&quot;last&quot;<br>/&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const [firstName, firstNameModifiers] = defineModel(&#x27;firstName&#x27;)<br>const [lastName, lastNameModifiers] = defineModel(&#x27;lastName&#x27;)<br><br>console.log(firstNameModifiers) // &#123; capitalize: true &#125;<br>console.log(lastNameModifiers) // &#123; uppercase: true &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模板</title>
    <link href="/z-%E6%A8%A1%E6%9D%BF/"/>
    <url>/z-%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>vue进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搭建自己的MQTT服务器、实现设备上云(Windows+EMQX)</title>
    <link href="/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建自己的MQTT服务器、实现设备上云-Windows-EMQX"><a href="#搭建自己的MQTT服务器、实现设备上云-Windows-EMQX" class="headerlink" title="搭建自己的MQTT服务器、实现设备上云(Windows+EMQX)"></a>搭建自己的MQTT服务器、实现设备上云(Windows+EMQX)</h1><h2 id="一、EMQX介绍"><a href="#一、EMQX介绍" class="headerlink" title="一、EMQX介绍"></a>一、EMQX介绍</h2><h3 id="1-1-EMQX介绍"><a href="#1-1-EMQX介绍" class="headerlink" title="1.1 EMQX介绍"></a>1.1 EMQX介绍</h3><p>​<strong>EMQX是一款大规模可弹性伸缩的云原生分布式物联网MQTT消息服务器</strong>。它是完全开源的，基于Apache 2.0许可证，且自2013年起已经有200+的开源版本迭代。EMQX提供了三种服务：云服务版本、商业版和开源版。</p><p>​作为一款MQTT消息服务器，EMQX支持MQTT 5.0和3.x协议标准，具有更好的伸缩性、安全性和可靠性。在性能上，单节点支持500万MQTT设备连接，集群可扩展至1亿并发MQTT连接。同时，它能支持每秒实时接收、移动、处理与分发数百万条的MQTT消息，消息分发与投递时延低于1毫秒。</p><p>​EMQX还有一些高级特性，如采用Masterless的大规模分布式集群架构，实现系统高可用和水平扩展。此外，它还内置了强大的规则引擎，支持一站式数据提取、过滤与转换，并能灵活集成SQL、NoSQL、时序数据库，及Kafka等流处理中间件。</p><p>​<strong>EMQX支持跨平台部署</strong>，可以在<strong>Linux、Windows、MacOS、ARM嵌入系统</strong>等平台进行部署。生产环境下，推荐在<strong>CentOS、Ubuntu、Debian等Linux发行版</strong>上进行部署，不建议使用Windows。</p><p>帮助文档：<a href="https://www.emqx.io/docs/zh/v5.2/">https://www.emqx.io/docs/zh/v5.2/</a></p><h3 id="1-2-MQTT核心概念"><a href="#1-2-MQTT核心概念" class="headerlink" title="1.2 MQTT核心概念"></a>1.2 MQTT核心概念</h3><p>​MQTT（消息队列遥测传输）是物联网（Internet of Things）中最常用的轻量级消息协议。该协议基于发布&#x2F;订阅（pub&#x2F;sub）模式进行消息通信，允许设备和应用程序实时交换数据，使用简单有效的消息格式，最大限度地减少网络开销并降低功耗。</p><p>​作为MQTT消息平台，EMQX Enterprise为完整的MQTT消息功能提供全面支持。</p><h3 id="1-3-发布-订阅模式"><a href="#1-3-发布-订阅模式" class="headerlink" title="1.3 发布&#x2F;订阅模式"></a>1.3 发布&#x2F;订阅模式</h3><p>​该协议是事件驱动的，并使用发布&#x2F;订阅模式连接设备。与传统的客户端&#x2F;服务器模式不同，它是一种消息传递模式，其中发送方（发布者）不直接将消息发送给特定的接收方（订阅者）。相反，发布者将消息分类为不同的主题，订阅者订阅他们感兴趣的主题。当发布者向主题发送消息时，MQTT代理路由并过滤所有传入消息，然后将其传递给对该主题表达兴趣的所有订阅者。</p><p>​发布者和订阅者彼此解耦，不需要知道对方的存在。他们之间的唯一连接基于预定的消息协议。发布&#x2F;订阅模式支持灵活的消息通信，因为可以根据需要动态添加或删除订阅者和发布者。它还使消息广播、多播和单播的实现更加容易。</p><h3 id="1-4-MQTT服务器"><a href="#1-4-MQTT服务器" class="headerlink" title="1.4 MQTT服务器"></a>1.4 MQTT服务器</h3><p>​MQTT服务器充当发布客户端和订阅客户端之间的代理，将所有收到的消息转发给匹配的订阅客户端。因此，有时服务器被直接称为MQTT代理。</p><h3 id="1-5-MQTT客户端"><a href="#1-5-MQTT客户端" class="headerlink" title="1.5 MQTT客户端"></a>1.5 MQTT客户端</h3><p>​客户端是指可以使用MQTT协议连接到MQTT服务器的设备或应用程序。它们既可以充当发布者和订阅者，也可以单独担任这两个角色中的任何一个。在MQTT通信中，客户端可以向服务器发布消息，同时也可以订阅一个或多个主题以接收来自其他客户端的消息。通过这种方式，MQTT客户端能够在物联网环境中实现高效、实时的数据传输和交互。</p><h3 id="1-6-主题与通配符"><a href="#1-6-主题与通配符" class="headerlink" title="1.6 主题与通配符"></a>1.6 主题与通配符</h3><p>​在MQTT中，主题是用于识别和区分不同消息的，构成了MQTT消息路由的基础。发布者在发布消息时可以指定消息的主题，而订阅者可以选择订阅感兴趣的主题以接收相关消息。</p><p>​为了实现一次订阅多个主题的目标，订阅者在订阅主题时可以使用通配符。MQTT提供了两种类型的主题通配符，单级通配符和多级通配符，以满足不同的订阅需求。</p><ul><li>单级通配符：+ 用于匹配主题中的一个级别。</li><li>多级通配符：# 用于匹配主题中的多个级别。</li></ul><p>​通过使用这两种通配符，订阅者可以灵活地订阅一系列相关的主题，而不仅仅是一个具体的主题。</p><h3 id="1-7-服务质量（QoS）"><a href="#1-7-服务质量（QoS）" class="headerlink" title="1.7 服务质量（QoS）"></a>1.7 服务质量（QoS）</h3><p>​MQTT定义了三个级别的QoS，以提供不同级别的消息可靠性。每个消息在发布时可以独立设置自己的QoS。</p><ul><li>QoS 0：最多传递一次消息，可能会丢失；</li><li>QoS 1：至少传递一次消息，保证到达，但可能会重复；</li><li>QoS 2：精确传递一次消息，保证到达且不重复。</li></ul><p>​随着QoS级别的增加，消息传输的复杂性也增加。需要根据实际情况选择合适的QoS级别。</p><p>​在选择QoS级别时，需权衡消息传递的可靠性和网络资源的消耗。例如，在网络资源有限但对消息可靠性要求不高的情况下，可以选择QoS 0；而在对消息可靠性要求较高，且能容忍一定网络资源消耗的场景中，可以选择QoS 1或QoS 2。</p><h2 id="二、Windows下安装EMQX"><a href="#二、Windows下安装EMQX" class="headerlink" title="二、Windows下安装EMQX"></a>二、Windows下安装EMQX</h2><h3 id="2-1-官网地址"><a href="#2-1-官网地址" class="headerlink" title="2.1 官网地址"></a>2.1 官网地址</h3><p>链接：<a href="https://www.emqx.io/downloads?os=Windows">https://www.emqx.io/downloads?os=Windows</a></p><h3 id="2-2-下载EMQX"><a href="#2-2-下载EMQX" class="headerlink" title="2.2 下载EMQX"></a>2.2 下载EMQX</h3><p>【1】点击下载压缩包。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/2407b2f644a4e6b45120b936adf42923.png" alt="image-20231107141257677"></p><p>【2】下载后解压。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/8dd6e1397d9fe2a220ffbb9d90c5d20d.png" alt="image-20231107141403129"></p><h3 id="2-3-打开PowerShell命令行"><a href="#2-3-打开PowerShell命令行" class="headerlink" title="2.3 打开PowerShell命令行"></a>2.3 打开PowerShell命令行</h3><p>​鼠标右键点击Windows左下角的<code>windows图标</code>，弹出对话框，选择 <code>Windows PowerShell</code>，打开命令行窗口。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/09af657e7db6ec3a525cb05901acc050.png" alt="image-20231107141620856"></p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/a80499bae9dd5c5d82a7a01dda20530f.png" alt="image-20231107141454298"></p><h3 id="2-4-启动EMQX"><a href="#2-4-启动EMQX" class="headerlink" title="2.4 启动EMQX"></a>2.4 启动EMQX</h3><p>【1】进入到刚才EMQX解压的目录。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/699b021ee1dbb9c1cf8ad7e06871de4b.png" alt="image-20231107141752015"></p><p>【2】在 <code>Windows PowerShell</code>命令行窗口，输入cd命令切换路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cd C:\Users\<span class="hljs-number">11266</span>\Downloads\emqx<span class="hljs-number">-5.3</span><span class="hljs-number">.0</span>-windows-amd64<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/ff05200f2f57d7b953e2b2d49077ea03.png" alt="image-20231107142102289"></p><p>【3】输入命令启动EMQX</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">.\bin\emqx start<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>启动的时候会弹出防火墙提示窗口，记得点击 允许访问 。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/b044aa261ab22d9c63b6d51fd74433be.png" alt="image-20231107142237380"></p><p><strong>启动成功的提示如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PS C:\Users\<span class="hljs-number">11266</span>\Downloads\emqx<span class="hljs-number">-5.3</span><span class="hljs-number">.0</span>-windows-amd64&gt; .\bin\emqx start<br>EMQX_NODE__DB_ROLE [node.role]: core<br>EMQX_NODE__DB_BACKEND [node.db_backend]: mnesia<br>PS C:\Users\<span class="hljs-number">11266</span>\Downloads\emqx<span class="hljs-number">-5.3</span><span class="hljs-number">.0</span>-windows-amd64&gt;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/2850a220b3aa47de8866f6152043e76f.png" alt="image-20231107142332199"></p><h3 id="2-5-EMQX常用的命令"><a href="#2-5-EMQX常用的命令" class="headerlink" title="2.5 EMQX常用的命令"></a>2.5 EMQX常用的命令</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PS C:\Users\<span class="hljs-number">11266</span>\Downloads\emqx<span class="hljs-number">-5.3</span><span class="hljs-number">.0</span>-windows-amd64&gt; .\bin\emqx<br>usage: <span class="hljs-built_in">emqx</span> (install|uninstall|start|stop|restart|console|ping|ctl|list|remote_console|attach)<br>    <br>.\bin\emqx start    启动<br>.\bin\emqx stop     停止<br>.\bin\emqx restart  重启 <br><span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><h2 id="三、配置EMQX服务器"><a href="#三、配置EMQX服务器" class="headerlink" title="三、配置EMQX服务器"></a>三、配置EMQX服务器</h2><h3 id="3-1-登录EMQX内置管理控制台"><a href="#3-1-登录EMQX内置管理控制台" class="headerlink" title="3.1 登录EMQX内置管理控制台"></a>3.1 登录EMQX内置管理控制台</h3><p>​EMQX 提供了一个内置的管理控制台，即 EMQX Dashboard。方便用户通过 Web 页面就能轻松管理和监控 EMQX 集群，并配置和使用所需的各项功能。</p><p>​在浏览器里输入: <code>http://127.0.0.1:18083</code> 就可以访问EMQX的后台管理页面。可以管理以连接的客户端或检查运行状态。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/ad63a846472107d2b30a151f332384cc.png" alt="image-20231107142801182"></p><p>默认用户名和密码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">用户名：<span class="hljs-keyword">admin</span><br>密码：<span class="hljs-built_in">public</span><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>第一次登录会提示你修改新密码，如果不想设置，也可以选择跳过。</p><p>登录成功的页面显示如下：</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/75a41e84ebfa7c7540d9c34a65c8d073.png" alt="image-20231107142950152"></p><h3 id="3-2-MQTT配置"><a href="#3-2-MQTT配置" class="headerlink" title="3.2 MQTT配置"></a>3.2 MQTT配置</h3><p><a href="http://127.0.0.1:18083/#/mqtt/general">http://127.0.0.1:18083/#/mqtt/general</a></p><p>这里可以配置MQTT的一些参数，根据自己的需求进行配置。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/20a7ae21f4c97c37013b4c47dc5d4f34.png" alt="image-20231107144529825"></p><h3 id="3-3-测试MQTT通信"><a href="#3-3-测试MQTT通信" class="headerlink" title="3.3 测试MQTT通信"></a>3.3 测试MQTT通信</h3><p><a href="http://127.0.0.1:18083/#/websocket">http://127.0.0.1:18083/#/websocket</a></p><p>新建一个客户端，点击连接。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/f5900ae8869135ebaac511ecf8ab0b28.png" alt="image-20231107152330895"></p><p>连接之后，然后点击订阅，和发布，如果下面消息能正常的接收。说明MQTT服务器通信是已经正常，没问题了。</p><p>并且在这个页面也可以看到<code>主题发布</code>和<code>主题订阅</code>的格式。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/a2984de68f77d98c08ad7263bf9c792e.png" alt="image-20231107152608232"></p><h3 id="3-4-MQTT客户端登录服务器测试"><a href="#3-4-MQTT客户端登录服务器测试" class="headerlink" title="3.4 MQTT客户端登录服务器测试"></a>3.4 MQTT客户端登录服务器测试</h3><p>​接下来就打开我们自己的MQTT客户端登录MQTT服务器进行测试数据的通信。</p><p>​端口选择: 1883</p><p>​根据软件参数填入参数，登录，进行主题的发布和订阅。</p><p>​<strong>说明： 目前还没有配置客户端认证，现在只要IP和端口输入正确，MQTT三元组可以随便输入，都可以登录上服务器的，服务器没有对三元组做校验。</strong></p><p>​[EMQ X](<a href="https://so.csdn.net/so/search?q=EMQ">https://so.csdn.net/so/search?q=EMQ</a> X&amp;spm&#x3D;1001.2101.3001.7020) 默认配置中启用了匿名认证，任何客户端都能接入 EMQX。没有启用认证插件或认证插件没有显式允许&#x2F;拒绝（ignore）连接请求时，EMQX 将根据匿名认证启用情况决定是否允许客户端连接。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/db5ff00ea446b143c374c051a804d541.png" alt="image-20231107152927778"></p><p><a href="http://127.0.0.1:18083/#/clients">http://127.0.0.1:18083/#/clients</a></p><p>然后打开<code>EMQX</code>的管理后台，可以看到我们的设备已经登录服务器了，名字为<code>test1</code>。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/38fab98b7caaecb712964287f0ad96aa.png" alt="image-20231107153020452"></p><p>在订阅主题的页面也可以看到我们客户端设备订阅的主题。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/cdce062429cdef9eb39d4ce39fed2e3b.png" alt="image-20231107153156526"></p><h3 id="3-5-客户端认证配置"><a href="#3-5-客户端认证配置" class="headerlink" title="3.5 客户端认证配置"></a>3.5 客户端认证配置</h3><p>​EMQX 默认配置中启用了匿名认证，任何客户端都能接入 EMQX。没有启用认证插件或认证插件没有显式允许&#x2F;拒绝（ignore）连接请求时，EMQX 将根据匿名认证启用情况决定是否允许客户端连接。</p><p>在正式产品里肯定是要启用认证的，不然任何设备都能接入。</p><p><strong>下面就介绍如何配置 客户端认证。</strong></p><p><a href="http://127.0.0.1:18083/#/authentication">http://127.0.0.1:18083/#/authentication</a></p><p>【1】打开客户端认证页面</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/d26114afb45568a8dde1b062f9fb2590.png" alt="image-20231107160746380"></p><p>【2】选择密码认证</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/480dba8007b4ad5eefd3ebab713e5142.png" alt="image-20231107160844450"></p><p>【3】选择内置数据库</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/48e3f1085ebc873e66c7c8ac89c59bcb.png" alt="image-20231107160916912"></p><p>【4】设置认证方式（都可以默认，不用改），直接点击创建。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/b3314cd17a1659584c064363e05dff66.png" alt="image-20231107161002220"></p><p>【5】创建成功后，点击用户管理</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/0dcf9377a9bf89ea8cc08825b9779e77.png" alt="image-20231107161043692"></p><p>【6】添加用户</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/af320de5942e28239b12b107114659c2.png" alt="image-20231107161154596"></p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/440fe920c97a8da6afae809788605e41.png" alt="image-20231107161254779"></p><p>【7】添加成功</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/b91fceb1c037ea210239e178f63ab02d.png" alt="image-20231107161317252"></p><p>【8】添加完毕之后，打开MQTT客户端可以进行测试。</p><p>登录的时候，MQTT用户名和密码必须输入正确，按照上一步添加的信息进行如实填写，否则是无法登录服务器的。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/bb34f56886aeb9faeb9785cd94eb9a07.png" alt="image-20231107161438124"></p><h3 id="3-6-客户端授权配置"><a href="#3-6-客户端授权配置" class="headerlink" title="3.6 客户端授权配置"></a>3.6 客户端授权配置</h3><p>​客户端授权页面可以配置每个客户端(设备)的主题发布，订阅权限。限制它是否可以发布主题，订阅主题。 如果有需要就可以进行配置。</p><p><a href="http://127.0.0.1:18083/#/authorization/detail/built_in_database?tab=users">http://127.0.0.1:18083/#/authorization/detail/built_in_database?tab=users</a></p><p>【1】创建数据源</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/b48682ee3c85ad4af0bd5db193b105d8.png" alt="image-20231107153705954"></p><p>【2】选择内置数据库</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/f1671c12a9c5f84cdffb3e7c299b1317.png" alt="image-20231107153725972"></p><p>【3】完成创建</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/9e58326990fbbec13994736feacda377.png" alt="image-20231107153746654"></p><p>【4】点击权限管理</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/62cb0da366d261b53bf77c7512c00db3.png" alt="image-20231107153810651"></p><p>【5】选择客户端ID，点击添加</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/4616938ae76e1414dc19f77bde251b7a.png" alt="image-20231107153902413"></p><p>【6】配置权限</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/d992482b58417f39477b586e83013248.png" alt="image-20231107161803875"></p><h3 id="3-7-数据转发-集成"><a href="#3-7-数据转发-集成" class="headerlink" title="3.7 数据转发(集成)"></a>3.7 数据转发(集成)</h3><p>​在集成选项里，可以对设备数据处理。 比如：转发到自己的HTTP服务器，转发到自己其他的MQTT服务器，创建规则，某些事件触发某些动作等等。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/3a3efecda69e23f43d6e517bbdaffa0e.png" alt="image-20231107225638965"></p><p><strong>选择数据桥接。</strong></p><p>可以把数据发送端自己的HTTP服务器，或者发送到其他的MQTT服务器。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/97a39d4319fae400abf1f91605b29826.png" alt="image-20231107225815739"></p><p>选择HTTP服务 （如果自己有HTTP服务器，可以将数据转发给自己的HTTP服务器）。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/b746b75d5986bfd34799f2819bdb4819.png" alt="image-20231107225942506"></p><h2 id="四、MQTT客户端消息互发测试"><a href="#四、MQTT客户端消息互发测试" class="headerlink" title="四、MQTT客户端消息互发测试"></a>四、MQTT客户端消息互发测试</h2><h3 id="4-1-添加2个设备"><a href="#4-1-添加2个设备" class="headerlink" title="4.1 添加2个设备"></a>4.1 添加2个设备</h3><p>为了方便测试设备间互相订阅主题，数据收发，在客户端认证页面至少添加2个设备。我这里分别添加了<code>test1</code>和<code>test2</code>。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/2263162a9bb5a97a953718e1c0fd168f.png" alt="image-20231107163706657"></p><h3 id="4-2-设备间测试"><a href="#4-2-设备间测试" class="headerlink" title="4.2 设备间测试"></a>4.2 设备间测试</h3><p>设备A订阅设备B的主题，设备B订阅设备A的主题，实现数据互发。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/727e794c7d4863255fa2dc6c37181951.png" alt="image-20231107164156741"></p><p><strong>设备A的MQTT信息：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MQTT服务器地址：<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>MQTT服务器端口号：<span class="hljs-number">1883</span><br>MQTT客户端ID：AAA<br>MQTT用户名：test1<br>MQTT登录密码：<span class="hljs-number">12345678</span><br><br>订阅主题：BBB/#<br>发布主题：AAA/<span class="hljs-number">1</span><br>发布的消息：&#123; <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;我是AAA设备&quot;</span> &#125;<br><span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure><p><strong>设备B的MQTT信息：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MQTT服务器地址：<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>MQTT服务器端口号：<span class="hljs-number">1883</span><br>MQTT客户端ID：BBB<br>MQTT用户名：test2<br>MQTT登录密码：<span class="hljs-number">12345678</span><br><br>订阅主题：AAA/#<br>发布主题：BBB/<span class="hljs-number">1</span><br>发布的消息：&#123; <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;我是BBB设备&quot;</span> &#125;<br><span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure><h3 id="4-3-MQTT实时图传测试"><a href="#4-3-MQTT实时图传测试" class="headerlink" title="4.3 MQTT实时图传测试"></a>4.3 MQTT实时图传测试</h3><p>下面演示，利用MQTT协议进行图像传输。</p><p>​这是打包好的APP，0积分可以下载，下载下来就可以测试图传：<br><a href="https://download.csdn.net/download/xiaolong1126626497/88512661">https://download.csdn.net/download/xiaolong1126626497/88512661</a></p><p>​这是MQTT协议图传上位机的Qt源码，如果需要源码的可以到这里下载：<br><a href="https://download.csdn.net/download/xiaolong1126626497/87614468">https://download.csdn.net/download/xiaolong1126626497/87614468</a></p><p>​这是Qt的工程，利用Qt开发的图传软件，分别为发送端和接收端。</p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/c40086b6b2a21f04a0a20630da5eeb9a.png" alt="image-20231107172033585"></p><p><strong>运行效果：</strong> 进行图传效果是非常的好。 <strong>报文最大一次可以发送 256MB</strong></p><p><img src="/../img/%E5%85%B6%E4%BB%96-%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/b460547a5747c2a69c651df8329e7c68.png" alt="image-20231107172328140"></p><h2 id="五、单片机设备上云"><a href="#五、单片机设备上云" class="headerlink" title="五、单片机设备上云"></a>五、单片机设备上云</h2><p>​只要是MQTT客户端能正常上云通信了，那么单片机也是一样的。</p><p>​目前是介绍本地部署，如果想在云端部署，直接买一个ECS云服务器，购买一个公网IP地址就可以了，在云端服务器部署好EMQX就可以正常像阿里云IOT、OneNet、华为云IOT之类的服务器一样使用了。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Props</title>
    <link href="/vue%E8%BF%9B%E9%98%B6-Props/"/>
    <url>/vue%E8%BF%9B%E9%98%B6-Props/</url>
    
    <content type="html"><![CDATA[<h2 id="Props-声明"><a href="#Props-声明" class="headerlink" title="Props 声明"></a>Props 声明</h2><p>​一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute (关于透传 attribute，我们会在<a href="https://cn.vuejs.org/guide/components/attrs.html">专门的章节</a>中讨论)。</p><p>​在使用 <code>&lt;script setup&gt;</code> 的单文件组件中，props 可以使用 <code>defineProps()</code> 宏来声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const props = defineProps([&#x27;foo&#x27;])<br><br>console.log(props.foo)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​在没有使用 <code>&lt;script setup&gt;</code> 的组件中，props 可以使用 <a href="https://cn.vuejs.org/api/options-state.html#props"><code>props</code></a> 选项来声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;foo&#x27;</span>],<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-comment">// setup() 接收 props 作为第一个参数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props.<span class="hljs-property">foo</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​注意传递给 <code>defineProps()</code> 的参数和提供给 <code>props</code> 选项的值是相同的，两种声明方式背后其实使用的都是 props 选项。</p><p>​除了使用字符串数组来声明 props 外，还可以使用对象的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用 &lt;script setup&gt;</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,<br>  <span class="hljs-attr">likes</span>: <span class="hljs-title class_">Number</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 非 &lt;script setup&gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">likes</span>: <span class="hljs-title class_">Number</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​对于以对象形式声明的每个属性，key 是 prop 的名称，而值则是该 prop 预期类型的构造函数。比如，如果要求一个 prop 的值是 <code>number</code> 类型，则可使用 <code>Number</code> 构造函数作为其声明的值。</p><p>​对象形式的 props 声明不仅可以一定程度上作为组件的文档，而且如果其他开发者在使用你的组件时传递了错误的类型，也会在浏览器控制台中抛出警告。我们将在本章节稍后进一步讨论有关 <a href="https://cn.vuejs.org/guide/components/props.html#prop-validation">prop 校验</a>的更多细节。</p><p>​如果你正在搭配 TypeScript 使用 <code>&lt;script setup&gt;</code>，也可以使用类型标注来声明 props：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>defineProps&lt;&#123;<br>  title?: string<br>  likes?: number<br>&#125;&gt;()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​更多关于基于类型的声明的细节请参考<a href="https://cn.vuejs.org/guide/typescript/composition-api.html#typing-component-props">组件 props 类型标注</a>。</p><h2 id="响应式-Props-解构"><a href="#响应式-Props-解构" class="headerlink" title="响应式 Props 解构"></a>响应式 Props 解构</h2><p>​Vue 的响应系统基于属性访问跟踪状态的使用情况。例如，在计算属性或侦听器中访问 <code>props.foo</code> 时，<code>foo</code> 属性将被跟踪为依赖项。</p><p>​因此，在以下代码的情况下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; foo &#125; = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;foo&#x27;</span>])<br><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在 3.5 之前只运行一次</span><br>  <span class="hljs-comment">// 在 3.5+ 中在 &quot;foo&quot; prop 变化时重新执行</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<br>&#125;)<br></code></pre></td></tr></table></figure><p>​在 3.4 及以下版本，<code>foo</code> 是一个实际的常量，永远不会改变。在 3.5 及以上版本，当在同一个 <code>&lt;script setup&gt;</code> 代码块中访问由 <code>defineProps</code> 解构的变量时，Vue 编译器会自动在前面添加 <code>props.</code>。因此，上面的代码等同于以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;foo&#x27;</span>])<br><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// `foo` 由编译器转换为 `props.foo`</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props.<span class="hljs-property">foo</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>​此外，你可以使用 JavaScript 原生的默认值语法声明 props 默认值。这在使用基于类型的 props 声明时特别有用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> &#123; foo = <span class="hljs-string">&#x27;hello&#x27;</span> &#125; = defineProps&lt;&#123; foo?: <span class="hljs-built_in">string</span> &#125;&gt;()<br></code></pre></td></tr></table></figure><p>​如果你希望在 IDE 中在解构的 props 和普通变量之间有更多视觉上的区分，Vue 的 VSCode 扩展提供了一个设置来启用解构 props 的内联提示。</p><h3 id="将解构的-props-传递到函数中"><a href="#将解构的-props-传递到函数中" class="headerlink" title="将解构的 props 传递到函数中"></a>将解构的 props 传递到函数中</h3><p>​当我们将解构的 prop 传递到函数中时，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; foo &#125; = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;foo&#x27;</span>])<br><br><span class="hljs-title function_">watch</span>(foo, <span class="hljs-comment">/* ... */</span>)<br></code></pre></td></tr></table></figure><p>​这并不会按预期工作，因为它等价于 <code>watch(props.foo, ...)</code>——我们给 <code>watch</code> 传递的是一个值而不是响应式数据源。实际上，Vue 的编译器会捕捉这种情况并发出警告。</p><p>​与使用 <code>watch(() =&gt; props.foo, ...)</code> 来侦听普通 prop 类似，我们也可以通过将其包装在 getter 中来侦听解构的 prop：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> foo, <span class="hljs-comment">/* ... */</span>)<br></code></pre></td></tr></table></figure><p>​此外，当我们需要传递解构的 prop 到外部函数中并保持响应性时，这是推荐做法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useComposable</span>(<span class="hljs-function">() =&gt;</span> foo)<br></code></pre></td></tr></table></figure><p>​外部函数可以调用 getter (或使用 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#tovalue">toValue</a> 进行规范化) 来追踪提供的 prop 变更。例如，在计算属性或侦听器的 getter 中。</p><h1 id="传递-prop-的细节"><a href="#传递-prop-的细节" class="headerlink" title="传递 prop 的细节"></a>传递 prop 的细节</h1><h3 id="Prop-名字格式"><a href="#Prop-名字格式" class="headerlink" title="Prop 名字格式"></a>Prop 名字格式</h3><p>​如果一个 prop 的名字很长，应使用 camelCase 形式，因为它们是合法的 JavaScript 标识符，可以直接在模板的表达式中使用，也可以避免在作为属性 key 名时必须加上引号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">greetingMessage</span>: <span class="hljs-title class_">String</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;span&gt;&#123;&#123; greetingMessage &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure><p>​虽然理论上你也可以在向子组件传递 props 时使用 camelCase 形式 (使用 <a href="https://cn.vuejs.org/guide/essentials/component-basics.html#in-dom-template-parsing-caveats">DOM 内模板</a>时例外)，但实际上为了和 HTML attribute 对齐，我们通常会将其写为 kebab-case 形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent greeting-message=&quot;hello&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​对于组件名我们推荐使用 <a href="https://cn.vuejs.org/guide/components/registration.html#component-name-casing">PascalCase</a>，因为这提高了模板的可读性，能帮助我们区分 Vue 组件和原生 HTML 元素。然而对于传递 props 来说，使用 camelCase 并没有太多优势，因此我们推荐更贴近 HTML 的书写风格。</p><h3 id="静态-vs-动态-Props"><a href="#静态-vs-动态-Props" class="headerlink" title="静态 vs. 动态 Props"></a>静态 vs. 动态 Props</h3><p>​至此，你已经见过了很多像这样的静态值形式的 props：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;BlogPost title=&quot;My journey with Vue&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​相应地，还有使用 <code>v-bind</code> 或缩写 <code>:</code> 来进行动态绑定的 props：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 根据一个变量的值动态传入 --&gt;<br>&lt;BlogPost :title=&quot;post.title&quot; /&gt;<br><br>&lt;!-- 根据一个更复杂表达式的值动态传入 --&gt;<br>&lt;BlogPost :title=&quot;post.title + &#x27; by &#x27; + post.author.name&quot; /&gt;<br></code></pre></td></tr></table></figure><h3 id="传递不同的值类型"><a href="#传递不同的值类型" class="headerlink" title="传递不同的值类型"></a>传递不同的值类型</h3><p>​在上述的两个例子中，我们只传入了字符串值，但实际上<strong>任何</strong>类型的值都可以作为 props 的值被传递。</p><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 虽然 `42` 是个常量，我们还是需要使用 v-bind --&gt;<br>&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;<br>&lt;BlogPost :likes=&quot;42&quot; /&gt;<br><br>&lt;!-- 根据一个变量的值动态传入 --&gt;<br>&lt;BlogPost :likes=&quot;post.likes&quot; /&gt;<br></code></pre></td></tr></table></figure><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 仅写上 prop 但不传值，会隐式转换为 `true` --&gt;<br>&lt;BlogPost is-published /&gt;<br><br>&lt;!-- 虽然 `false` 是静态的值，我们还是需要使用 v-bind --&gt;<br>&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;<br>&lt;BlogPost :is-published=&quot;false&quot; /&gt;<br><br>&lt;!-- 根据一个变量的值动态传入 --&gt;<br>&lt;BlogPost :is-published=&quot;post.isPublished&quot; /&gt;<br></code></pre></td></tr></table></figure><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 虽然这个数组是个常量，我们还是需要使用 v-bind --&gt;<br>&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;<br>&lt;BlogPost :comment-ids=&quot;[234, 266, 273]&quot; /&gt;<br><br>&lt;!-- 根据一个变量的值动态传入 --&gt;<br>&lt;BlogPost :comment-ids=&quot;post.commentIds&quot; /&gt;<br></code></pre></td></tr></table></figure><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 虽然这个对象字面量是个常量，我们还是需要使用 v-bind --&gt;<br>&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;<br>&lt;BlogPost<br>  :author=&quot;&#123;<br>    name: &#x27;Veronica&#x27;,<br>    company: &#x27;Veridian Dynamics&#x27;<br>  &#125;&quot;<br> /&gt;<br><br>&lt;!-- 根据一个变量的值动态传入 --&gt;<br>&lt;BlogPost :author=&quot;post.author&quot; /&gt;<br></code></pre></td></tr></table></figure><h3 id="使用一个对象绑定多个-prop"><a href="#使用一个对象绑定多个-prop" class="headerlink" title="使用一个对象绑定多个 prop"></a>使用一个对象绑定多个 prop</h3><p>​如果你想要将一个对象的所有属性都当作 props 传入，你可以使用<a href="https://cn.vuejs.org/guide/essentials/template-syntax.html#dynamically-binding-multiple-attributes">没有参数的 <code>v-bind</code></a>，即只使用 <code>v-bind</code> 而非 <code>:prop-name</code>。例如，这里有一个 <code>post</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> post = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;My Journey with Vue&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​以及下面的模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;BlogPost v-bind=&quot;post&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​而这实际上等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;BlogPost :id=&quot;post.id&quot; :title=&quot;post.title&quot; /&gt;<br></code></pre></td></tr></table></figure><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>​所有的 props 都遵循着<strong>单向绑定</strong>原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。</p><p>​另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你<strong>不应该</strong>在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;foo&#x27;</span>])<br><br><span class="hljs-comment">// ❌ 警告！prop 是只读的！</span><br>props.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure><p>​导致你想要更改一个 prop 的需求通常来源于以下两种场景：</p><ol><li><p><strong>prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性</strong>。在这种情况下，最好是新定义一个局部数据属性，从 props 上获取初始值即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;initialCounter&#x27;</span>])<br><br><span class="hljs-comment">// 计数器只是将 props.initialCounter 作为初始值</span><br><span class="hljs-comment">// 像下面这样做就使 prop 和后续更新无关了</span><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">ref</span>(props.<span class="hljs-property">initialCounter</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>需要对传入的 prop 值做进一步的转换</strong>。在这种情况中，最好是基于该 prop 值定义一个计算属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;size&#x27;</span>])<br><br><span class="hljs-comment">// 该 prop 变更时计算属性也会自动更新</span><br><span class="hljs-keyword">const</span> normalizedSize = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> props.<span class="hljs-property">size</span>.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">toLowerCase</span>())<br></code></pre></td></tr></table></figure></li></ol><h3 id="更改对象-数组类型的-props"><a href="#更改对象-数组类型的-props" class="headerlink" title="更改对象 &#x2F; 数组类型的 props"></a>更改对象 &#x2F; 数组类型的 props</h3><p>​当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然<strong>可以</strong>更改对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，对 Vue 来说，阻止这种更改需要付出的代价异常昂贵。</p><p>​这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。在大多数场景下，子组件应该<a href="https://cn.vuejs.org/guide/components/events.html">抛出一个事件</a>来通知父组件做出改变。</p><h2 id="Prop-校验"><a href="#Prop-校验" class="headerlink" title="Prop 校验"></a>Prop 校验</h2><p>​Vue 组件可以更细致地声明对传入的 props 的校验要求。比如我们上面已经看到过的类型声明，如果传入的值不满足类型要求，Vue 会在浏览器控制台中抛出警告来提醒使用者。这在开发给其他开发者使用的组件时非常有用。</p><p>​要声明对 props 的校验，你可以向 <code>defineProps()</code> 宏提供一个带有 props 校验选项的对象，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-comment">// 基础类型检查</span><br>  <span class="hljs-comment">// （给出 `null` 和 `undefined` 值则会跳过任何类型检查）</span><br>  <span class="hljs-attr">propA</span>: <span class="hljs-title class_">Number</span>,<br>  <span class="hljs-comment">// 多种可能的类型</span><br>  <span class="hljs-attr">propB</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>],<br>  <span class="hljs-comment">// 必传，且为 String 类型</span><br>  <span class="hljs-attr">propC</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-comment">// 必传但可为 null 的字符串</span><br>  <span class="hljs-attr">propD</span>: &#123;<br>    <span class="hljs-attr">type</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-literal">null</span>],<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-comment">// Number 类型的默认值</span><br>  <span class="hljs-attr">propE</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-number">100</span><br>  &#125;,<br>  <span class="hljs-comment">// 对象类型的默认值</span><br>  <span class="hljs-attr">propF</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,<br>    <span class="hljs-comment">// 对象或数组的默认值</span><br>    <span class="hljs-comment">// 必须从一个工厂函数返回。</span><br>    <span class="hljs-comment">// 该函数接收组件所接收到的原始 prop 作为参数。</span><br>    <span class="hljs-title function_">default</span>(<span class="hljs-params">rawProps</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 自定义类型校验函数</span><br>  <span class="hljs-comment">// 在 3.4+ 中完整的 props 作为第二个参数传入</span><br>  <span class="hljs-attr">propG</span>: &#123;<br>    <span class="hljs-title function_">validator</span>(<span class="hljs-params">value, props</span>) &#123;<br>      <span class="hljs-comment">// The value must match one of these strings</span><br>      <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-string">&#x27;danger&#x27;</span>].<span class="hljs-title function_">includes</span>(value)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 函数类型的默认值</span><br>  <span class="hljs-attr">propH</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Function</span>,<br>    <span class="hljs-comment">// 不像对象或数组的默认，这不是一个</span><br>    <span class="hljs-comment">// 工厂函数。这会是一个用来作为默认值的函数</span><br>    <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Default function&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>​<code>defineProps()</code> 宏中的参数<strong>不可以访问 <code>&lt;script setup&gt;</code> 中定义的其他变量</strong>，因为在编译时整个表达式都会被移到外部的函数中。</p><p>一些补充细节：</p><ul><li>所有 prop 默认都是可选的，除非声明了 <code>required: true</code>。</li><li>除 <code>Boolean</code> 外的未传递的可选 prop 将会有一个默认值 <code>undefined</code>。</li><li><code>Boolean</code> 类型的未传递 prop 将被转换为 <code>false</code>。这可以通过为它设置 <code>default</code> 来更改——例如：设置为 <code>default: undefined</code> 将与非布尔类型的 prop 的行为保持一致。</li><li>如果声明了 <code>default</code> 值，那么在 prop 的值被解析为 <code>undefined</code> 时，无论 prop 是未被传递还是显式指明的 <code>undefined</code>，都会改为 <code>default</code> 值。</li></ul><p>​当 prop 的校验失败后，Vue 会抛出一个控制台警告 (在开发模式下)。</p><p>​如果使用了<a href="https://cn.vuejs.org/api/sfc-script-setup.html#type-only-props-emit-declarations">基于类型的 prop 声明</a> ，Vue 会尽最大努力在运行时按照 prop 的类型标注进行编译。举例来说，<code>defineProps&lt;&#123; msg: string &#125;&gt;</code> 会被编译为 <code>&#123; msg: &#123; type: String, required: true &#125;&#125;</code>。</p><h3 id="运行时类型检查"><a href="#运行时类型检查" class="headerlink" title="运行时类型检查"></a>运行时类型检查</h3><p>校验选项中的 <code>type</code> 可以是下列这些原生构造函数：</p><ul><li><code>String</code></li><li><code>Number</code></li><li><code>Boolean</code></li><li><code>Array</code></li><li><code>Object</code></li><li><code>Date</code></li><li><code>Function</code></li><li><code>Symbol</code></li><li><code>Error</code></li></ul><p>​另外，<code>type</code> 也可以是自定义的类或构造函数，Vue 将会通过 <code>instanceof</code> 来检查类型是否匹配。例如下面这个类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName, lastName</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = lastName<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​你可以将其作为一个 prop 的类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">author</span>: <span class="hljs-title class_">Person</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>​Vue 会通过 <code>instanceof Person</code> 来校验 <code>author</code> prop 的值是否是 <code>Person</code> 类的一个实例。</p><h3 id="可为-null-的类型"><a href="#可为-null-的类型" class="headerlink" title="可为 null 的类型"></a>可为 null 的类型</h3><p>​如果该类型是必传但可为 null 的，你可以用一个包含 <code>null</code> 的数组语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">id</span>: &#123;<br>    <span class="hljs-attr">type</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-literal">null</span>],<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>​注意如果 <code>type</code> 仅为 <code>null</code> 而非使用数组语法，它将允许任何类型。</p><h2 id="Boolean-类型转换"><a href="#Boolean-类型转换" class="headerlink" title="Boolean 类型转换"></a>Boolean 类型转换</h2><p>​为了更贴近原生 boolean attributes 的行为，声明为 <code>Boolean</code> 类型的 props 有特别的类型转换规则。以带有如下声明的 <code>&lt;MyComponent&gt;</code> 组件为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: <span class="hljs-title class_">Boolean</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>​该组件可以被这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 等同于传入 :disabled=&quot;true&quot; --&gt;<br>&lt;MyComponent disabled /&gt;<br><br>&lt;!-- 等同于传入 :disabled=&quot;false&quot; --&gt;<br>&lt;MyComponent /&gt;<br></code></pre></td></tr></table></figure><p>​当一个 prop 被声明为允许多种类型时，<code>Boolean</code> 的转换规则也将被应用。然而，当同时允许 <code>String</code> 和 <code>Boolean</code> 时，有一种边缘情况——只有当 <code>Boolean</code> 出现在 <code>String</code> 之前时，<code>Boolean</code> 转换规则才适用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Boolean</span>, <span class="hljs-title class_">Number</span>]<br>&#125;)<br><br><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Boolean</span>, <span class="hljs-title class_">String</span>]<br>&#125;)<br><br><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Number</span>, <span class="hljs-title class_">Boolean</span>]<br>&#125;)<br><br><span class="hljs-comment">// disabled 将被解析为空字符串 (disabled=&quot;&quot;)</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Boolean</span>]<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>组件基础</title>
    <link href="/vue%E5%9F%BA%E7%A1%80-%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <url>/vue%E5%9F%BA%E7%A1%80-%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h1><p>​组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。在实际应用中，组件常常被组织成一个层层嵌套的树状结构：</p><p><img src="/../img/vue-%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/image-20241224161949530-17350283926022.png" alt="image-20241224161949530"></p><p>​这和我们嵌套 HTML 元素的方式类似，Vue 实现了自己的组件模型，使我们可以在每个组件内封装自定义内容与逻辑。Vue 同样也能很好地配合原生 Web Component。如果你想知道 Vue 组件与原生 Web Components 之间的关系</p><h2 id="定义一个组件"><a href="#定义一个组件" class="headerlink" title="定义一个组件"></a>定义一个组件</h2><p>​当使用构建步骤时，我们一般会将 Vue 组件定义在一个单独的 <code>.vue</code> 文件中，这被叫做<a href="https://cn.vuejs.org/guide/scaling-up/sfc.html">单文件组件</a> (简称 SFC)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const count = ref(0)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>​当不使用构建步骤时，一个 Vue 组件以一个包含 Vue 特定选项的 JavaScript 对象来定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> &#123; count &#125;<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;button @click=&quot;count++&quot;&gt;</span><br><span class="hljs-string">      You clicked me &#123;&#123; count &#125;&#125; times.</span><br><span class="hljs-string">    &lt;/button&gt;`</span><br>  <span class="hljs-comment">// 也可以针对一个 DOM 内联模板：</span><br>  <span class="hljs-comment">// template: &#x27;#my-template-element&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​这里的模板是一个内联的 JavaScript 字符串，Vue 将会在运行时编译它。你也可以使用 ID 选择器来指向一个元素 (通常是原生的 <code>&lt;template&gt;</code> 元素)，Vue 将会使用其内容作为模板来源。</p><p>​上面的例子中定义了一个组件，并在一个 <code>.js</code> 文件里默认导出了它自己，但你也可以通过具名导出在一个文件中导出多个组件。</p><h2 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h2><p>​我们会在接下来的指引中使用单文件组件语法，无论你是否使用构建步骤，组件相关的概念都是相同的。<a href="https://cn.vuejs.org/examples/">示例</a>一节中展示了两种场景中的组件使用情况。</p><p>​要使用一个子组件，我们需要在父组件中导入它。假设我们把计数器组件放在了一个叫做 <code>ButtonCounter.vue</code> 的文件中，这个组件将会以默认导出的形式被暴露给外部。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import ButtonCounter from &#x27;./ButtonCounter.vue&#x27;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;h1&gt;Here is a child component!&lt;/h1&gt;<br>  &lt;ButtonCounter /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>通过 <code>&lt;script setup&gt;</code>，导入的组件都在模板中直接可用。</p><p>​当然，你也可以全局地注册一个组件，使得它在当前应用中的任何组件上都可以使用，而不需要额外再导入。关于组件的全局注册和局部注册两种方式的利弊，我们放在了<a href="https://cn.vuejs.org/guide/components/registration.html">组件注册</a>这一章节中专门讨论。</p><p>组件可以被重用任意多次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;h1&gt;Here is a child component!&lt;/h1&gt;<br>&lt;ButtonCounter /&gt;<br>&lt;ButtonCounter /&gt;<br>&lt;ButtonCounter /&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNqVj91KAzEQhV/lmJsqlY3eSlr8ufEVhNys6ZQGNz8kE0GWfXez2SJUsdCLuZiZM9+ZM4qnGLvPQuJBqGySjYxMXOJWe+tiSIznwhz8SyieKWGfgsOqkyfTGbDSXsmFUG9rw+Ti0DPNHavD/faVEqGv5Xr/BXOwww4mVBNPnvOVklXTtKeO8qKhkj++4lb8+fL/mCMS7TEdAy6BtDfBZ65fVgA2s+L67uZMUEC9N0s8msGaj40W7Xa91qKtgbdQ0Ha0gyOM45E+TWDrKHeNIhfMr0DTN4U0me8=">在演练场中尝试一下</a></p><p>​你会注意到，每当点击这些按钮时，每一个组件都维护着自己的状态，是不同的 <code>count</code>。这是因为每当你使用一个组件，就创建了一个新的<strong>实例</strong>。</p><p>​在单文件组件中，推荐为子组件使用 <code>PascalCase</code> 的标签名，以此来和原生的 HTML 元素作区分。虽然原生 HTML 标签名是不区分大小写的，但 Vue 单文件组件是可以在编译中区分大小写的。我们也可以使用 <code>/&gt;</code> 来关闭一个标签。</p><p>​如果你是直接在 DOM 中书写模板 (例如原生 <code>&lt;template&gt;</code> 元素的内容)，模板的编译需要遵从浏览器中 HTML 的解析行为。在这种情况下，你应该需要使用 <code>kebab-case</code> 形式并显式地关闭这些组件的标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 如果是在 DOM 中书写该模板 --&gt;<br>&lt;button-counter&gt;&lt;/button-counter&gt;<br>&lt;button-counter&gt;&lt;/button-counter&gt;<br>&lt;button-counter&gt;&lt;/button-counter&gt;<br></code></pre></td></tr></table></figure><h1 id="传递-props"><a href="#传递-props" class="headerlink" title="传递 props"></a>传递 props</h1><p>​如果我们正在构建一个博客，我们可能需要一个表示博客文章的组件。我们希望所有的博客文章分享相同的视觉布局，但有不同的内容。要实现这样的效果自然必须向组件中传递数据，例如每篇文章标题和内容，这就会使用到 props。</p><p>​Props 是一种特别的 attributes，你可以在组件上声明注册。要传递给博客文章组件一个标题，我们必须在组件的 props 列表上声明它。这里要用到 <a href="https://cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits"><code>defineProps</code></a> 宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- BlogPost.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;title&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>​<code>defineProps</code> 是一个仅 <code>&lt;script setup&gt;</code> 中可用的编译宏命令，并不需要显式地导入。声明的 props 会自动暴露给模板。<code>defineProps</code> 会返回一个对象，其中包含了可以传递给组件的所有 props：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;title&#x27;</span>])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props.<span class="hljs-property">title</span>)<br></code></pre></td></tr></table></figure><p>TypeScript 用户请参考：<a href="https://cn.vuejs.org/guide/typescript/composition-api.html#typing-component-props">为组件 props 标注类型</a></p><p>​如果你没有使用 <code>&lt;script setup&gt;</code>，props 必须以 <code>props</code> 选项的方式声明，props 对象会作为 <code>setup()</code> 函数的第一个参数被传入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;title&#x27;</span>],<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props.<span class="hljs-property">title</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个组件可以有任意多的 props，默认情况下，所有 prop 都接受任意类型的值。</p><p>当一个 prop 被注册后，可以像这样以自定义 attribute 的形式传递数据给它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;BlogPost title=&quot;My journey with Vue&quot; /&gt;<br>&lt;BlogPost title=&quot;Blogging with Vue&quot; /&gt;<br>&lt;BlogPost title=&quot;Why Vue is so fun&quot; /&gt;<br></code></pre></td></tr></table></figure><p>在实际应用中，我们可能在父组件中会有如下的一个博客文章数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> posts = <span class="hljs-title function_">ref</span>([<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;My journey with Vue&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Blogging with Vue&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Why Vue is so fun&#x27;</span> &#125;<br>])<br></code></pre></td></tr></table></figure><p>这种情况下，我们可以使用 <code>v-for</code> 来渲染它们：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;BlogPost<br>  v-for=&quot;post in posts&quot;<br>  :key=&quot;post.id&quot;<br>  :title=&quot;post.title&quot;<br> /&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNp9kU9PhDAUxL/KpBfWBCH+OZEuid5N9qSHrQezFKhC27RlDSF8d1tYQBP1+N78OpN5HciD1sm54yQj1J6M0A6Wu07nTIpWK+MwwPASI0qjWkQejVbpsVHVQVl30ZJ0WQRHjwFMnpT0gPZLi32w2h2DMEAUGW5iOOEaniF66vGuOiN5j0/hajx7B4zxxt5ubIiphKz+IO828qXugw5hYRXKTnqSydcrJmk61/VF/eB4q5s3x8Pk6FJjauDO16Uye0ZCBwg5d2EkkED2wfuLlogibMOTbMpf9tMwP8jpeiMfRdM1l8Tk+/F++Y6Cl0Lyg1Ha7o7R5Bn9WwSg9X0+DPMxMI409fPP1PELlVmwdQ==">在演练场中尝试一下</a></p><p>​留意我们是如何使用 <a href="https://cn.vuejs.org/api/built-in-directives.html#v-bind"><code>v-bind</code> 语法</a> (<code>:title=&quot;post.title&quot;</code>) 来传递动态 prop 值的。当事先不知道要渲染的确切内容时，这一点特别有用。</p><p>​以上就是目前你需要了解的关于 props 的全部了。如果你看完本章节后还想知道更多细节，我们推荐你深入阅读关于 props 的<a href="https://cn.vuejs.org/guide/components/props.html">完整指引</a>。</p><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>​让我们继续关注我们的 <code>&lt;BlogPost&gt;</code> 组件。我们会发现有时候它需要与父组件进行交互。例如，要在此处实现无障碍访问的需求，将博客文章的文字能够放大，而页面的其余部分仍使用默认字号。</p><p>在父组件中，我们可以添加一个 <code>postFontSize</code> ref 来实现这个效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> posts = <span class="hljs-title function_">ref</span>([<br>  <span class="hljs-comment">/* ... */</span><br>])<br><br><span class="hljs-keyword">const</span> postFontSize = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>在模板中用它来控制所有博客文章的字体大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;&#123; fontSize: postFontSize + &#x27;em&#x27; &#125;&quot;&gt;<br>  &lt;BlogPost<br>    v-for=&quot;post in posts&quot;<br>    :key=&quot;post.id&quot;<br>    :title=&quot;post.title&quot;<br>   /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>然后，给 <code>&lt;BlogPost&gt;</code> 组件添加一个按钮：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- BlogPost.vue, 省略了 &lt;script&gt; --&gt;<br>&lt;template&gt;<br>  &lt;div class=&quot;blog-post&quot;&gt;<br>    &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;<br>    &lt;button&gt;Enlarge text&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>​这个按钮目前还没有做任何事情，我们想要点击这个按钮来告诉父组件它应该放大所有博客文章的文字。要解决这个问题，组件实例提供了一个自定义事件系统。父组件可以通过 <code>v-on</code> 或 <code>@</code> 来选择性地监听子组件上抛的事件，就像监听原生 DOM 事件那样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;BlogPost<br>  ...<br>  @enlarge-text=&quot;postFontSize += 0.1&quot;<br> /&gt;<br></code></pre></td></tr></table></figure><p>子组件可以通过调用内置的 <a href="https://cn.vuejs.org/api/component-instance.html#emit"><strong><code>$emit</code></strong> 方法</a>，通过传入事件名称来抛出一个事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- BlogPost.vue, 省略了 &lt;script&gt; --&gt;<br>&lt;template&gt;<br>  &lt;div class=&quot;blog-post&quot;&gt;<br>    &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;<br>    &lt;button @click=&quot;$emit(&#x27;enlarge-text&#x27;)&quot;&gt;Enlarge text&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>因为有了 <code>@enlarge-text=&quot;postFontSize += 0.1&quot;</code> 的监听，父组件会接收这一事件，从而更新 <code>postFontSize</code> 的值。</p><p><a href="https://play.vuejs.org/#eNp1Uk1PwkAQ/SuTxqQYgYp6ahaiJngzITHRA/UAZQor7W7TnaK16X93th8UEuHEvPdm5s3bls5Tmo4POTq+I0yYyZTAIOXpLFAySXVGUEKGEVQQZToBl6XukXqO9XahDbXc2OsAO5FlAIEKtWJByqCBqR01WFqiBLnxYTIEkhSjD+5rAV86zxQW8C1pB+88Aaphr73rtXbNVqrtBeV9r/zYFZYHacBoiHLFykB9Xgfq1NmLVvQmf7E1OGFaeE0anAMXhEkarwhtRWIjD+AbKmKcBk4JUdvtn8+6ARcTu87hLuCf6NJpSoDDKNIZj7BtIFUTUuB0tL/HomXHcnOC18d1TF305COqeJVtcUT4Q62mtzSF2/GkE8/E8b1qh8Ljw/if8I7nOkPn9En/+Ug2GEmFi0ynZrB0azOujbfB54kki5+aqumL8bING28Yr4xh+2vePrI39CnuHmZl2TwwVJXwuG6ZdU6kFTyGsQz33HyFvH5wvvyaB80bACwgvKbrYgLVH979DQc=">在演练场中尝试一下</a></p><p>我们可以通过 <a href="https://cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits"><code>defineEmits</code></a> 宏来声明需要抛出的事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- BlogPost.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;title&#x27;])<br>defineEmits([&#x27;enlarge-text&#x27;])<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​这声明了一个组件可能触发的所有事件，还可以对事件的参数进行<a href="https://cn.vuejs.org/guide/components/events.html#validate-emitted-events">验证</a>。同时，这还可以让 Vue 避免将它们作为原生事件监听器隐式地应用于子组件的根元素。</p><p>​和 <code>defineProps</code> 类似，<code>defineEmits</code> 仅可用于 <code>&lt;script setup&gt;</code> 之中，并且不需要导入，它返回一个等同于 <code>$emit</code> 方法的 <code>emit</code> 函数。它可以被用于在组件的 <code>&lt;script setup&gt;</code> 中抛出事件，因为此处无法直接访问 <code>$emit</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const emit = defineEmits([&#x27;enlarge-text&#x27;])<br><br>emit(&#x27;enlarge-text&#x27;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>TypeScript 用户请参考：<a href="https://cn.vuejs.org/guide/typescript/composition-api.html#typing-component-emits">为组件 emits 标注类型</a></p><p>​如果你没有在使用 <code>&lt;script setup&gt;</code>，你可以通过 <code>emits</code> 选项定义组件会抛出的事件。你可以从 <code>setup()</code> 函数的第二个参数，即 setup 上下文对象上访问到 <code>emit</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;enlarge-text&#x27;</span>],<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, ctx</span>) &#123;<br>    ctx.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;enlarge-text&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="通过插槽来分配内容"><a href="#通过插槽来分配内容" class="headerlink" title="通过插槽来分配内容"></a>通过插槽来分配内容</h1><p>一些情况下我们会希望能和 HTML 元素一样向组件中传递内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;AlertBox&gt;<br>  Something bad happened.<br>&lt;/AlertBox&gt;<br></code></pre></td></tr></table></figure><p>我们期望能渲染成这样：</p><p><img src="/../img/vue-%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/image-20241224162431047-17350286720763.png" alt="image-20241224162431047"></p><p>这可以通过 Vue 的自定义 <code>&lt;slot&gt;</code> 元素来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- AlertBox.vue --&gt;<br>&lt;template&gt;<br>  &lt;div class=&quot;alert-box&quot;&gt;<br>    &lt;strong&gt;This is an Error for Demo Purposes&lt;/strong&gt;<br>    &lt;slot /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.alert-box &#123;<br>  /* ... */<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>如上所示，我们使用 <code>&lt;slot&gt;</code> 作为一个占位符，父组件传递进来的内容就会渲染在这里。</p><p><a href="https://play.vuejs.org/#eNpVUEtOwzAQvcpgFt3QBBCqUAiRisQJ2GbjxG4a4Xis8aQKqnp37PyUyqv3mZn3fBVH55JLr0Umcl9T6xi85t4VpW07h8RwNJr4Cwc4EXawS9KFiGO70ubpNBcmAmDdOSNZR8T5Yg0IoOQf7DSfW9tAJRWcpXPaapWM1nVt8ObpukY8ie29GHNzAiBX7QVqI73/LIWMzn2FQylGMcieCW1TfBMhPYSoE5zFitLVZ5BhQnkadt6nGKt5/jMafI1Oq8Ak6zW4xrEaDVIGj4fD4SPiCknpQLy4ATyaVgFptVH2JFXb+wze3DDSTioV/iaD1+eZqWT92xD2Vu2X7af3+IJ6G7/UToVigpJnTzwTO42eWDnELsTtH/wUqH4=">在演练场中尝试一下</a></p><p>​以上就是目前你需要了解的关于插槽的所有知识了。如果你看完本章节后还想知道更多细节，请深入阅读<a href="https://cn.vuejs.org/guide/components/slots.html">组件插槽</a>章节。</p><h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><p>有些场景会需要在两个组件间来回切换，比如 Tab 界面：</p><p><a href="https://play.vuejs.org/#eNqNVMGOmzAQ/ZURe2BXCiHbrXpwk1X31mMPvS1V5RiTWAEb2SZNhPLvHdvggLZRE6TIM/P8/N5gpk/e2nZ57HhCkrVhWrQWDLdd+1pI0bRKW/iuGg6VVg2ky9wFDp7G8g9lrIl1H80Bb5rtxfFKMcRzUA+aV3AZQKEEhWRKGgus05pL+5NuYeNwj6mTkT4VckRYujVY63GT17twC6/Fr4YjC3kp5DoPNtEgBpY3bU0txwhgXYojsJoasymSkjeqSHweK9vOWoUbXIC/Y1YpjaDH3wt39hMI6TUUSYSQAz8jArPT5Mj+nmIhC6zpAu1TZlEhmXndbBwpXH5NGL6xWrADMsyaMj1lkAzQ92E7mvYe8nCcM24xZApbL5ECiHCSnP73KyseGnvh6V/XedwS2pVjv3C1ziddxNDYc+2WS9fC8E4qJW1W0UbUZwKGSpMZrkX11dW2SpdcE3huT2BULUp44JxPSpmmpegMgU/tyadbWpZC7jCxwj0v+OfTDdU7ITOrWiTjzTS3Vei8IfB5xHZ4PmqoObMEJHryWXXkuqrVn+xEgHZWYRKbh06uLyv4iQq+oIDnkXSQiwKymlc26n75WNdit78FmLWCMeZL+GKMwlKrhLRcBzhlh51WnSwJPFQr9/zLdIZ007w/O6bR4MQe2bseBJMzer5yzwf8MtzbOzYMkNsOY0+HfoZv1d+lZJGMg8fNqdsfbbio4b77uRVv7I0Li8xxZN1PHWbeHdyTWXc/+zgw/8t/+QsROe9h">在演练场中查看示例</a></p><p>上面的例子是通过 Vue 的 <code>&lt;component&gt;</code> 元素和特殊的 <code>is</code> attribute 实现的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- currentTab 改变时组件也改变 --&gt;<br>&lt;component :is=&quot;tabs[currentTab]&quot;&gt;&lt;/component&gt;<br></code></pre></td></tr></table></figure><p>在上面的例子中，被传给 <code>:is</code> 的值可以是以下几种：</p><ul><li>被注册的组件名</li><li>导入的组件对象</li></ul><p>你也可以使用 <code>is</code> attribute 来创建一般的 HTML 元素。</p><p>​当使用 <code>&lt;component :is=&quot;...&quot;&gt;</code> 来在多个组件间作切换时，被切换掉的组件会被卸载。我们可以通过<a href="https://cn.vuejs.org/guide/built-ins/keep-alive.html">keep-alive</a>强制被切换掉的组件仍然保持“存活”的状态。</p><h2 id="DOM-内模板解析注意事项"><a href="#DOM-内模板解析注意事项" class="headerlink" title="DOM 内模板解析注意事项"></a>DOM 内模板解析注意事项</h2><p>​如果你想在 DOM 中直接书写 Vue 模板，Vue 则必须从 DOM 中获取模板字符串。由于浏览器的原生 HTML 解析行为限制，有一些需要注意的事项。</p><p>​请注意下面讨论只适用于直接在 DOM 中编写模板的情况。如果你使用来自以下来源的字符串模板，就不需要顾虑这些限制了：</p><ul><li>单文件组件</li><li>内联模板字符串 (例如 <code>template: &#39;...&#39;</code>)</li><li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li></ul><h3 id="大小写区分"><a href="#大小写区分" class="headerlink" title="大小写区分"></a>大小写区分</h3><p>​HTML 标签和属性名称是不分大小写的，所以浏览器会把任何大写的字符解释为小写。这意味着当你使用 DOM 内的模板时，无论是 PascalCase 形式的组件名称、camelCase 形式的 prop 名称还是 v-on 的事件名称，都需要转换为相应等价的 kebab-case (短横线连字符) 形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// JavaScript 中的 camelCase</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">BlogPost</span> = &#123;<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;postTitle&#x27;</span>],<br>  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;updatePost&#x27;</span>],<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;</span><br><span class="hljs-string">  `</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- HTML 中的 kebab-case --&gt;<br>&lt;blog-post post-title=&quot;hello!&quot; @update-post=&quot;onUpdatePost&quot;&gt;&lt;/blog-post&gt;<br></code></pre></td></tr></table></figure><h3 id="闭合标签"><a href="#闭合标签" class="headerlink" title="闭合标签"></a>闭合标签</h3><p>我们在上面的例子中已经使用过了闭合标签 (self-closing tag)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent /&gt;<br></code></pre></td></tr></table></figure><p>这是因为 Vue 的模板解析器支持任意标签使用 <code>/&gt;</code> 作为标签关闭的标志。</p><p>然而在 DOM 内模板中，我们必须显式地写出关闭标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;my-component&gt;&lt;/my-component&gt;<br></code></pre></td></tr></table></figure><p>​这是由于 HTML 只允许<a href="https://html.spec.whatwg.org/multipage/syntax.html#void-elements">一小部分特殊的元素</a>省略其关闭标签，最常见的就是 <code>&lt;input&gt;</code> 和 <code>&lt;img&gt;</code>。对于其他的元素来说，如果你省略了关闭标签，原生的 HTML 解析器会认为开启的标签永远没有结束，用下面这个代码片段举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;my-component /&gt; &lt;!-- 我们想要在这里关闭标签... --&gt;<br>&lt;span&gt;hello&lt;/span&gt;<br></code></pre></td></tr></table></figure><p>将被解析为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;my-component&gt;<br>  &lt;span&gt;hello&lt;/span&gt;<br>&lt;/my-component&gt; &lt;!-- 但浏览器会在这里关闭标签 --&gt;<br></code></pre></td></tr></table></figure><h3 id="元素位置限制"><a href="#元素位置限制" class="headerlink" title="元素位置限制"></a>元素位置限制</h3><p>​某些 HTML 元素对于放在其中的元素类型有限制，例如 <code>&lt;ul&gt;</code>，<code>&lt;ol&gt;</code>，<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，相应的，某些元素仅在放置于特定元素中时才会显示，例如 <code>&lt;li&gt;</code>，<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>。</p><p>​这将导致在使用带有此类限制元素的组件时出现问题。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;table&gt;<br>  &lt;blog-post-row&gt;&lt;/blog-post-row&gt;<br>&lt;/table&gt;<br></code></pre></td></tr></table></figure><p>​自定义的组件 <code>&lt;blog-post-row&gt;</code> 将作为无效的内容被忽略，因而在最终呈现的输出中造成错误。我们可以使用特殊的 <a href="https://cn.vuejs.org/api/built-in-special-attributes.html#is"><code>is</code> attribute</a> 作为一种解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;table&gt;<br>  &lt;tr is=&quot;vue:blog-post-row&quot;&gt;&lt;/tr&gt;<br>&lt;/table&gt;<br></code></pre></td></tr></table></figure><p>​当使用在原生 HTML 元素上时，<code>is</code> 的值必须加上前缀 <code>vue:</code> 才可以被解析为一个 Vue 组件。这一点是必要的，为了避免和原生的<a href="https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example">自定义内置元素</a>相混淆。</p>]]></content>
    
    
    <categories>
      
      <category>vue基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模板引用</title>
    <link href="/vue%E5%9F%BA%E7%A1%80-%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8/"/>
    <url>/vue%E5%9F%BA%E7%A1%80-%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h1><p>​虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 <code>ref</code> attribute：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input ref=&quot;input&quot;&gt;<br></code></pre></td></tr></table></figure><p>​<code>ref</code> 是一个特殊的 attribute，和 <code>v-for</code> 章节中提到的 <code>key</code> 类似。它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库。</p><h2 id="访问模板引用"><a href="#访问模板引用" class="headerlink" title="访问模板引用"></a>访问模板引用</h2><p>​要在组合式 API 中获取引用，我们可以使用辅助函数 <a href="https://cn.vuejs.org/api/composition-api-helpers.html#usetemplateref"><code>useTemplateRef()</code></a> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; useTemplateRef, onMounted &#125; from &#x27;vue&#x27;<br><br>// 第一个参数必须与模板中的 ref 值匹配<br>const input = useTemplateRef(&#x27;my-input&#x27;)<br><br>onMounted(() =&gt; &#123;<br>  input.value.focus()<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input ref=&quot;my-input&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>​在使用 TypeScript 时，Vue 的 IDE 支持和 <code>vue-tsc</code> 将根据匹配的 <code>ref</code> attribute 所用的元素或组件自动推断 <code>inputRef.value</code> 的类型。</p><details style="box-sizing: border-box; display: block;"><summary style="box-sizing: border-box; display: list-item; touch-action: manipulation; margin-bottom: 1.2em; width: fit-content; cursor: pointer;">3.5 前的用法</summary><p style="box-sizing: border-box; margin: 0px 0px 1.2em;"><code style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: var(--vt-doc-code-font-size); background-color: var(--vt-c-bg-mute); padding: 0.15em 0.5em; border-radius: 4px; color: var(--vt-c-text-code); transition: color 0.5s, background-color 0.5s; white-space: nowrap;"></code></p><div class="language-vue" style="box-sizing: border-box; position: relative; margin: 28px 0px; background-color: rgb(41, 45, 62); overflow-x: auto; transition: background-color 0.5s; border-radius: 8px;"><button title="Copy Code" class="copy" style="box-sizing: border-box; font-family: inherit; font-size: 16px; line-height: inherit; margin: 0px; overflow: visible; text-transform: none; appearance: button; touch-action: manipulation; border: 0px; padding: 0px; color: inherit; background-color: rgb(41, 45, 62); background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='20' width='20' stroke='rgba(128,128,128,1)' stroke-width='2' viewBox='0 0 24 24'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2M9 5a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2M9 5a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2'/%3E%3C/svg%3E&quot;); cursor: pointer; position: absolute; top: 4px; right: 4px; z-index: 3; display: block; justify-content: center; align-items: center; border-radius: 4px; width: 40px; height: 40px; opacity: 0; background-position: 50% center; background-size: 20px; background-repeat: no-repeat; transition: opacity 0.4s;"></button><span class="lang" style="box-sizing: border-box; position: absolute; top: 4px; right: 10px; z-index: 2; font-size: 12px; font-weight: 500; color: var(--vt-c-text-dark-3); transition: color 0.5s;"></span><pre class="shiki github-dark vp-code" tabindex="0" style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: 1em; margin: 0px; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; position: relative; z-index: 1; padding: 14px 0px; background: transparent; overflow-x: auto;"><code style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: var(--vt-doc-code-font-size); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; display: block; padding: 0px 24px; width: fit-content; min-width: 100%; line-height: var(--vt-doc-code-line-height); color: rgb(166, 172, 205); transition: color 0.5s;"><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(106, 115, 125);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(106, 115, 125);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(121, 184, 255);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(121, 184, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span></code></pre></div><p style="box-sizing: border-box; margin: 0px 0px 1.2em;"><code style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: var(--vt-doc-code-font-size); background-color: var(--vt-c-bg-mute); padding: 0.15em 0.5em; border-radius: 4px; color: var(--vt-c-text-code); transition: color 0.5s, background-color 0.5s; white-space: nowrap;"></code><code style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: var(--vt-doc-code-font-size); background-color: var(--vt-c-bg-mute); padding: 0.15em 0.5em; border-radius: 4px; color: var(--vt-c-text-code); transition: color 0.5s, background-color 0.5s; white-space: nowrap;"></code></p><div class="language-js" style="box-sizing: border-box; position: relative; margin: 28px 0px; background-color: rgb(41, 45, 62); overflow-x: auto; transition: background-color 0.5s; border-radius: 8px;"><button title="Copy Code" class="copy" style="box-sizing: border-box; font-family: inherit; font-size: 16px; line-height: inherit; margin: 0px; overflow: visible; text-transform: none; appearance: button; touch-action: manipulation; border: 0px; padding: 0px; color: inherit; background-color: rgb(41, 45, 62); background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='20' width='20' stroke='rgba(128,128,128,1)' stroke-width='2' viewBox='0 0 24 24'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2M9 5a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2M9 5a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2'/%3E%3C/svg%3E&quot;); cursor: pointer; position: absolute; top: 4px; right: 4px; z-index: 3; display: block; justify-content: center; align-items: center; border-radius: 4px; width: 40px; height: 40px; opacity: 0; background-position: 50% center; background-size: 20px; background-repeat: no-repeat; transition: opacity 0.4s;"></button><span class="lang" style="box-sizing: border-box; position: absolute; top: 4px; right: 10px; z-index: 2; font-size: 12px; font-weight: 500; color: var(--vt-c-text-dark-3); transition: color 0.5s;"></span><pre class="shiki github-dark vp-code" tabindex="0" style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: 1em; margin: 0px; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; position: relative; z-index: 1; padding: 14px 0px; background: transparent; overflow-x: auto;"><code style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: var(--vt-doc-code-font-size); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; display: block; padding: 0px 24px; width: fit-content; min-width: 100%; line-height: var(--vt-doc-code-line-height); color: rgb(166, 172, 205); transition: color 0.5s;"><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(121, 184, 255);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(121, 184, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(106, 115, 125);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line highlighted" style="box-sizing: border-box; background-color: rgba(0, 0, 0, 0.3); transition: background-color 0.5s; margin: 0px -24px; padding: 0px 24px; width: calc(100% + 48px); display: inline-block;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span></code></pre></div></details><p>​注意，你只可以<strong>在组件挂载后</strong>才能访问模板引用。如果你想在模板中的表达式上访问 <code>input</code>，在初次渲染时会是 <code>null</code>。这是因为在初次渲染前这个元素还不存在呢！</p><p>​如果你需要侦听一个模板引用 ref 的变化，确保考虑到其值为 <code>null</code> 的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (input.<span class="hljs-property">value</span>) &#123;<br>    input.<span class="hljs-property">value</span>.<span class="hljs-title function_">focus</span>()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 此时还未挂载，或此元素已经被卸载（例如通过 v-if 控制）</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>也可参考：<a href="https://cn.vuejs.org/guide/typescript/composition-api.html#typing-template-refs">为模板引用标注类型</a> </p><h2 id="v-for-中的模板引用"><a href="#v-for-中的模板引用" class="headerlink" title="v-for 中的模板引用"></a><code>v-for</code> 中的模板引用</h2><blockquote><p>需要 v3.2.25 及以上版本</p></blockquote><p>​当在 <code>v-for</code> 中使用模板引用时，对应的 ref 中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, useTemplateRef, onMounted &#125; from &#x27;vue&#x27;<br><br>const list = ref([<br>  /* ... */<br>])<br><br>const itemRefs = useTemplateRef(&#x27;items&#x27;)<br><br>onMounted(() =&gt; console.log(itemRefs.value))<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;ul&gt;<br>    &lt;li v-for=&quot;item in list&quot; ref=&quot;items&quot;&gt;<br>      &#123;&#123; item &#125;&#125;<br>    &lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNp9UsluwjAQ/ZWRLwQpDepyQoDUIg6t1EWUW91DFAZq6tiWF4oU5d87dtgqVRyyzLw3b+aN3bB7Y4ptQDZkI1dZYTw49MFMuBK10dZDAxZXOQSHC6yNLD3OY6zVsw7K4xJaWFldQ49UelxxVWnlPEhBr3GszT6uc7jJ4fazf4KFx5p0HFH+Kme9CLle4h6bZFkfxhNouAIoJVqfHQSKbSkDFnVpMhEpovC481NNVcr3SaWlZzTovJErCqgydaMIYBRk+tKfFLC9Wmk75iyqg1DJBWfRxT7pONvTAZom2YC23QsMpOg0B0l0NDh2YjnzjpyvxLrYOK1o3ckLZ5WujSBHr8YL2gxnw85lxEop9c9TynkbMD/kqy+svv/Jb9wu5jh7s+jQbpGzI+ZLu0byEuHZ+wvt6Ays9TJIYl8A5+i0DHHGjvYQ1JLGPuOlaR/TpRFqvXCzHR2BO5iKg0Zmm/ic0W2ZXrB+Gve2uEt1dJKs/QXbwePE">在演练场中尝试一下</a></p><details style="box-sizing: border-box; display: block;"><summary style="box-sizing: border-box; display: list-item; touch-action: manipulation; margin-bottom: 1.2em; width: fit-content; cursor: pointer;">3.5 前的用法</summary><div class="language-vue" style="box-sizing: border-box; position: relative; margin: 28px 0px; background-color: rgb(41, 45, 62); overflow-x: auto; transition: background-color 0.5s; border-radius: 8px;"><button title="Copy Code" class="copy" style="box-sizing: border-box; font-family: inherit; font-size: 16px; line-height: inherit; margin: 0px; overflow: visible; text-transform: none; appearance: button; touch-action: manipulation; border: 0px; padding: 0px; color: inherit; background-color: rgb(41, 45, 62); background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='20' width='20' stroke='rgba(128,128,128,1)' stroke-width='2' viewBox='0 0 24 24'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2M9 5a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2M9 5a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2'/%3E%3C/svg%3E&quot;); cursor: pointer; position: absolute; top: 4px; right: 4px; z-index: 3; display: block; justify-content: center; align-items: center; border-radius: 4px; width: 40px; height: 40px; opacity: 0; background-position: 50% center; background-size: 20px; background-repeat: no-repeat; transition: opacity 0.4s;"></button><span class="lang" style="box-sizing: border-box; position: absolute; top: 4px; right: 10px; z-index: 2; font-size: 12px; font-weight: 500; color: var(--vt-c-text-dark-3); transition: color 0.5s;"></span><pre class="shiki github-dark vp-code" tabindex="0" style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: 1em; margin: 0px; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; position: relative; z-index: 1; padding: 14px 0px; background: transparent; overflow-x: auto;"><code style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: var(--vt-doc-code-font-size); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; display: block; padding: 0px 24px; width: fit-content; min-width: 100%; line-height: var(--vt-doc-code-line-height); color: rgb(166, 172, 205); transition: color 0.5s;"><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(121, 184, 255);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(106, 115, 125);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(121, 184, 255);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span></code></pre></div></details><p>应该注意的是，ref 数组<strong>并不</strong>保证与源数组相同的顺序。</p><h2 id="函数模板引用"><a href="#函数模板引用" class="headerlink" title="函数模板引用"></a>函数模板引用</h2><p>​除了使用字符串值作名字，<code>ref</code> attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input :ref=&quot;(el) =&gt; &#123; /* 将 el 赋值给一个数据属性或 ref 变量 */ &#125;&quot;&gt;<br></code></pre></td></tr></table></figure><p>​注意我们这里需要使用动态的 <code>:ref</code> 绑定才能够传入一个函数。当绑定的元素被卸载时，函数也会被调用一次，此时的 <code>el</code> 参数会是 <code>null</code>。你当然也可以绑定一个组件方法而不是内联函数。</p><h2 id="组件上的-ref"><a href="#组件上的-ref" class="headerlink" title="组件上的 ref"></a>组件上的 ref</h2><p>​模板引用也可以被用在一个子组件上。这种情况下引用中获得的值是组件实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; useTemplateRef, onMounted &#125; from &#x27;vue&#x27;<br>import Child from &#x27;./Child.vue&#x27;<br><br>const childRef = useTemplateRef(&#x27;child&#x27;)<br><br>onMounted(() =&gt; &#123;<br>  // childRef.value 将持有 &lt;Child /&gt; 的实例<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;Child ref=&quot;child&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><details style="box-sizing: border-box; display: block;"><summary style="box-sizing: border-box; display: list-item; touch-action: manipulation; margin-bottom: 1.2em; width: fit-content; cursor: pointer;">3.5 前的用法</summary><div class="language-vue" style="box-sizing: border-box; position: relative; margin: 28px 0px; background-color: rgb(41, 45, 62); overflow-x: auto; transition: background-color 0.5s; border-radius: 8px;"><button title="Copy Code" class="copy" style="box-sizing: border-box; font-family: inherit; font-size: 16px; line-height: inherit; margin: 0px; overflow: visible; text-transform: none; appearance: button; touch-action: manipulation; border: 0px; padding: 0px; color: inherit; background-color: rgb(41, 45, 62); background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='20' width='20' stroke='rgba(128,128,128,1)' stroke-width='2' viewBox='0 0 24 24'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2M9 5a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2M9 5a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2'/%3E%3C/svg%3E&quot;); cursor: pointer; position: absolute; top: 4px; right: 4px; z-index: 3; display: block; justify-content: center; align-items: center; border-radius: 4px; width: 40px; height: 40px; opacity: 0; background-position: 50% center; background-size: 20px; background-repeat: no-repeat; transition: opacity 0.4s;"></button><span class="lang" style="box-sizing: border-box; position: absolute; top: 4px; right: 10px; z-index: 2; font-size: 12px; font-weight: 500; color: var(--vt-c-text-dark-3); transition: color 0.5s;"></span><pre class="shiki github-dark vp-code" tabindex="0" style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: 1em; margin: 0px; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; position: relative; z-index: 1; padding: 14px 0px; background: transparent; overflow-x: auto;"><code style="box-sizing: border-box; font-family: var(--vt-font-family-mono); font-size: var(--vt-doc-code-font-size); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; tab-size: 4; hyphens: none; display: block; padding: 0px 24px; width: fit-content; min-width: 100%; line-height: var(--vt-doc-code-line-height); color: rgb(166, 172, 205); transition: color 0.5s;"><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(121, 184, 255);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(121, 184, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(249, 117, 131);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(106, 115, 125);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(179, 146, 240);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(158, 203, 255);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span><span class="line" style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span><span style="box-sizing: border-box; color: rgb(133, 232, 157);"></span><span style="box-sizing: border-box; color: rgb(225, 228, 232);"></span></span></code></pre></div></details><p>​如果一个子组件使用的是选项式 API 或没有使用 <code>&lt;script setup&gt;</code>，被引用的组件实例和该子组件的 <code>this</code> 完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互。</p><p>​有一个例外的情况，使用了 <code>&lt;script setup&gt;</code> 的组件是<strong>默认私有</strong>的：一个父组件无法访问到一个使用了 <code>&lt;script setup&gt;</code> 的子组件中的任何东西，除非子组件在其中通过 <code>defineExpose</code> 宏显式暴露：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const a = 1<br>const b = ref(2)<br><br>// 像 defineExpose 这样的编译器宏不需要导入<br>defineExpose(&#123;<br>  a,<br>  b<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​当父组件通过模板引用获取到了该组件的实例时，得到的实例类型为 <code>&#123; a: number, b: number &#125;</code> (ref 都会自动解包，和一般的实例一样)。</p><p>TypeScript 用户请参考：<a href="https://cn.vuejs.org/guide/typescript/composition-api.html#typing-component-template-refs">为组件的模板引用标注类型</a> </p>]]></content>
    
    
    <categories>
      
      <category>vue基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>侦听器</title>
    <link href="/vue%E5%9F%BA%E7%A1%80-%E4%BE%A6%E5%90%AC%E5%99%A8/"/>
    <url>/vue%E5%9F%BA%E7%A1%80-%E4%BE%A6%E5%90%AC%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h1><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例<a href="https://cn.vuejs.org/guide/essentials/watchers.html#basic-example"></a></h2><p>​计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。</p><p>​在组合式 API 中，我们可以使用 <a href="https://cn.vuejs.org/api/reactivity-core.html#watch"><code>watch</code> 函数</a>在每次响应式状态发生变化时触发回调函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;p&gt;<br>    输入yes获取随机yes图片<br>    &lt;input v-model=&quot;question&quot; /&gt;<br>    您的输入&#123;&#123; question &#125;&#125;<br>  &lt;/p&gt;<br>  &lt;div&gt;<br>    &lt;img v-if=&quot;image&quot; :src=&quot;image&quot; alt=&quot;&quot;&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref, watch &#125; from &quot;vue&quot;;<br>const image = ref(&quot;&quot;);<br>const question = ref(&#x27;&#x27;);<br>watch(question, async (newQuestion) =&gt; &#123;<br>  if (newQuestion === &#x27;yes&#x27;) &#123;<br>    try &#123;<br>      image.value = (await (await fetch(&quot;https://yesno.wtf/api&quot;)).json()).image;<br>    &#125; catch (error) &#123;<br>      image.value = &#x27;&#x27;;<br>    &#125;<br>  &#125; else &#123;<br>    image.value = &#x27;&#x27;;<br>  &#125;<br>&#125;);<br>&lt;/script&gt;<br>&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNp9U8Fy0zAQ/ZVFF9tDah96C2mZ0umhHKBAj7oIe52oUSQjyXEyGf87KytyoDC9JPa+p+e3b1cndtd15b5HtmQrV1vZeXDo++6Wa7nrjPVwAovtAgbh6w2M0Fqzg4xOZFxzXRvtPPzq0XlpNNwEbp5lRUKEdgPaVP925jnoXS+UOgKxvJAaxEVjJ+y2hA9XxUVFGdFIvT7LtEI5JIzrqjrbGozdOmikxdqTKqmIQOV6gvOkvQDhjrqGXOOQvCzAqCa9FHBzCyeuAWT7F6uUulZ9gy7PPmZFETmQjJV7oXoke972GJHY+Axkzxupt4FalhRcYHh7TDIQcqA+LTriikFIDy0G59nG+84tq+qITpty8G0lOhmSiedefSaPZ0mnfHFG50VRRkbkj1BPceVorbFzF/+6fQj4O7g3vWpAm6Ao6JzfINw9PZaQwXuYNJJuK/U0z1nxdTLT0M7s8Ec/I3WxquLS0brRi8ddp4RHegNYhR0M/Du3pXFSAJU285osI7aSuus97K92pkF1w1nCOYNlI534qbCh8tkOVasoXkV1+sjplLZ0HGN5Vc1G2IJ5R8Np5XpKlK7J1CJntdl1UqH92k0bzdkyNc8ZRWGGz1MtbMQi1esN1tv/1F/cIdQ4e6LJod0jZzPmhV2jj/DDjy94oOcZpK57Rew3wO/ojOpjJIH2qdcN2f6DN7l9nC47RfTsHg4etUtNpZUeJz5ndPPv32j9Yve6vE6DZuNvu1R2Tg==">在演练场中尝试一下</a></p><h3 id="侦听数据源类型"><a href="#侦听数据源类型" class="headerlink" title="侦听数据源类型"></a>侦听数据源类型</h3><p>​<code>watch</code> 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description">getter 函数</a>、或多个数据源组成的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> x = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> y = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// 单个 ref</span><br><span class="hljs-title function_">watch</span>(x, <span class="hljs-function">(<span class="hljs-params">newX</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`x is <span class="hljs-subst">$&#123;newX&#125;</span>`</span>)<br>&#125;)<br><br><span class="hljs-comment">// getter 函数</span><br><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> x.<span class="hljs-property">value</span> + y.<span class="hljs-property">value</span>,<br>  <span class="hljs-function">(<span class="hljs-params">sum</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`sum of x + y is: <span class="hljs-subst">$&#123;sum&#125;</span>`</span>)<br>  &#125;<br>)<br><br><span class="hljs-comment">// 多个来源组成的数组</span><br><span class="hljs-title function_">watch</span>([x, <span class="hljs-function">() =&gt;</span> y.<span class="hljs-property">value</span>], <span class="hljs-function">(<span class="hljs-params">[newX, newY]</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`x is <span class="hljs-subst">$&#123;newX&#125;</span> and y is <span class="hljs-subst">$&#123;newY&#125;</span>`</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>注意，你不能直接侦听响应式对象的属性值，例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<br><br><span class="hljs-comment">// 错误，因为 watch() 得到的参数是一个 number</span><br><span class="hljs-title function_">watch</span>(obj.<span class="hljs-property">count</span>, <span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count is: <span class="hljs-subst">$&#123;count&#125;</span>`</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这里需要用一个返回该属性的 getter 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 提供一个 getter 函数</span><br><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> obj.<span class="hljs-property">count</span>,<br>  <span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count is: <span class="hljs-subst">$&#123;count&#125;</span>`</span>)<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="深层侦听器"><a href="#深层侦听器" class="headerlink" title="深层侦听器"></a>深层侦听器</h2><p>​直接给 <code>watch()</code> 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<br><br><span class="hljs-title function_">watch</span>(obj, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在嵌套的属性变更时触发</span><br>  <span class="hljs-comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span><br>  <span class="hljs-comment">// 因为它们是同一个对象！</span><br>&#125;)<br><br>obj.<span class="hljs-property">count</span>++<br></code></pre></td></tr></table></figure><p>​相比之下，一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">someObject</span>,<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 仅当 state.someObject 被替换时触发</span><br>  &#125;<br>)<br></code></pre></td></tr></table></figure><p>​你也可以给上面这个例子显式地加上 <code>deep</code> 选项，强制转成深层侦听器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">someObject</span>,<br>  <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span><br>    <span class="hljs-comment">// *除非* state.someObject 被整个替换了</span><br>  &#125;,<br>  &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> &#125;<br>)<br></code></pre></td></tr></table></figure><p>在 Vue 3.5+ 中，<code>deep</code> 选项还可以是一个数字，表示最大遍历深度——即 Vue 应该遍历对象嵌套属性的级数。</p><p>谨慎使用</p><p>​深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。</p><h2 id="即时回调的侦听器"><a href="#即时回调的侦听器" class="headerlink" title="即时回调的侦听器"></a>即时回调的侦听器</h2><p>​<code>watch</code> 默认是懒执行的：仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。</p><p>​我们可以通过传入 <code>immediate: true</code> 选项来强制侦听器的回调立即执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<br>  source,<br>  <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 立即执行，且当 `source` 改变时再次执行</span><br>  &#125;,<br>  &#123; <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="一次性侦听器"><a href="#一次性侦听器" class="headerlink" title="一次性侦听器"></a>一次性侦听器</h2><ul><li>仅支持 3.4 及以上版本</li></ul><p>​每当被侦听源发生变化时，侦听器的回调就会执行。如果希望回调只在源变化时触发一次，请使用 <code>once: true</code> 选项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<br>  source,<br>  <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 当 `source` 变化时，仅触发一次</span><br>  &#125;,<br>  &#123; <span class="hljs-attr">once</span>: <span class="hljs-literal">true</span> &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect()"></a><code>watchEffect()</code></h2><p>​侦听器的回调使用与源完全相同的响应式状态是很常见的。例如下面的代码，在每当 <code>todoId</code> 的引用发生变化时使用侦听器来加载一个远程资源：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> todoId = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br><br><span class="hljs-title function_">watch</span>(<br>  todoId,<br>  <span class="hljs-title function_">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<br>      <span class="hljs-string">`https://jsonplaceholder.typicode.com/todos/<span class="hljs-subst">$&#123;todoId.value&#125;</span>`</span><br>    )<br>    data.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>()<br>  &#125;,<br>  &#123; <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> &#125;<br>)<br></code></pre></td></tr></table></figure><p>特别是注意侦听器是如何两次使用 <code>todoId</code> 的，一次是作为源，另一次是在回调中。</p><p>​我们可以用 <a href="https://cn.vuejs.org/api/reactivity-core.html#watcheffect"><code>watchEffect</code> 函数</a> 来简化上面的代码。<code>watchEffect()</code> 允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<br>    <span class="hljs-string">`https://jsonplaceholder.typicode.com/todos/<span class="hljs-subst">$&#123;todoId.value&#125;</span>`</span><br>  )<br>  data.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><p>​这个例子中，回调会立即执行，不需要指定 <code>immediate: true</code>。在执行期间，它会自动追踪 <code>todoId.value</code> 作为依赖（和计算属性类似）。每当 <code>todoId.value</code> 变化时，回调会再次执行。有了 <code>watchEffect()</code>，我们不再需要明确传递 <code>todoId</code> 作为源值。</p><p>​你可以参考一下<a href="https://cn.vuejs.org/examples/#fetching-data">这个例子</a>的 <code>watchEffect</code> 和响应式的数据请求的操作。</p><p>​对于这种只有一个依赖项的例子来说，<code>watchEffect()</code> 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 <code>watchEffect()</code> 可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，<code>watchEffect()</code> 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。</p><p>​<code>watchEffect</code> 仅会在其<strong>同步</strong>执行期间，才追踪依赖。在使用异步回调时，只有在第一个 <code>await</code> 正常工作前访问到的属性才会被追踪。</p><h3 id="watch-vs-watchEffect"><a href="#watch-vs-watchEffect" class="headerlink" title="watch vs. watchEffect"></a><code>watch</code> vs. <code>watchEffect</code></h3><p><code>watch</code> 和 <code>watchEffect</code> 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：</p><ul><li><code>watch</code> 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。<code>watch</code> 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。</li><li><code>watchEffect</code>，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。</li></ul><h2 id="副作用清理"><a href="#副作用清理" class="headerlink" title="副作用清理"></a>副作用清理</h2><p>有时我们可能会在侦听器中执行副作用，例如异步请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(id, <span class="hljs-function">(<span class="hljs-params">newId</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/<span class="hljs-subst">$&#123;newId&#125;</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 回调逻辑</span><br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>​但是如果在请求完成之前 <code>id</code> 发生了变化怎么办？当上一个请求完成时，它仍会使用已经过时的 ID 值触发回调。理想情况下，我们希望能够在 <code>id</code> 变为新值时取消过时的请求。</p><p>​我们可以使用 <a href="https://cn.vuejs.org/api/reactivity-core.html#onwatchercleanup"><code>onWatcherCleanup()</code></a> API 来注册一个清理函数，当侦听器失效并准备重新运行时会被调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; watch, onWatcherCleanup &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-title function_">watch</span>(id, <span class="hljs-function">(<span class="hljs-params">newId</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>()<br><br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/<span class="hljs-subst">$&#123;newId&#125;</span>`</span>, &#123; <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 回调逻辑</span><br>  &#125;)<br><br>  <span class="hljs-title function_">onWatcherCleanup</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 终止过期请求</span><br>    controller.<span class="hljs-title function_">abort</span>()<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>​请注意，<code>onWatcherCleanup</code> 仅在 Vue 3.5+ 中支持，并且必须在 <code>watchEffect</code> 效果函数或 <code>watch</code> 回调函数的同步执行期间调用：你不能在异步函数的 <code>await</code> 语句之后调用它。</p><p>​作为替代，<code>onCleanup</code> 函数还作为第三个参数传递给侦听器回调，以及 <code>watchEffect</code> 作用函数的第一个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(id, <span class="hljs-function">(<span class="hljs-params">newId, oldId, onCleanup</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-title function_">onCleanup</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 清理逻辑</span><br>  &#125;)<br>&#125;)<br><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">(<span class="hljs-params">onCleanup</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-title function_">onCleanup</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 清理逻辑</span><br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>​这在 3.5 之前的版本有效。此外，通过函数参数传递的 <code>onCleanup</code> 与侦听器实例相绑定，因此不受 <code>onWatcherCleanup</code> 的同步限制。</p><h2 id="回调的触发时机"><a href="#回调的触发时机" class="headerlink" title="回调的触发时机"></a>回调的触发时机</h2><p>​当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。</p><p>​类似于组件更新，用户创建的侦听器回调函数也会被批量处理以避免重复调用。例如，如果我们同步将一千个项目推入被侦听的数组中，我们可能不希望侦听器触发一千次。</p><p>​默认情况下，侦听器回调会在父组件更新 (如有) <strong>之后</strong>、所属组件的 DOM 更新<strong>之前</strong>被调用。这意味着如果你尝试在侦听器回调中访问所属组件的 DOM，那么 DOM 将处于更新前的状态。</p><h3 id="Post-Watchers"><a href="#Post-Watchers" class="headerlink" title="Post Watchers"></a>Post Watchers</h3><p>​如果想在侦听器回调中能访问被 Vue 更新<strong>之后</strong>的所属组件的 DOM，你需要指明 <code>flush: &#39;post&#39;</code> 选项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(source, callback, &#123;<br>  <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;post&#x27;</span><br>&#125;)<br><br><span class="hljs-title function_">watchEffect</span>(callback, &#123;<br>  <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;post&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>​后置刷新的 <code>watchEffect()</code> 有个更方便的别名 <code>watchPostEffect()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; watchPostEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-title function_">watchPostEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">/* 在 Vue 更新后执行 */</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="同步侦听器"><a href="#同步侦听器" class="headerlink" title="同步侦听器"></a>同步侦听器</h3><p>​你还可以创建一个同步触发的侦听器，它会在 Vue 进行任何更新之前触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(source, callback, &#123;<br>  <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;sync&#x27;</span><br>&#125;)<br><br><span class="hljs-title function_">watchEffect</span>(callback, &#123;<br>  <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;sync&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>​同步触发的 <code>watchEffect()</code> 有个更方便的别名 <code>watchSyncEffect()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; watchSyncEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-title function_">watchSyncEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">/* 在响应式数据变化时同步执行 */</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>​同步侦听器不会进行批处理，每当检测到响应式数据发生变化时就会触发。可以使用它来监视简单的布尔值，但应避免在可能多次同步修改的数据源 (如数组) 上使用。</p><h2 id="停止侦听器"><a href="#停止侦听器" class="headerlink" title="停止侦听器"></a>停止侦听器</h2><p>​在 <code>setup()</code> 或 <code>&lt;script setup&gt;</code> 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。因此，在大多数情况下，你无需关心怎么停止一个侦听器。</p><p>​一个关键点是，侦听器必须用<strong>同步</strong>语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。如下方这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; watchEffect &#125; from &#x27;vue&#x27;<br><br>// 它会自动停止<br>watchEffect(() =&gt; &#123;&#125;)<br><br>// ...这个则不会！<br>setTimeout(() =&gt; &#123;<br>  watchEffect(() =&gt; &#123;&#125;)<br>&#125;, 100)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​要手动停止一个侦听器，请调用 <code>watch</code> 或 <code>watchEffect</code> 返回的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> unwatch = <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br><br><span class="hljs-comment">// ...当该侦听器不再需要时</span><br><span class="hljs-title function_">unwatch</span>()<br></code></pre></td></tr></table></figure><p>​注意，需要异步创建侦听器的情况很少，请尽可能选择同步创建。如果需要等待一些异步数据，你可以使用条件式的侦听逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 需要异步请求得到的数据</span><br><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (data.<span class="hljs-property">value</span>) &#123;<br>    <span class="hljs-comment">// 数据加载后执行某些操作...</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>表单输入绑定</title>
    <link href="/vue%E5%9F%BA%E7%A1%80-%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/"/>
    <url>/vue%E5%9F%BA%E7%A1%80-%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h1><p>​在前端处理表单时，我们常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input<br>  :value=&quot;text&quot;<br>  @input=&quot;event =&gt; text = event.target.value&quot;&gt;<br></code></pre></td></tr></table></figure><p>​<code>v-model</code> 指令帮我们简化了这一步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input v-model=&quot;text&quot;&gt;<br></code></pre></td></tr></table></figure><p>​另外，<code>v-model</code> 还可以用于各种不同类型的输入，<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 元素。它会根据所使用的元素自动使用对应的 DOM 属性和事件组合：</p><ul><li>文本类型的 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code> 元素会绑定 <code>value</code> property 并侦听 <code>input</code> 事件；</li><li><code>&lt;input type=&quot;checkbox&quot;&gt;</code> 和 <code>&lt;input type=&quot;radio&quot;&gt;</code> 会绑定 <code>checked</code> property 并侦听 <code>change</code> 事件；</li><li><code>&lt;select&gt;</code> 会绑定 <code>value</code> property 并侦听 <code>change</code> 事件。</li></ul><p>​<code>v-model</code> 会忽略任何表单元素上初始的 <code>value</code>、<code>checked</code> 或 <code>selected</code> attribute。它将始终将当前绑定的 JavaScript 状态视为数据的正确来源。我们应该在 JavaScript 中使用<a href="https://cn.vuejs.org/api/reactivity-core.html#reactivity-api-core">响应式系统的 API</a>来声明该初始值。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;<br>&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot; /&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNo9jUEOgyAQRa8yYUO7aNkbNOkBegM2RseWRGACoxvC3TumxuX/+f+9ql5Ez31D1SlbpuyJoSBvNLjoA6XMUCHjAg2WnAJomWoXXZxSLAwBSxk/CP2xuWl9d9GaP0YAEhgDrSOjJABLw/s8+NJBrde/NWsOpWPrI20M+yOkGdfeqXPiFAhowm9aZ8zS4+wPv/RGjtZcJtV+YpNK1g==">在演练场中尝试一下</a></p><p>​对于需要使用 <a href="https://en.wikipedia.org/wiki/Input_method">IME</a> 的语言 (中文，日文和韩文等)，你会发现 <code>v-model</code> 不会在 IME 输入还在拼字阶段时触发更新。如果你的确想在拼字阶段也触发更新，请直接使用自己的 <code>input</code> 事件监听器和 <code>value</code> 绑定而不要使用 <code>v-model</code>。</p><h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;span&gt;Multiline message is:&lt;/span&gt;<br>&lt;p style=&quot;white-space: pre-line;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;<br>&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNo9jktuwzAMRK9CaON24XrvKgZ6gN5AG8FmGgH6ECKdJjB891D5LYec9zCb+SH6Oq9oRmN5roEEGGWlyeWQqFSBDSoeYYdjLQk6rXYuuzyXzAIJmf0fwqF1Prru02U7PDQq0CCYKHrBlsQy+Tz9rlFCDBnfdOBRqfa7twhYrhEPzvyfgmCvnxlHoIp9w76dmbbtDe+7HdpaBQUv4it6OPepLBjV8Gw5AzpjxlOJC1a9+2WB1IZQRGhWVqsdXgb1tfDcbvYbJDRqLQ==">在演练场中尝试一下</a></p><p>注意在 <code>&lt;textarea&gt;</code> 中是不支持插值表达式的。请使用 <code>v-model</code> 来替代：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 错误 --&gt;<br>&lt;textarea&gt;&#123;&#123; text &#125;&#125;&lt;/textarea&gt;<br><br>&lt;!-- 正确 --&gt;<br>&lt;textarea v-model=&quot;text&quot;&gt;&lt;/textarea&gt;<br></code></pre></td></tr></table></figure><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>单一的复选框，绑定布尔类型值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot; /&gt;<br>&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNpVjssKgzAURH/lko3tonVfotD/yEaTKw3Ni3gjLSH/3qhUcDnDnMNk9gzhviRkD8ZnGXUgmJFS6IXTNvhIkCHiBAWm6C00ddoIJ5z0biaQL5RvVNCtmwvFhFfheLuLqqIGQhvMQLgm4tqFREDfgJ1gGz36j2Cg1TkvN+sVmn+JqnbtrjDDiAYmH09En/PxphTebqsK8PY4wMoPslBUxQ==">在演练场中尝试一下</a></p><p>​我们也可以将多个复选框绑定到同一个数组或<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">集合</a>的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> checkedNames = <span class="hljs-title function_">ref</span>([])<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/div&gt;<br><br>&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot; /&gt;<br>&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;<br><br>&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot; /&gt;<br>&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;<br><br>&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot; /&gt;<br>&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;<br></code></pre></td></tr></table></figure><p>​在这个例子中，<code>checkedNames</code> 数组将始终包含所有当前被选中的框的值。</p><p><a href="https://play.vuejs.org/#eNqVkUtqwzAURbfy0CTtoNU8KILSWaHdQNWBIj8T1fohyybBeO+RbOc3i2e+vHvuMWggHyG89x2SLWGtijokaDF1gQunbfAxwQARaxihjt7CJlc3wgmnvGsTqAOqBqsfabGFXSm+/P69CsfovJVXckhog5EJcwJgle7558yBK+AWhuFxaRwZLbVCZ0K70CVIp4A7Qabi3h8FAV3l/C9Vk797abpy/lrim/UVmkt/Gc4HOv+EkXs0UPt4XeCFZHQ6lM4TZn9w9+YlrjFPCC/kKrPVDd6Zv5e4wjwv8ELezIxeX4qMZwHduAs=">在演练场中尝试一下</a></p><h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/div&gt;<br><br>&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot; /&gt;<br>&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;<br><br>&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot; /&gt;<br>&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNqFkDFuwzAMRa9CaHE7tNoDxUBP0A4dtTgWDQiRJUKmHQSG7x7KhpMMAbLxk3z/g5zVD9H3NKI6KDO02RPDgDxSbaPvKWWGGTJ2sECXUw+VrFY22timODCQb8/o4FhWPqrfiNWnjUZvRmIhgrGn0DCKAjDOT/XfCh1gnnd+WYwukwJYNj7SyMBXwqNVuXE+WQXeiUgRpZyaMJaR5BX11SeHQfTmJi1dnNiE5oQBupR3shbC6LX9Posvpdyz/jf1OksOe85ayVqIR5bR9z+o5Qbc6oCk">在演练场中尝试一下</a></p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>​单个选择器的示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;<br><br>&lt;select v-model=&quot;selected&quot;&gt;<br>  &lt;option disabled value=&quot;&quot;&gt;Please select one&lt;/option&gt;<br>  &lt;option&gt;A&lt;/option&gt;<br>  &lt;option&gt;B&lt;/option&gt;<br>  &lt;option&gt;C&lt;/option&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNp1j7EOgyAQhl/lwmI7tO4Nmti+QJOuLFTPxASBALoQ3r2H2jYOjvff939wkTXWXucJ2Y1x37rBBvAYJlsLPYzWuAARHPaQoHdmhILQQmihW6N9RhW2ATuoMnQqirPQvFw9ZKAh4GiVDEgTAPdW6hpeW+sGMf4VKVEz73Mvs8sC5stoOlSVYF9SsEVGiLFhMBq6wcu3IsUs1YREEvFUKD1udjAaebnS+27dHOT3g/yxy+nHywM08PJ3KksfXwJ2dA==">在演练场中尝试一下</a></p><p>​如果 <code>v-model</code> 表达式的初始值不匹配任何一个选择项，<code>&lt;select&gt;</code> 元素会渲染成一个“未选择”的状态。在 iOS 上，这将导致用户无法选择第一项，因为 iOS 在这种情况下不会触发一个 change 事件。因此，我们建议提供一个空值的禁用选项，如上面的例子所示。</p><p>多选 (值绑定到一个数组)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;<br><br>&lt;select v-model=&quot;selected&quot; multiple&gt;<br>  &lt;option&gt;A&lt;/option&gt;<br>  &lt;option&gt;B&lt;/option&gt;<br>  &lt;option&gt;C&lt;/option&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNp1kL2OwjAQhF9l5Ya74i7QBhMJeARKTIESIyz5Z5VsAsjyu7NOQEBB5xl/M7vaKNaI/0OvRSlkV7cGCTpNPVbKG4ehJYjQ6hMkOLXBwYzRmfLK18F3GbW6Jt3AKkM/+8Ov8rKYeriBBWmH9kiaFYBszFDtHpkSYnwVpCSL/JtDDE4+DH8uNNqulHiCSoDrLRm0UyWzAckEX61l8Xh9+psv/vbD563HCSxk8bY0y45u47AJ2D/HHyDm4MU0dC5hMZ/jdal8Gg8wJkS6A3nRew4=">在演练场中尝试一下</a></p><p>选择器的选项可以使用 <code>v-for</code> 动态渲染：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> selected = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;A&#x27;</span>)<br><br><span class="hljs-keyword">const</span> options = <span class="hljs-title function_">ref</span>([<br>  &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;One&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;A&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Two&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;B&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Three&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;C&#x27;</span> &#125;<br>])<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;select v-model=&quot;selected&quot;&gt;<br>  &lt;option v-for=&quot;option in options&quot; :value=&quot;option.value&quot;&gt;<br>    &#123;&#123; option.text &#125;&#125;<br>  &lt;/option&gt;<br>&lt;/select&gt;<br><br>&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNplkMFugzAQRH9l5YtbKYU7IpFoP6CH9lb3EMGiWgLbMguthPzvXduEJMqNYUazb7yKxrlimVFUop5arx3BhDS7kzJ6dNYTrOCxhwC9tyNIjkpllGmtmWJ0wJawg2MMPclGPl9N60jzx+Z9KQPcRfhHFch3g/IAy3mYkVUjIRzu/M9fe+O/Pvo/Hm8b3jihzDdfr8s8gwewIBzdcCZkBVBnXFheRtvhcFTiwq9ECnAkQ3Okt54Dm9TmskYJqNLR3SyS3BsYct3CRYSFwGCpusx/M0qZTydKRXWnl9PHBlPFhv1lQ6jL6MZl+xoR/gFjPZTD">在演练场中尝试一下</a></p><h2 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h2><p>​对于单选按钮，复选框和选择器选项，<code>v-model</code> 绑定的值通常是静态的字符串 (或者对复选框是布尔值)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- `picked` 在被选择时是字符串 &quot;a&quot; --&gt;<br>&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot; /&gt;<br><br>&lt;!-- `toggle` 只会为 true 或 false --&gt;<br>&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; /&gt;<br><br>&lt;!-- `selected` 在第一项被选中时为字符串 &quot;abc&quot; --&gt;<br>&lt;select v-model=&quot;selected&quot;&gt;<br>  &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p>​但有时我们可能希望将该值绑定到当前组件实例上的动态数据。这可以通过使用 <code>v-bind</code> 来实现。此外，使用 <code>v-bind</code> 还使我们可以将选项值绑定为非字符串的数据类型。</p><h3 id="复选框-1"><a href="#复选框-1" class="headerlink" title="复选框"></a>复选框</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input<br>  type=&quot;checkbox&quot;<br>  v-model=&quot;toggle&quot;<br>  true-value=&quot;yes&quot;<br>  false-value=&quot;no&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​<code>true-value</code> 和 <code>false-value</code> 是 Vue 特有的 attributes，仅支持和 <code>v-model</code> 配套使用。这里 <code>toggle</code> 属性的值会在选中时被设为 <code>&#39;yes&#39;</code>，取消选择时设为 <code>&#39;no&#39;</code>。你同样可以通过 <code>v-bind</code> 将其绑定为其他动态值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input<br>  type=&quot;checkbox&quot;<br>  v-model=&quot;toggle&quot;<br>  :true-value=&quot;dynamicTrueValue&quot;<br>  :false-value=&quot;dynamicFalseValue&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​<code>true-value</code> 和 <code>false-value</code> attributes 不会影响 <code>value</code> attribute，因为浏览器在表单提交时，并不会包含未选择的复选框。为了保证这两个值 (例如：“yes”和“no”) 的其中之一被表单提交，请使用单选按钮作为替代。</p><h3 id="单选按钮-1"><a href="#单选按钮-1" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; :value=&quot;first&quot; /&gt;<br>&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; :value=&quot;second&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​<code>pick</code> 会在第一个按钮选中时被设为 <code>first</code>，在第二个按钮选中时被设为 <code>second</code>。</p><h3 id="选择器选项"><a href="#选择器选项" class="headerlink" title="选择器选项"></a>选择器选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;select v-model=&quot;selected&quot;&gt;<br>  &lt;!-- 内联对象字面量 --&gt;<br>  &lt;option :value=&quot;&#123; number: 123 &#125;&quot;&gt;123&lt;/option&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p>​<code>v-model</code> 同样也支持非字符串类型的值绑定！在上面这个例子中，当某个选项被选中，<code>selected</code> 会被设为该对象字面量值 <code>&#123; number: 123 &#125;</code>。</p><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a><code>.lazy</code></h3><p>​默认情况下，<code>v-model</code> 会在每次 <code>input</code> 事件后更新数据 (<a href="https://cn.vuejs.org/guide/essentials/forms.html#vmodel-ime-tip">IME 拼字阶段的状态</a>例外)。你可以添加 <code>lazy</code> 修饰符来改为在每次 <code>change</code> 事件后更新数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 在 &quot;change&quot; 事件后同步更新而不是 &quot;input&quot; --&gt;<br>&lt;input v-model.lazy=&quot;msg&quot; /&gt;<br></code></pre></td></tr></table></figure><h3 id="number"><a href="#number" class="headerlink" title=".number"></a><code>.number</code></h3><p>​如果你想让用户输入自动转换为数字，你可以在 <code>v-model</code> 后添加 <code>.number</code> 修饰符来管理输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input v-model.number=&quot;age&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​如果该值无法被 <code>parseFloat()</code> 处理，那么将返回原始值。</p><p>​<code>number</code> 修饰符会在输入框有 <code>type=&quot;number&quot;</code> 时自动启用。</p><h3 id="trim"><a href="#trim" class="headerlink" title=".trim"></a><code>.trim</code></h3><p>​如果你想要默认自动去除用户输入内容中两端的空格，你可以在 <code>v-model</code> 后添加 <code>.trim</code> 修饰符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input v-model.trim=&quot;msg&quot; /&gt;<br></code></pre></td></tr></table></figure><h2 id="组件上的-v-model"><a href="#组件上的-v-model" class="headerlink" title="组件上的 v-model"></a>组件上的 <code>v-model</code></h2><p>​HTML 的内置表单输入类型并不总能满足所有需求。幸运的是，我们可以使用 Vue 构建具有自定义行为的可复用输入组件，并且这些输入组件也支持 <code>v-model</code>！要了解更多关于此的内容，请在组件指引中阅读<a href="https://cn.vuejs.org/guide/components/v-model.html">配合 <code>v-model</code> 使用</a>。</p>]]></content>
    
    
    <categories>
      
      <category>vue基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>事件处理</title>
    <link href="/vue%E5%9F%BA%E7%A1%80-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <url>/vue%E5%9F%BA%E7%A1%80-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>​我们可以使用 指令 (简写为 ) 来监听 DOM 事件，并在事件触发时执行对应的 JavaScript。 用法： 或 。<code>v-on``@``v-on:click=&quot;handler&quot;``@click=&quot;handler&quot;</code></p><p>事件处理器 (handler) 的值可以是：</p><ol><li><strong>内联事件处理器</strong>：事件被触发时执行的内联 JavaScript 语句 (与 类似)。<code>onclick</code></li><li><strong>方法事件处理器</strong>：一个指向组件上定义的方法的属性名或是路径。</li></ol><h2 id="内联事件处理器"><a href="#内联事件处理器" class="headerlink" title="内联事件处理器"></a>内联事件处理器</h2><p>内联事件处理器通常用于简单场景，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click=&quot;count++&quot;&gt;Add 1&lt;/button&gt;<br>&lt;p&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/p&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNo9jssKgzAURH/lko0tgrbbEqX+Q5fZaLxiqHmQ3LgJ+fdqFZcD58xMYp1z1RqRvRgP0itHEJCia4VR2llPkMDjBBkmbzUUG1oII4y0JhBIGw2hh2Znbo+7MLw+WjZ/C4TaLT3hnogPkcgaeMtFyW8j2GmXpWBtN47w5PWBHLhrPzPCKfWDXRHmPsCAaOBfgSOkdH3IGUhpDBWv9/e8vsZZ/gFFhFJN">在演练场中尝试一下</a></p><h2 id="方法事件处理器"><a href="#方法事件处理器" class="headerlink" title="方法事件处理器"></a>方法事件处理器</h2><p>​随着事件处理器的逻辑变得愈发复杂，内联代码方式变得不够灵活。 因此 也可以接受一个方法名或对某个方法的调用。<code>v-on</code></p><p>举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Vue.js&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name.value&#125;</span>!`</span>)<br>  <span class="hljs-comment">// `event` 是 DOM 原生事件</span><br>  <span class="hljs-keyword">if</span> (event) &#123;<br>    <span class="hljs-title function_">alert</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- `greet` 是上面定义过的方法名 --&gt;<br>&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNpVj0FLxDAQhf/KMwjtXtq7dBcFQS/qzVMOrWFao2kSkkkvpf/dJIuCEBgm771vZnbx4H23JRJ3YogqaM+IxMlfpNWrd4GxI9CMA3NwK5psbaSVVjkbGXZaCediaJv3RN1XbE5FnZNVrJ3FEoi4pY0sn7BLC0yGArfjMxnjcLsXQrdNJtFxM+Ys0PcYa2CEjuBPylNYb4THtxdUobj0jH/YX3D963gKC5WyvGZ+xR7S5jf01yPzeblhWr2ZmErHw0dizivfK6PV91mKursUl6dSh/4qZ+vQ/+XE8QODonDi">在演练场中尝试一下</a></p><p>​方法事件处理器会自动接收原生 DOM 事件并触发执行。 在上面的例子中，我们能够通过被触发事件的 访问到该 DOM 元素。<code>event.target</code></p><h3 id="方法与内联事件判断"><a href="#方法与内联事件判断" class="headerlink" title="方法与内联事件判断"></a>方法与内联事件判断</h3><p>​模板编译器会通过检查 <code>v-on</code> 的值是否是合法的 JavaScript 标识符或属性访问路径来断定是何种形式的事件处理器。举例来说，<code>foo</code>、<code>foo.bar</code> 和 <code>foo[&#39;bar&#39;]</code> 会被视为方法事件处理器，而 <code>foo()</code> 和 <code>count++</code> 会被视为内联事件处理器。注意，在 Vue 模板中，<code>foo</code> 仅是一个占位符，可以替换为任何合法的 JavaScript 标识符。</p><h2 id="在内联处理器中调用方法"><a href="#在内联处理器中调用方法" class="headerlink" title="在内联处理器中调用方法"></a>在内联处理器中调用方法</h2><p>​除了直接绑定方法名，你还可以在内联事件处理器中调用方法。这允许我们向方法传入自定义参数以代替原生事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">message</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(message)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click=&quot;say(&#x27;hello&#x27;)&quot;&gt;Say hello&lt;/button&gt;<br>&lt;button @click=&quot;say(&#x27;bye&#x27;)&quot;&gt;Say bye&lt;/button&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNp9jTEOwjAMRa8SeSld6I5CBWdg9ZJGBiJSN2ocpKjq3UmpFDGx+Vn//b/ANYTjOxGcQEc7uyAqkqTQI98TW3ETq2jyYaQYzYNatSArZTzNUn/IK7Ludr2IBYTG4I3QRqKHJFJ6LtY7+zojbIXNk7yfmhahv5msvqS7PfnHGjJVp9w/hu7qKKwfEd1NSg==">在演练场中尝试一下</a></p><h2 id="在内联事件处理器中访问事件参数"><a href="#在内联事件处理器中访问事件参数" class="headerlink" title="在内联事件处理器中访问事件参数"></a>在内联事件处理器中访问事件参数</h2><p>​有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的变量，或者使用内联箭头函数：<code>$event</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 使用特殊的 $event 变量 --&gt;<br>&lt;button @click=&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;&gt;<br>  Submit<br>&lt;/button&gt;<br><br>&lt;!-- 使用内联箭头函数 --&gt;<br>&lt;button @click=&quot;(event) =&gt; warn(&#x27;Form cannot be submitted yet.&#x27;, event)&quot;&gt;<br>  Submit<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">warn</span>(<span class="hljs-params">message, event</span>) &#123;<br>  <span class="hljs-comment">// 这里可以访问原生事件</span><br>  <span class="hljs-keyword">if</span> (event) &#123;<br>    event.<span class="hljs-title function_">preventDefault</span>()<br>  &#125;<br>  <span class="hljs-title function_">alert</span>(message)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>​在处理事件时调用 或 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。<code>event.preventDefault()``event.stopPropagation()</code></p><p>为解决这一问题，Vue 为 提供了<strong>事件修饰符</strong>。修饰符是用 表示的指令后缀，包含以下这些：<code>v-on``.</code></p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.self</code></li><li><code>.capture</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 单击事件将停止传递 --&gt;<br>&lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;<br><br>&lt;!-- 提交事件将不再重新加载页面 --&gt;<br>&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;<br><br>&lt;!-- 修饰语可以使用链式书写 --&gt;<br>&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;<br><br>&lt;!-- 也可以只有修饰符 --&gt;<br>&lt;form @submit.prevent&gt;&lt;/form&gt;<br><br>&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;<br>&lt;!-- 例如：事件处理器不来自子元素 --&gt;<br>&lt;div @click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>​使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。因此使用 <code>@click.prevent.self</code> 会阻止<strong>元素及其子元素的所有点击事件的默认行为</strong>，而 <code>@click.self.prevent</code> 则只会阻止对元素本身的点击事件的默认行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 添加事件监听器时，使用 `capture` 捕获模式 --&gt;<br>&lt;!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 --&gt;<br>&lt;div @click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;<br><br>&lt;!-- 点击事件最多被触发一次 --&gt;<br>&lt;a @click.once=&quot;doThis&quot;&gt;&lt;/a&gt;<br><br>&lt;!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 --&gt;<br>&lt;!-- 以防其中包含 `event.preventDefault()` --&gt;<br>&lt;div @scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><code>.passive</code> 修饰符一般用于触摸事件的监听器，可以用来<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD">改善移动端设备的滚屏性能</a></p><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>​在监听键盘事件时，我们经常需要检查特定的按键。 Vue 允许在 或 监听按键事件时添加按键修饰符。<code>v-on``@</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 仅在 `key` 为 `Enter` 时调用 `submit` --&gt;<br>&lt;input @keyup.enter=&quot;submit&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​你可以直接使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/UI_Events/Keyboard_event_key_values"><code>KeyboardEvent.key</code></a> 暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input @keyup.page-down=&quot;onPageDown&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​在上面的例子中，仅会在 为 时调用事件处理。<code>$event.key``&#39;PageDown&#39;</code></p><h3 id="按键别名"><a href="#按键别名" class="headerlink" title="按键别名"></a>按键别名</h3><p>Vue 为一些常用的按键提供了别名：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“Delete”和“Backspace”两个按键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><h3 id="系统按键修饰符"><a href="#系统按键修饰符" class="headerlink" title="系统按键修饰符"></a>系统按键修饰符</h3><p>你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><p>注意</p><p>​在 Mac 键盘上，meta 是 Command 键 (⌘)。 在 Windows 键盘上，meta 键是 Windows 键 (⊞)。 在 Sun 微机系统键盘上，meta 是钻石键 (◆)。 在某些键盘上，特别是 MIT 和 Lisp 机器的键盘及其后代版本的键盘，如 Knight 键盘，space-cadet 键盘，meta 都被标记为“META”。 在 Symbolics 键盘上，meta 也被标识为“META”或“Meta”。</p><p>举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- Alt + Enter --&gt;<br>&lt;input @keyup.alt.enter=&quot;clear&quot; /&gt;<br><br>&lt;!-- Ctrl + 点击 --&gt;<br>&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>​请注意，系统按键修饰符和常规按键不同。 与 事件一起使用时，该按键必须在事件发出时处于按下状态。 换句话说， 只会在你仍然按住 但松开了另一个键时被触发。 若你单独松开 键将不会触发。<code>keyup``keyup.ctrl``ctrl``ctrl</code></p><h3 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a><code>.exact</code> 修饰符</h3><p>​<code>.exact</code> 修饰符允许精确控制触发事件所需的系统修饰符的组合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;<br>&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;<br><br>&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;<br>&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;<br><br>&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;<br>&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;<br></code></pre></td></tr></table></figure><h2 id="鼠标按键修饰符"><a href="#鼠标按键修饰符" class="headerlink" title="鼠标按键修饰符"></a>鼠标按键修饰符</h2><ul><li><code>.left</code></li><li><code>.right</code></li><li><code>.middle</code></li></ul><p>这些修饰符将处理程序限定为由特定鼠标按键触发的事件。</p>]]></content>
    
    
    <categories>
      
      <category>vue基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>条件渲染</title>
    <link href="/vue%E5%9F%BA%E7%A1%80-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
    <url>/vue%E5%9F%BA%E7%A1%80-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><p><code>v-for</code></p><p>​我们可以使用 <code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令的值需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据的数组，而 <code>item</code> 是迭代项的<strong>别名</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> items = <span class="hljs-title function_">ref</span>([&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;, &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125;])<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;item in items&quot;&gt;<br>  &#123;&#123; item.message &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>在 <code>v-for</code> 块中可以完整地访问父作用域内的属性和变量。<code>v-for</code> 也支持使用可选的第二个参数表示当前项的位置索引。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> parentMessage = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Parent&#x27;</span>)<br><span class="hljs-keyword">const</span> items = <span class="hljs-title function_">ref</span>([&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;, &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125;])<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;(item, index) in items&quot;&gt;<br>  &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNpdTsuqwjAQ/ZVDNlFQu5d64bpwJ7g3LopOJdAmIRlFCPl3p60PcDWcM+eV1X8Iq/uN1FrV6RxtYCTiW/gzzvbBR0ZGpBYFbfQ9tEi1ccadvUuM0ERyvKeUmithMyhn+jCSev4WWaY+vZ7HjH5Sr6F33muUhTR8uW0ThTuJua6mPbJEgGSErmEaENedxX3Z+rgxajbEL2DdhR5zOVOdUSIEDOf8M7IULCHsaPgiMa1eK4QcS6rOSkhdfapVeQLQEWnH">在演练场中尝试一下</a></p><p><code>v-for</code> 变量的作用域和下面的 JavaScript 代码很类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> parentMessage = <span class="hljs-string">&#x27;Parent&#x27;</span><br><span class="hljs-keyword">const</span> items = [<br>  <span class="hljs-comment">/* ... */</span><br>]<br><br>items.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 可以访问外层的 `parentMessage`</span><br>  <span class="hljs-comment">// 而 `item` 和 `index` 只在这个作用域可用</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parentMessage, item.<span class="hljs-property">message</span>, index)<br>&#125;)<br></code></pre></td></tr></table></figure><p>​注意 <code>v-for</code> 是如何对应 <code>forEach</code> 回调的函数签名的。实际上，你也可以在定义 <code>v-for</code> 的变量别名时使用解构，和解构函数参数类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;&#123; message &#125; in items&quot;&gt;<br>  &#123;&#123; message &#125;&#125;<br>&lt;/li&gt;<br><br>&lt;!-- 有 index 索引时 --&gt;<br>&lt;li v-for=&quot;(&#123; message &#125;, index) in items&quot;&gt;<br>  &#123;&#123; message &#125;&#125; &#123;&#123; index &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>对于多层嵌套的 <code>v-for</code>，作用域的工作方式和函数的作用域很类似。每个 <code>v-for</code> 作用域都可以访问到父级作用域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;item in items&quot;&gt;<br>  &lt;span v-for=&quot;childItem in item.children&quot;&gt;<br>    &#123;&#123; item.message &#125;&#125; &#123;&#123; childItem &#125;&#125;<br>  &lt;/span&gt;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>你也可以使用 <code>of</code> 作为分隔符来替代 <code>in</code>，这更接近 JavaScript 的迭代器语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><h2 id="v-for-与对象"><a href="#v-for-与对象" class="headerlink" title="v-for 与对象"></a><code>v-for</code> 与对象</h2><p>​你也可以使用 <code>v-for</code> 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 <code>Object.values()</code> 的返回值来决定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myObject = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;How to do lists in Vue&#x27;</span>,<br>  <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Jane Doe&#x27;</span>,<br>  <span class="hljs-attr">publishedAt</span>: <span class="hljs-string">&#x27;2016-04-10&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;ul&gt;<br>  &lt;li v-for=&quot;value in myObject&quot;&gt;<br>    &#123;&#123; value &#125;&#125;<br>  &lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>可以通过提供第二个参数表示属性名 (例如 key)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;(value, key) in myObject&quot;&gt;<br>  &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>第三个参数表示位置索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt;<br>  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNo9jjFvgzAQhf/KE0sSCQKpqg7IqRSpQ9WlWycvBC6KW2NbcKaNEP+9B7Tx4nt33917Y3IKYT9ESspE9XVnAqMnjuFZO9MG3zFGdFTVbAbChEvnW2yE32inXe1dz2hv7+dPqhnHO7kdtQPYsKUSm1f/DfZoPKzpuYdx+JAL6cxUka++E+itcoQX/9cO8SzslZoTy+yhODxlxWN2KMR22mmn8jWrpBTB1AZbMc2KVbTyQ56yBkN28d1RJ9uhspFSfNEtFf+GfnZzjP/oOll2NQPjuM4xTftZyIaU5VwuN0SsqMqtWZxUvliq/J4jmX4BTCp08A==">在演练场中尝试一下</a></p><h2 id="在-v-for-里使用范围值"><a href="#在-v-for-里使用范围值" class="headerlink" title="在 v-for 里使用范围值"></a>在 <code>v-for</code> 里使用范围值</h2><p><code>v-for</code> 可以直接接受一个整数值。在这种用例中，会将该模板基于 <code>1...n</code> 的取值范围重复多次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure><p>注意此处 <code>n</code> 的初值是从 <code>1</code> 开始而非 <code>0</code>。</p><h2 id="上的-v-for"><a href="#上的-v-for" class="headerlink" title="&lt;template&gt; 上的 v-for"></a><code>&lt;template&gt;</code> 上的 <code>v-for</code></h2><p>与模板上的 <code>v-if</code> 类似，你也可以在 <code>&lt;template&gt;</code> 标签上使用 <code>v-for</code> 来渲染一个包含多个元素的块。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;ul&gt;<br>  &lt;template v-for=&quot;item in items&quot;&gt;<br>    &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;<br>    &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt;<br>  &lt;/template&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><h2 id="v-for-与-v-if"><a href="#v-for-与-v-if" class="headerlink" title="v-for 与 v-if"></a><code>v-for</code> 与 <code>v-if</code></h2><p>​同时使用 <code>v-if</code> 和 <code>v-for</code> 是<strong>不推荐的</strong>，因为这样二者的优先级不明显。请转阅<a href="https://cn.vuejs.org/style-guide/rules-essential.html#avoid-v-if-with-v-for">风格指南</a>查看更多细节。</p><p>​当它们同时存在于一个节点上时，<code>v-if</code> 比 <code>v-for</code> 的优先级更高。这意味着 <code>v-if</code> 的条件将无法访问到 <code>v-for</code> 作用域内定义的变量别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!--<br> 这会抛出一个错误，因为属性 todo 此时<br> 没有在该实例上定义<br>--&gt;<br>&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;<br>  &#123;&#123; todo.name &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>在外先包装一层 <code>&lt;template&gt;</code> 再在其上使用 <code>v-for</code> 可以解决这个问题 (这也更加明显易读)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;template v-for=&quot;todo in todos&quot;&gt;<br>  &lt;li v-if=&quot;!todo.isComplete&quot;&gt;<br>    &#123;&#123; todo.name &#125;&#125;<br>  &lt;/li&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h2 id="通过-key-管理状态"><a href="#通过-key-管理状态" class="headerlink" title="通过 key 管理状态"></a>通过 key 管理状态</h2><p>​Vue 默认按照“就地更新”的策略来更新通过 <code>v-for</code> 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。</p><p>​默认模式是高效的，但<strong>只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况</strong>。</p><p>​为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 <code>key</code> attribute：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;<br>  &lt;!-- 内容 --&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>当你使用 <code>&lt;template v-for&gt;</code> 时，<code>key</code> 应该被放置在这个 <code>&lt;template&gt;</code> 容器上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;template v-for=&quot;todo in todos&quot; :key=&quot;todo.name&quot;&gt;<br>  &lt;li&gt;&#123;&#123; todo.name &#125;&#125;&lt;/li&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>注意</p><p>​<code>key</code> 在这里是一个通过 <code>v-bind</code> 绑定的特殊 attribute。请不要和<a href="https://cn.vuejs.org/guide/essentials/list.html#v-for-with-an-object">在 <code>v-for</code> 中使用对象</a>里所提到的对象属性名相混淆。</p><p>​<a href="https://cn.vuejs.org/style-guide/rules-essential.html#use-keyed-v-for">推荐</a>在任何可行的时候为 <code>v-for</code> 提供一个 <code>key</code> attribute，除非所迭代的 DOM 内容非常简单 (例如：不包含组件或有状态的 DOM 元素)，或者你想有意采用默认行为来提高性能。</p><p><code>key</code> 绑定的值期望是一个基础类型的值，例如字符串或 number 类型。不要用对象作为 <code>v-for</code> 的 key。关于 <code>key</code> attribute 的更多用途细节，请参阅 <a href="https://cn.vuejs.org/api/built-in-special-attributes.html#key"><code>key</code> API 文档</a>。</p><h2 id="组件上使用-v-for"><a href="#组件上使用-v-for" class="headerlink" title="组件上使用 v-for"></a>组件上使用 <code>v-for</code></h2><p>我们可以直接在组件上使用 <code>v-for</code>，和在一般的元素上使用没有区别 (别忘记提供一个 <code>key</code>)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent v-for=&quot;item in items&quot; :key=&quot;item.id&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还需要传递 props：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent<br>  v-for=&quot;(item, index) in items&quot;<br>  :item=&quot;item&quot;<br>  :index=&quot;index&quot;<br>  :key=&quot;item.id&quot;<br>/&gt;<br></code></pre></td></tr></table></figure><p>​不自动将 <code>item</code> 注入组件的原因是，这会使组件与 <code>v-for</code> 的工作方式紧密耦合。明确其数据的来源可以使组件在其他情况下重用。</p><p>​这里是一个简单的 <a href="https://play.vuejs.org/#eNp1U8Fu2zAM/RXCGGAHTWx02ylwgxZYB+ywYRhyq3dwLGYRYkuCJTsZjPz7KMmK3ay9JBQfH/meKA/Rk1Jp32G0jnJdtVwZ0Gg6tSkEb5RsDQzQ4h4usG9lAzGVxldoK5n8ZrAZsTQLCduRygAKUUmhDQg8WWyLZwMPtmESx4sAGkL0mH6xrMH+AHC2hvuljw03Na4h/iLBHBAY1wfUbsTFVcwoH28o2/KIIDuaQ0TTlvrwNu/TDe+7PDlKXZ6EZxTiN4kuRI3W0dk4u4yUf7bZfScqw6WAkrEf3m+y8AOcw7Qv6w5T1elDMhs7Nbq7e61gdmme60SQAvgfIhExiSSJeeb3SBukAy1D1aVBezL5XrYN9Csp1rrbNdykqsUehXkookl0EVGxlZHX5Q5rIBLhNHFlbRD6xBiUzlOeuZJQz4XqjI+BxjSSYe2pQWwRBZizV01DmsRWeJA1Qzv0Of2TwldE5hZRlVd+FkbuOmOksJLybIwtkmfWqg+7qz47asXpSiaN3lxikSVwwfC8oD+/sEnV+oh/qcxmU85mebepgLjDBD622Mg+oDrVquYVJm7IEu4XoXKTZ1dho3gnmdJhedEymn9ab3ysDPdc4M9WKp28xE5JbB+rzz/Trm3eK3LAu8/E7p2PNzYM/i3ChR7W7L7hsSIvR7L2Aal1EhqTp80vF95sw3WcG7r8A0XaeME=">Todo List 的例子</a>，展示了如何通过 <code>v-for</code> 来渲染一个组件列表，并向每个实例中传入不同的数据。</p><h2 id="数组变化侦测"><a href="#数组变化侦测" class="headerlink" title="数组变化侦测"></a>数组变化侦测</h2><h3 id="变更方法"><a href="#变更方法" class="headerlink" title="变更方法"></a>变更方法</h3><p>Vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括：</p><ul><li><p><code>push()</code>:在数组末尾添加一个或多个元素，并返回新的数组长度。</p></li><li><p><code>pop():</code>移除并返回数组的最后一个元素。</p></li><li><p><code>shift()</code>:移除并返回数组的第一个元素。</p></li><li><p><code>unshift()</code>:在数组的开头添加一个或多个元素，并返回新的数组长度。</p></li><li><p><code>splice()</code>:通过删除、添加或替换的方式修改数组内容，并返回被删除的元素（若有）。</p><ul><li><strong>参数</strong>：</li><li><code>start</code>：起始索引。</li><li><code>deleteCount</code>：要删除的元素数量。</li><li><code>...items</code>：要添加的新元素。</li></ul></li><li><p><code>sort()</code>:对数组进行原地排序，并返回排序后的数组。</p></li><li><p><code>reverse():</code>将数组的元素顺序颠倒，并返回修改后的数组。</p></li></ul><h3 id="替换一个数组"><a href="#替换一个数组" class="headerlink" title="替换一个数组"></a>替换一个数组</h3><p>​变更方法，顾名思义，就是会对调用它们的原数组进行变更。相对地，也有一些不可变 (immutable) 方法，例如</p><ul><li><code>map()</code>用于对数组中的每个元素进行操作，并返回一个新数组</li><li><code>reduce()</code>用于将数组中的元素通过回调函数归纳为单个值，返回新值</li><li><code>flatMap()</code>对数组中的每个元素进行映射，并将结果扁平化为一个新数组 </li><li>这些都不会更改原数组，而总是<strong>返回一个新数组</strong>。</li><li>当遇到的是非变更方法时，我们需要将旧的数组替换为新的：<code>filter()</code>，<code>concat()</code> 和 <code>slice()</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// `items` 是一个数组的 ref</span><br>items.<span class="hljs-property">value</span> = items.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">message</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/Foo/</span>))<br></code></pre></td></tr></table></figure><p>​你可能认为这将导致 Vue 丢弃现有的 DOM 并重新渲染整个列表——幸运的是，情况并非如此。Vue 实现了一些巧妙的方法来最大化对 DOM 元素的重用，因此用另一个包含部分重叠对象的数组来做替换，仍会是一种非常高效的操作。</p><h2 id="展示过滤或排序后的结果"><a href="#展示过滤或排序后的结果" class="headerlink" title="展示过滤或排序后的结果"></a>展示过滤或排序后的结果</h2><p>​有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性。</p><p>举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = <span class="hljs-title function_">ref</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-keyword">const</span> evenNumbers = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> numbers.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>在计算属性不可行的情况下 (例如在多层嵌套的 <code>v-for</code> 循环中)，你可以使用以下方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sets = <span class="hljs-title function_">ref</span>([<br>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],<br>  [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br>])<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">even</span>(<span class="hljs-params">numbers</span>) &#123;<br>  <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;ul v-for=&quot;numbers in sets&quot;&gt;<br>  &lt;li v-for=&quot;n in even(numbers)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>​在计算属性中使用 <code>reverse()</code> 和 <code>sort()</code> 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- return numbers.reverse()</span><br><span class="hljs-addition">+ return [...numbers].reverse()</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>条件渲染</title>
    <link href="/vue%E5%9F%BA%E7%A1%80-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"/>
    <url>/vue%E5%9F%BA%E7%A1%80-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><code>v-if</code></h2><p>​<code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回真值时才被渲染。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;<br></code></pre></td></tr></table></figure><h2 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a><code>v-else</code></h2><p>​你也可以使用 <code>v-else</code> 为 <code>v-if</code> 添加一个“else 区块”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;button @click=&quot;awesome = !awesome&quot;&gt;Toggle&lt;/button&gt;<br><br>&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;<br>&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNpFjkEOgjAQRa8ydIMulLA1hegJ3LnqBskAjdA27RQXhHu4M/GEHsEiKLv5mfdf/sBOxux7j+zAuCutNAQOyZtcKNkZbQkGsFjBCJXVHcQBjYUSqtTKERR3dLpDyCZmQ9bjViiezKKgCIGwM21BGBIAv3oireBYtrK8ZYKtgmg5BctJ13WLPJnhr0YQb1Lod7JaS4G8eATpfjMinjTphC8wtg7zcwNKw/v5eC1fnvwnsfEDwaha7w==">在演练场中尝试一下</a></p><p>一个 <code>v-else</code> 元素必须跟在一个 <code>v-if</code> 或者 <code>v-else-if</code> 元素后面，否则它将不会被识别。</p><h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a><code>v-else-if</code></h2><p>顾名思义，<code>v-else-if</code> 提供的是相应于 <code>v-if</code> 的“else if 区块”。它可以连续多次重复使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;<br>  A<br>&lt;/div&gt;<br>&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;<br>  B<br>&lt;/div&gt;<br>&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;<br>  C<br>&lt;/div&gt;<br>&lt;div v-else&gt;<br>  Not A/B/C<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>和 <code>v-else</code> 类似，一个使用 <code>v-else-if</code> 的元素必须紧跟在一个 <code>v-if</code> 或一个 <code>v-else-if</code> 元素后面。</p><h2 id="上的-v-if"><a href="#上的-v-if" class="headerlink" title="&lt;template&gt; 上的 v-if"></a><code>&lt;template&gt;</code> 上的 <code>v-if</code></h2><p>​因为 <code>v-if</code> 是一个指令，他必须依附于某个元素。但如果我们想要切换不止一个元素呢？在这种情况下我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-if</code>，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 <code>&lt;template&gt;</code> 元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;template v-if=&quot;ok&quot;&gt;<br>  &lt;h1&gt;Title&lt;/h1&gt;<br>  &lt;p&gt;Paragraph 1&lt;/p&gt;<br>  &lt;p&gt;Paragraph 2&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><code>v-else</code> 和 <code>v-else-if</code> 也可以在 <code>&lt;template&gt;</code> 上使用。</p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><code>v-show</code></h2><p>另一个可以用来按条件显示一个元素的指令是 <code>v-show</code>。其用法基本一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p>不同之处在于 <code>v-show</code> 会在 DOM 渲染中保留该元素；<code>v-show</code> 仅切换了该元素上名为 <code>display</code> 的 CSS 属性。</p><p><code>v-show</code> 不支持在 <code>&lt;template&gt;</code> 元素上使用，也不能和 <code>v-else</code> 搭配使用。</p><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs. v-show"></a><code>v-if</code> vs. <code>v-show</code></h2><ol><li><code>v-if</code> 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。</li><li><code>v-if</code> 也是<strong>惰性</strong>的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。</li><li>相比之下，<code>v-show</code> 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS <code>display</code> 属性会被切换。</li><li>总的来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 <code>v-show</code> 较好；如果在运行时绑定条件很少改变，则 <code>v-if</code> 会更合适。</li></ol><h2 id="v-if-和-v-for"><a href="#v-if-和-v-for" class="headerlink" title="v-if 和 v-for"></a><code>v-if</code> 和 <code>v-for</code></h2><ul><li>同时使用 <code>v-if</code> 和 <code>v-for</code> 是<strong>不推荐的</strong>，因为这样二者的优先级不明显。请查看<a href="https://cn.vuejs.org/style-guide/rules-essential.html#avoid-v-if-with-v-for">风格指南</a>获得更多信息。</li><li>当 <code>v-if</code> 和 <code>v-for</code> 同时存在于一个元素上的时候，<code>v-if</code> 会首先被执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>vue基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>类与样式绑定</title>
    <link href="/vue%E5%9F%BA%E7%A1%80-%E7%B1%BB%E4%B8%8E%E6%A0%B7%E5%BC%8F%E7%BB%91%E5%AE%9A/"/>
    <url>/vue%E5%9F%BA%E7%A1%80-%E7%B1%BB%E4%B8%8E%E6%A0%B7%E5%BC%8F%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h1><p>​数据绑定的一个常见需求场景是操纵元素的 CSS class 列表和内联样式。因为 <code>class</code> 和 <code>style</code> 都是 attribute，我们可以和其他 attribute 一样使用 <code>v-bind</code> 将它们和动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易出错的。因此，Vue 专门为 <code>class</code> 和 <code>style</code> 的 <code>v-bind</code> 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。</p><h2 id="绑定-HTML-class"><a href="#绑定-HTML-class" class="headerlink" title="绑定 HTML class"></a>绑定 HTML class</h2><h3 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h3><p>​我们可以给 <code>:class</code> (<code>v-bind:class</code> 的缩写) 传递一个对象来动态切换 class：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>​上面的语法表示 <code>active</code> 是否存在取决于数据属性 <code>isActive</code> 的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">真假值</a>。</p><p>​你可以在对象中写多个字段来操作多个 class。此外，<code>:class</code> 指令也可以和一般的 <code>class</code> attribute 共存。举例来说，下面这样的状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> isActive = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">const</span> hasError = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><p>配合以下模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div<br>  class=&quot;static&quot;<br>  :class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;<br>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>渲染的结果会是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>​当 <code>isActive</code> 或者 <code>hasError</code> 改变时，class 列表会随之更新。举例来说，如果 <code>hasError</code> 变为 <code>true</code>，class 列表也会变成 <code>&quot;static active text-danger&quot;</code>。</p><p>​绑定的对象并不一定需要写成内联字面量的形式，也可以直接绑定一个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> classObject = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&#x27;text-danger&#x27;</span>: <span class="hljs-literal">false</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这将渲染：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div class=&quot;active&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>我们也可以绑定一个返回对象的<a href="https://cn.vuejs.org/guide/essentials/computed.html">计算属性</a>。这是一个常见且很有用的技巧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> isActive = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">const</span> error = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br><br><span class="hljs-keyword">const</span> classObject = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> (&#123;<br>  <span class="hljs-attr">active</span>: isActive.<span class="hljs-property">value</span> &amp;&amp; !error.<span class="hljs-property">value</span>,<br>  <span class="hljs-string">&#x27;text-danger&#x27;</span>: error.<span class="hljs-property">value</span> &amp;&amp; error.<span class="hljs-property">value</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;fatal&#x27;</span><br>&#125;))<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><h3 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h3><p>我们可以给 <code>:class</code> 绑定一个数组来渲染多个 CSS class：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> activeClass = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br><span class="hljs-keyword">const</span> errorClass = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;text-danger&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>渲染的结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>如果你也想在数组中有条件地渲染某个 class，你可以使用三元表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><code>errorClass</code> 会一直存在，但 <code>activeClass</code> 只会在 <code>isActive</code> 为真时才存在。</p><p>然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;[&#123; [activeClass]: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><h3 id="在组件上使用"><a href="#在组件上使用" class="headerlink" title="在组件上使用"></a>在组件上使用</h3><blockquote><p>本节假设你已经有 <a href="https://cn.vuejs.org/guide/essentials/component-basics.html">Vue 组件</a>的知识基础。如果没有，你也可以暂时跳过，以后再阅读。</p></blockquote><p>​对于只有一个根元素的组件，当你使用了 <code>class</code> attribute 时，这些 class 会被添加到根元素上并与该元素上已有的 class 合并。</p><p>举例来说，如果你声明了一个组件名叫 <code>MyComponent</code>，模板如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 子组件模板 --&gt;<br>&lt;p class=&quot;foo bar&quot;&gt;Hi!&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>在使用时添加一些 class：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 在使用组件时 --&gt;<br>&lt;MyComponent class=&quot;baz boo&quot; /&gt;<br></code></pre></td></tr></table></figure><p>渲染出的 HTML 为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi!&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>Class 的绑定也是同样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent :class=&quot;&#123; active: isActive &#125;&quot; /&gt;<br></code></pre></td></tr></table></figure><p>当 <code>isActive</code> 为真时，被渲染的 HTML 会是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p class=&quot;foo bar active&quot;&gt;Hi!&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>​如果你的组件有多个根元素，你将需要指定哪个根元素来接收这个 class。你可以通过组件的 <code>$attrs</code> 属性来指定接收的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- MyComponent 模板使用 $attrs 时 --&gt;<br>&lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;<br>&lt;span&gt;This is a child component&lt;/span&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent class=&quot;baz&quot; /&gt;<br></code></pre></td></tr></table></figure><p>这将被渲染为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;baz&quot;</span>&gt;</span>Hi!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>This is a child component<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>你可以在<a href="https://cn.vuejs.org/guide/components/attrs.html">透传 Attribute</a> 一章中了解更多组件的 attribute 继承的细节。</p><h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h2><h3 id="绑定对象-1"><a href="#绑定对象-1" class="headerlink" title="绑定对象"></a>绑定对象</h3><p><code>:style</code> 支持绑定 JavaScript 对象值，对应的是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style">HTML 元素的 <code>style</code> 属性</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> activeColor = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;red&#x27;</span>)<br><span class="hljs-keyword">const</span> fontSize = <span class="hljs-title function_">ref</span>(<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>尽管推荐使用 camelCase，但 <code>:style</code> 也支持 kebab-cased 形式的 CSS 属性 key (对应其 CSS 中的实际名称)，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;&#123; &#x27;font-size&#x27;: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>直接绑定一个样式对象通常是一个好主意，这样可以使模板更加简洁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> styleObject = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;30px&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>同样的，如果样式对象需要更复杂的逻辑，也可以使用返回样式对象的计算属性。</p><h3 id="绑定数组-1"><a href="#绑定数组-1" class="headerlink" title="绑定数组"></a>绑定数组</h3><p>我们还可以给 <code>:style</code> 绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><h3 id="自动前缀"><a href="#自动前缀" class="headerlink" title="自动前缀"></a>自动前缀</h3><p>​当你在 <code>:style</code> 中使用了需要<a href="https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix">浏览器特殊前缀</a>的 CSS 属性时，Vue 会自动为他们加上相应的前缀。Vue 是在运行时检查该属性是否支持在当前浏览器中使用。如果浏览器不支持某个属性，那么将尝试加上各个浏览器特殊前缀，以找到哪一个是被支持的。</p><h3 id="样式多值"><a href="#样式多值" class="headerlink" title="样式多值"></a>样式多值</h3><p>你可以对一个样式属性提供多个 (不同前缀的) 值，举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要特别前缀的浏览器中都会渲染为 <code>display: flex</code>。</p>]]></content>
    
    
    <categories>
      
      <category>vue基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算属性</title>
    <link href="/vue%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <url>/vue%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><h2 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h2><p>​模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> author = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John Doe&#x27;</span>,<br>  <span class="hljs-attr">books</span>: [<br>    <span class="hljs-string">&#x27;Vue 2 - Advanced Guide&#x27;</span>,<br>    <span class="hljs-string">&#x27;Vue 3 - Basic Guide&#x27;</span>,<br>    <span class="hljs-string">&#x27;Vue 4 - The Mystery&#x27;</span><br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>​我们想根据 <code>author</code> 是否已有一些书籍来展示不同的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p&gt;Has published books:&lt;/p&gt;<br>&lt;span&gt;&#123;&#123; author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure><p>​这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于 <code>author.books</code>。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。</p><p>​因此我们推荐使用<strong>计算属性</strong>来描述依赖响应式状态的复杂逻辑。这是重构后的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; reactive, computed &#125; from &#x27;vue&#x27;<br><br>const author = reactive(&#123;<br>  name: &#x27;John Doe&#x27;,<br>  books: [<br>    &#x27;Vue 2 - Advanced Guide&#x27;,<br>    &#x27;Vue 3 - Basic Guide&#x27;,<br>    &#x27;Vue 4 - The Mystery&#x27;<br>  ]<br>&#125;)<br><br>// 一个计算属性 ref<br>const publishedBooksMessage = computed(() =&gt; &#123;<br>  return author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27;<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;p&gt;Has published books:&lt;/p&gt;<br>  &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNp1kE9Lw0AQxb/KI5dtoTainkoaaREUoZ5EEONhm0ybYLO77J9CCfnuzta0vdjbzr6Zeb95XbIwZroPlMySzJW2MR6OfDB5oZrWaOvRwZIsfbOnCUrdmuCpQo+N1S0ET4pCFarUynnI4GttMT9PjLpCAUq2NIN41bXCkyYxiZ9rrX/cDF/xDYiPQLjDDRbVXqqSHZ5DUw2tg3zP8lK6pvxHe2DtvSasDs6TPTAT8F2ofhzh0hTygm5pc+I1Yb1rXE3VMsKsyDm5JcY/9Y5GY8xzHI+wnIpVw4nTI/10R2rra+S4xSPEJzkBvvNNs310ztK/RDlLLjy1Zic9cQVkJn+R7gIwxJGlMXiWnZEq77orhH3Pq2NH9DjvTfpfSBSbmA==">在演练场中尝试一下</a></p><p>​我们在这里定义了一个计算属性 <code>publishedBooksMessage</code>。<code>computed()</code> 方法期望接收一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description">getter 函数</a>，返回值为一个<strong>计算属性 ref</strong>。和其他一般的 ref 类似，你可以通过 <code>publishedBooksMessage.value</code> 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 <code>.value</code>。</p><p>​Vue 的计算属性会自动追踪响应式依赖。它会检测到 <code>publishedBooksMessage</code> 依赖于 <code>author.books</code>，所以当 <code>author.books</code> 改变时，任何依赖于 <code>publishedBooksMessage</code> 的绑定都会同时更新。</p><h2 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h2><p>​你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p&gt;&#123;&#123; calculateBooksMessage() &#125;&#125;&lt;/p&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 组件中</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateBooksMessage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> author.<span class="hljs-property">books</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;Yes&#x27;</span> : <span class="hljs-string">&#x27;No&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于<strong>计算属性值会基于其响应式依赖被缓存</strong>。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 <code>author.books</code> 不改变，无论多少次访问 <code>publishedBooksMessage</code> 都会立即返回先前的计算结果，而不用重复执行 getter 函数。</p><p>​这也解释了为什么下面的计算属性永远不会更新，因为 <code>Date.now()</code> 并不是一个响应式依赖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> now = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>())<br></code></pre></td></tr></table></figure><p>​相比之下，方法调用<strong>总是</strong>会在重渲染发生时再次执行函数。</p><p>​为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 <code>list</code>，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 <code>list</code>。没有缓存的话，我们会重复执行非常多次 <code>list</code> 的 getter，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。</p><h2 id="可写计算属性"><a href="#可写计算属性" class="headerlink" title="可写计算属性"></a>可写计算属性</h2><p>​计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, computed &#125; from &#x27;vue&#x27;<br><br>const firstName = ref(&#x27;John&#x27;)<br>const lastName = ref(&#x27;Doe&#x27;)<br><br>const fullName = computed(&#123;<br>  // getter<br>  get() &#123;<br>    return firstName.value + &#x27; &#x27; + lastName.value<br>  &#125;,<br>  // setter<br>  set(newValue) &#123;<br>    // 注意：我们这里使用的是解构赋值语法<br>    [firstName.value, lastName.value] = newValue.split(&#x27; &#x27;)<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​现在当你再运行 <code>fullName.value = &#39;John Doe&#39;</code> 时，setter 会被调用而 <code>firstName</code> 和 <code>lastName</code> 会随之更新。</p><h3 id="Getter-不应有副作用"><a href="#Getter-不应有副作用" class="headerlink" title="Getter 不应有副作用"></a>Getter 不应有副作用</h3><p>​计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，<strong>不要改变其他状态、在 getter 中做异步请求或者更改 DOM</strong>！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用<a href="https://cn.vuejs.org/guide/essentials/watchers.html">侦听器</a>根据其他响应式状态的变更来创建副作用。</p><h3 id="避免直接修改计算属性值"><a href="#避免直接修改计算属性值" class="headerlink" title="避免直接修改计算属性值"></a>避免直接修改计算属性值</h3><p>​从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。</p>]]></content>
    
    
    <categories>
      
      <category>vue基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>响应式基础</title>
    <link href="/vue%E5%9F%BA%E7%A1%80-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    <url>/vue%E5%9F%BA%E7%A1%80-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h1><h2 id="声明响应式状态"><a href="#声明响应式状态" class="headerlink" title="声明响应式状态"></a>声明响应式状态</h2><h3 id="ref"><a href="#ref" class="headerlink" title="ref()"></a><code>ref()</code></h3><p>在组合式 API 中，推荐使用 <a href="https://cn.vuejs.org/api/reactivity-core.html#ref"><code>ref()</code></a> 函数来声明响应式状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const count = ref(0)<br></code></pre></td></tr></table></figure><p><code>ref()</code> 接收参数，并将其包裹在一个带有 <code>.value</code> 属性的 ref 对象中返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">const count = ref(0)<br><br>console.log(count) // &#123; value: 0 &#125;<br>console.log(count.value) // 0<br><br>count.value++<br>console.log(count.value) // 1<br></code></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://cn.vuejs.org/guide/typescript/composition-api.html#typing-ref">为 refs 标注类型</a> </p></blockquote><p>要在组件模板中访问 ref，请从组件的 <code>setup()</code> 函数中声明并返回它们：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; ref &#125; from &#x27;vue&#x27;<br><br>export default &#123;<br>  // `setup` 是一个特殊的钩子，专门用于组合式 API。<br>  setup() &#123;<br>    const count = ref(0)<br><br>    // 将 ref 暴露给模板<br>    return &#123;<br>      count<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>​注意，在模板中使用 ref 时，我们<strong>不</strong>需要附加 <code>.value</code>。为了方便起见，当在模板中使用时，ref 会自动解包。也可以直接在事件监听器中改变一个 ref：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click=&quot;count++&quot;&gt;<br>  &#123;&#123; count &#125;&#125;<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>对于更复杂的逻辑，我们可以在同一作用域内声明更改 ref 的函数，并将它们作为方法与状态一起公开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; ref &#125; from &#x27;vue&#x27;<br><br>export default &#123;<br>  setup() &#123;<br>    const count = ref(0)<br><br>    function increment() &#123;<br>      // 在 JavaScript 中需要 .value<br>      count.value++<br>    &#125;<br><br>    // 不要忘记同时暴露 increment 函数<br>    return &#123;<br>      count,<br>      increment<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，暴露的方法可以被用作事件监听器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click=&quot;increment&quot;&gt;<br>  &#123;&#123; count &#125;&#125;<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>这里是 <a href="https://codepen.io/vuejs-examples/pen/WNYbaqo">Codepen</a> 上的例子，没有使用任何构建工具。</p><h3 id=""><a href="#" class="headerlink" title="&lt;script setup&gt;"></a><code>&lt;script setup&gt;</code></h3><p>在 <code>setup()</code> 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用<a href="https://cn.vuejs.org/guide/scaling-up/sfc.html">单文件组件 (SFC)</a> 来避免这种情况。我们可以使用 <code>&lt;script setup&gt;</code> 来大幅度地简化代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const count = ref(0)<br><br>function increment() &#123;<br>  count.value++<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;<br>    &#123;&#123; count &#125;&#125;<br>  &lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNo9jUEKgzAQRa8yZKMiaNcllvYe2dgwQqiZhDhxE3L3jrW4/DPvv1/UK8Zhz6juSm82uciwIef4MOR8DImhQMIFKiwpeGgEbQwZsoE2BhsyMUwH0d66475ksuwCgSOb0CNx20ExBCc77POase8NVUN6PBdlSwKjj+vMKAlAvzOzWJ52dfYzGXXpjPoBAKX856uopDGeFfnq8XKp+gWq4FAi">在演练场中尝试一下</a></p><script setup> 中的顶层的导入、声明的变量和函数可在同一组件的模板中直接使用。你可以理解为模板是在同一作用域内声明的一个 JavaScript 函数——它自然可以访问与它一起声明的所有内容。### 为什么要使用 ref简单地讨论一下 Vue 的响应式系统是如何工作的。​当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue 会**追踪**在渲染过程中使用的每一个 ref。然后，当一个 ref 被修改时，它会**触发**追踪它的组件的一次重新渲染。​在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。​该 `.value` 属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。从概念上讲，你可以将 ref 看作是一个像这样的对象：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 伪代码，不是真正的实现<br>const myRef = &#123;<br>  _value: 0,<br>  get value() &#123;<br>    track()<br>    return this._value<br>  &#125;,<br>  set value(newValue) &#123;<br>    this._value = newValue<br>    trigger()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>​另一个 ref 的好处是，与普通变量不同，你可以将 ref 传递给函数，同时保留对最新值和响应式连接的访问。当将复杂的逻辑重构为可重用的代码时，这将非常有用。该响应性系统在[深入响应式原理](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html)章节中有更详细的讨论。### 深层响应性​Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构，比如 `Map`。​Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const obj = ref(&#123;<br>  nested: &#123; count: 0 &#125;,<br>  arr: [&#x27;foo&#x27;, &#x27;bar&#x27;]<br>&#125;)<br><br>function mutateDeeply() &#123;<br>  // 以下都会按照期望工作<br>  obj.value.nested.count++<br>  obj.value.arr.push(&#x27;baz&#x27;)<br>&#125;<br></code></pre></td></tr></table></figure>非原始值将通过 [`reactive()`](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#reactive) 转换为响应式代理，该函数将在后面讨论。​也可以通过 [shallow ref](https://cn.vuejs.org/api/reactivity-advanced.html#shallowref) 来放弃深层响应性。对于浅层 ref，只有 `.value` 的访问会被追踪。浅层 ref 可以用于避免对大型数据的响应性开销来优化性能、或者有外部库管理其内部状态的情况。### DOM 更新时机​当你修改了响应式状态时，DOM 会被自动更新。但是需要注意的是，DOM 更新不是同步的。Vue 会在“next tick”更新周期中缓冲所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。​要等待 DOM 更新完成后再执行额外的代码，可以使用 [nextTick()](https://cn.vuejs.org/api/general.html#nexttick) 全局 API：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; nextTick &#125; from &#x27;vue&#x27;<br><br>async function increment() &#123;<br>  count.value++<br>  await nextTick()<br>  // 现在 DOM 已经更新了<br>&#125;<br></code></pre></td></tr></table></figure>## `reactive()`​还有另一种声明响应式状态的方式，即使用 `reactive()` API。与将内部值包装在特殊对象中的 ref 不同，`reactive()` 将使对象本身具有响应性：js<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; reactive &#125; from &#x27;vue&#x27;<br><br>const state = reactive(&#123; count: 0 &#125;)<br></code></pre></td></tr></table></figure>> 参考：[为 `reactive()` 标注类型](https://cn.vuejs.org/guide/typescript/composition-api.html#typing-reactive) 在模板中使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click=&quot;state.count++&quot;&gt;<br>  &#123;&#123; state.count &#125;&#125;<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure>​响应式对象是 [JavaScript 代理](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，其行为就和普通对象一样。不同的是，Vue 能够拦截对响应式对象所有属性的访问和修改，以便进行依赖追踪和触发更新。​`reactive()` 将深层地转换对象：当访问嵌套对象时，它们也会被 `reactive()` 包装。当 ref 的值是一个对象时，`ref()` 也会在内部调用它。与浅层 ref 类似，这里也有一个 [`shallowReactive()`](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive) API 可以选择退出深层响应性。### Reactive Proxy vs. Original值得注意的是，`reactive()` 返回的是一个原始对象的 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，它和原始对象是不相等的：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">const raw = &#123;&#125;<br>const proxy = reactive(raw)<br><br>// 代理对象和原始对象不是全等的<br>console.log(proxy === raw) // false<br></code></pre></td></tr></table></figure>​只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用 Vue 的响应式系统的最佳实践是**仅使用你声明对象的代理版本**。​为保证访问代理的一致性，对同一个原始对象调用 `reactive()` 会总是返回同样的代理对象，而对一个已存在的代理对象调用 `reactive()` 会返回其本身：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 在同一个对象上调用 reactive() 会返回相同的代理<br>console.log(reactive(raw) === proxy) // true<br><br>// 在一个代理上调用 reactive() 会返回它自己<br>console.log(reactive(proxy) === proxy) // true<br></code></pre></td></tr></table></figure>​这个规则对嵌套对象也适用。依靠深层响应性，响应式对象内的嵌套对象依然是代理：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">const proxy = reactive(&#123;&#125;)<br><br>const raw = &#123;&#125;<br>proxy.nested = raw<br><br>console.log(proxy.nested === raw) // false<br></code></pre></td></tr></table></figure>### `reactive()` 的局限性`reactive()` API 有一些局限性：1. **有限的值类型**：它只能用于对象类型 (对象、数组和如 `Map`、`Set` 这样的[集合类型](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#keyed_collections))。它不能持有如 `string`、`number` 或 `boolean` 这样的[原始类型](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)。2. **不能替换整个对象**：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">let state = reactive(&#123; count: 0 &#125;)<br><br>// 上面的 (&#123; count: 0 &#125;) 引用将不再被追踪<br>// (响应性连接已丢失！)<br>state = reactive(&#123; count: 1 &#125;)<br></code></pre></td></tr></table></figure>3. **对解构操作不友好**：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">const state = reactive(&#123; count: 0 &#125;)<br><br>// 当解构时，count 已经与 state.count 断开连接<br>let &#123; count &#125; = state<br>// 不会影响原始的 state<br>count++<br><br>// 该函数接收到的是一个普通的数字<br>// 并且无法追踪 state.count 的变化<br>// 我们必须传入整个对象以保持响应性<br>callSomeFunction(state.count)<br></code></pre></td></tr></table></figure>由于这些限制，我们建议使用 `ref()` 作为声明响应式状态的主要 API。一个 ref 会在作为响应式对象的属性被访问或修改时自动解包。换句话说，它的行为就像一个普通的属性：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">const count = ref(0)<br>const state = reactive(&#123;<br>  count<br>&#125;)<br><br>console.log(state.count) // 0<br><br>state.count = 1<br>console.log(count.value) // 1<br></code></pre></td></tr></table></figure>如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">const otherCount = ref(2)<br><br>state.count = otherCount<br>console.log(state.count) // 2<br>// 原始 ref 现在已经和 state.count 失去联系<br>console.log(count.value) // 1<br></code></pre></td></tr></table></figure>只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为[浅层响应式对象](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive)的属性被访问时不会解包。### 数组和集合的注意事项与 reactive 对象不同的是，当 ref 作为响应式数组或原生集合类型 (如 `Map`) 中的元素被访问时，它**不会**被解包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">const books = reactive([ref(&#x27;Vue 3 Guide&#x27;)])<br>// 这里需要 .value<br>console.log(books[0].value)<br><br>const map = reactive(new Map([[&#x27;count&#x27;, ref(0)]]))<br>// 这里需要 .value<br>console.log(map.get(&#x27;count&#x27;).value)<br></code></pre></td></tr></table></figure>### 在模板中解包的注意事项在模板渲染上下文中，只有顶级的 ref 属性才会被解包。在下面的例子中，`count` 和 `object` 是顶级属性，但 `object.id` 不是：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">const count = ref(0)<br>const object = &#123; id: ref(1) &#125;<br></code></pre></td></tr></table></figure>因此，这个表达式按预期工作：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; count + 1 &#125;&#125;<br></code></pre></td></tr></table></figure>...但这个**不会**：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; object.id + 1 &#125;&#125;<br></code></pre></td></tr></table></figure>​渲染的结果将是 `[object Object]1`，因为在计算表达式时 `object.id` 没有被解包，仍然是一个 ref 对象。为了解决这个问题，我们可以将 `id` 解构为一个顶级属性：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">const &#123; id &#125; = object<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; id + 1 &#125;&#125;<br></code></pre></td></tr></table></figure>现在渲染的结果将是 `2`。]]></content>
    
    
    <categories>
      
      <category>vue基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模板语法</title>
    <link href="/vue%E5%9F%BA%E7%A1%80-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/"/>
    <url>/vue%E5%9F%BA%E7%A1%80-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><p>​Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。</p><p>​在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。</p><p>**文本插值:**双大括号标签会被替换为相应组件实例中 <code>msg</code> 属性的值。同时每次 <code>msg</code> 属性更改时它也会同步更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs VUE">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure><p>**原始 HTML:**双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 v-html 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs VUE">&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;<br>&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>​这里看到的 <code>v-html</code> attribute 被称为一个<strong>指令</strong>。将为渲染的 DOM 赋予特殊的响应式行为。在当前组件实例上，将此元素的 innerHTML 与 <code>rawHtml</code> 属性保持同步。</p><p>​<code>span</code> 的内容将会被替换为 <code>rawHtml</code> 属性的值，插值为纯 HTML——数据绑定将会被忽略。不能使用 <code>v-html</code> 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。</p><p>**Attribute 绑定:**双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 <a href="https://cn.vuejs.org/api/built-in-directives.html#v-bind"><code>v-bind</code> 指令</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;<br>&lt;!-- 因为 v-bind 非常常用，我们提供了特定的简写语法： --&gt;<br>&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;<br>&lt;!-- 如果attribute 的名称与绑定的JavaScript值的名称相同,那么可以进一步简化语法,省略 attribute 值：--&gt;<br>&lt;!-- 与 :id=&quot;id&quot; 相同 --&gt;<br>&lt;div :id&gt;&lt;/div&gt;<br>&lt;!-- 这也同样有效 --&gt;<br>&lt;div v-bind:id&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>​<code>v-bind</code> 指令指示 Vue 将元素的 <code>id</code> attribute 与组件的 <code>dynamicId</code> 属性保持一致。如果绑定的值是 <code>null</code> 或者 <code>undefined</code>，那么该 attribute 将会从渲染的元素上移除。</p><p><strong>使用 JavaScript 表达式</strong></p><p>​至此，我们仅在模板中绑定了一些简单的属性名。但是 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; number + 1 &#125;&#125;<br><br>&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;<br><br>&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<br><br>&lt;div :id=&quot;`list-$&#123;id&#125;`&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>​这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。</p><p>​在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：</p><ul><li>在文本插值中 (双大括号)</li><li>在任何 Vue 指令 (以 <code>v-</code> 开头的特殊 attribute) attribute 的值中</li></ul><p><strong>仅支持表达式</strong></p><p>​每个绑定仅支持<strong>单一表达式</strong>，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在 <code>return</code> 后面。</p><p>​因此，下面的例子都是<strong>无效</strong>的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs VUE">&lt;!-- 这是一个语句，而非表达式 --&gt;<br>&#123;&#123; var a = 1 &#125;&#125;<br><br>&lt;!-- 条件控制也不支持，请使用三元表达式 --&gt;<br>&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>调用函数</strong></p><p>可以在绑定的表达式中使用一个组件暴露的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;time :title=&quot;toTitleDate(date)&quot; :datetime=&quot;date&quot;&gt;<br>  &#123;&#123; formatDate(date) &#125;&#125;<br>&lt;/time&gt;<br></code></pre></td></tr></table></figure><p><strong>受限的全局访问</strong></p><p>​模板中的表达式将被沙盒化，仅能够访问到<a href="https://github.com/vuejs/core/blob/main/packages/shared/src/globalsAllowList.ts#L3">有限的全局对象列表</a>。该列表中会暴露常用的内置全局对象，比如 <code>Math</code> 和 <code>Date</code>。</p><p>​没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 <code>window</code> 上的属性。然而，你也可以自行在 <a href="https://cn.vuejs.org/api/application.html#app-config-globalproperties"><code>app.config.globalProperties</code></a> 上显式地添加它们，供所有的 Vue 表达式使用。</p><p><strong>指令 Directives</strong></p><p>​指令是带有 <code>v-</code> 前缀的特殊 attribute。Vue 提供了许多<a href="https://cn.vuejs.org/api/built-in-directives.html">内置指令</a>，包括上面我们所介绍的 <code>v-bind</code> 和 <code>v-html</code>。</p><p>​指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 <code>v-for</code>、<code>v-on</code> 和 <code>v-slot</code>)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 <a href="https://cn.vuejs.org/api/built-in-directives.html#v-if"><code>v-if</code></a> 为例：</p><p><strong>参数 Arguments</strong></p><p>​某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 <code>v-bind</code> 指令来响应式地更新一个 HTML attribute：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a :href=&quot;url&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure><p>​这里 <code>href</code> 就是一个参数，它告诉 <code>v-bind</code> 指令将表达式 <code>url</code> 的值绑定到元素的 <code>href</code> attribute 上。在简写中，参数前的一切 (例如 <code>v-bind:</code>) 都会被缩略为一个 <code>:</code> 字符。</p><p>​另一个例子是 <code>v-on</code> 指令，它将监听 DOM 事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure><p>​这里的参数是要监听的事件名称：<code>click</code>。<code>v-on</code> 有一个相应的缩写，即 <code>@</code> 字符。</p><p><strong>动态参数</strong></p><p>​同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--<br>注意，参数表达式有一些约束，<br>参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释<br>--&gt;<br>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure><p>​这里的 <code>attributeName</code> 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果组件实例有一个数据属性 <code>attributeName</code>，其值为 <code>&quot;href&quot;</code>，那么这个绑定就等价于 <code>v-bind:href</code>。</p><p>​相似地，还可以将一个函数绑定到动态的事件名称上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a @[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure><p>​在此示例中，当 <code>eventName</code> 的值是 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 就等价于 <code>v-on:focus</code>。</p><h4 id="动态参数值的限制"><a href="#动态参数值的限制" class="headerlink" title="动态参数值的限制"></a>动态参数值的限制</h4><p>动态参数中表达式的值应当是一个字符串，或者是 <code>null</code>。特殊值 <code>null</code> 意为显式移除该绑定。其他非字符串的值会触发警告。</p><h4 id="动态参数语法的限制"><a href="#动态参数语法的限制" class="headerlink" title="动态参数语法的限制"></a>动态参数语法的限制</h4><p>​动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 这会触发一个编译器警告 --&gt;<br>&lt;a :[&#x27;foo&#x27; + bar]=&quot;value&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure><p>​如果你需要传入一个复杂的动态参数，我们推荐使用<a href="https://cn.vuejs.org/guide/essentials/computed.html">计算属性</a>替换复杂的表达式，也是 Vue 最基础的概念之一，我们很快就会讲到。</p><p>​当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a :[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure><p>​上面的例子将会在 DOM 内嵌模板中被转换为 <code>:[someattr]</code>。如果你的组件拥有 “someAttr” 属性而非 “someattr”，这段代码将不会工作。单文件组件内的模板<strong>不</strong>受此限制。</p><p><strong>修饰符 Modifiers</strong></p><p>​修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 <code>.prevent</code> 修饰符会告知 <code>v-on</code> 指令对触发的事件调用 <code>event.preventDefault()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3生命周期</title>
    <link href="/vue%E5%9F%BA%E7%A1%80-vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/vue%E5%9F%BA%E7%A1%80-vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/vue-vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20241224160412939-17350274743921.png" alt="image-20241224160412939"></p><h1 id="选项式API中的生命周期"><a href="#选项式API中的生命周期" class="headerlink" title="选项式API中的生命周期"></a>选项式API中的生命周期</h1><p>vue3的生命周期主要分为：</p><ol><li>创建阶段（Created）</li><li>挂载阶段（Mounted）</li><li>更新阶段（Updated）</li><li>销毁阶段（Destoryed）</li></ol><p><strong>在每个阶段，vue3都会触发一些生命周期钩子，允许我们在不同时间点执行特定的逻辑</strong></p><p><strong>创建阶段：</strong></p><p><strong>beforeCreate</strong></p><ul><li><p>在vue实例被初始化之后，数据观测和事件配置之前调用</p></li><li><p>此时，数据和事件尚未设置</p></li><li><p>一般不常用，通常用于调试或者需要手动设置某些操作时使用</p></li><li><pre><code class="vue">beforeCreate()&#123;    console.log(&quot;beforeCreate: Vue 实例尚未初始化，数据和事件未设置&quot;);&#125;<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**created**</span><br><br><span class="hljs-bullet">- </span>在实例创建后立即调用，数据观测、属性和方法的初始化已经完成，事件和侦听器也设置完毕<br><br><span class="hljs-bullet">- </span>但此时DOM还未挂载，$el属性还无法访问<br><br><span class="hljs-bullet">- </span><span class="hljs-code">```vue</span><br><span class="hljs-code">  beforeMount() &#123;</span><br><span class="hljs-code">    console.log(&quot;beforeMount: 组件模板已编译，挂载即将开始&quot;);</span><br><span class="hljs-code">  &#125;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p><strong>挂载阶段</strong></p><p><strong>beforeMount</strong></p><ul><li><p>在挂载开始前调用，此时模板已经编译，vue实例和dom元素都已存在，但dom尚未更新</p></li><li><p>在这个钩子中无法访问到最终的渲染内容</p></li><li><pre><code class="vue">beforeMount() &#123;  console.log(&quot;beforeMount: 组件模板已编译，挂载即将开始&quot;);&#125;<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**mounted**</span><br><br><span class="hljs-bullet">- </span>在挂载完成后调用，此时vue实例已经被挂载到真实的dom上，并且可以访问到dom<br><br><span class="hljs-bullet">- </span>常用于初始化dom相关操作，比如第三方插件的初始化等等<br><br><span class="hljs-bullet">- </span><span class="hljs-code">```vue</span><br><span class="hljs-code">  mounted() &#123;</span><br><span class="hljs-code">    console.log(&quot;mounted: 组件已挂载到 DOM 上，可以访问到 DOM&quot;);</span><br><span class="hljs-code">  &#125;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p><strong>更新阶段</strong></p><p><strong>beforeUpdate</strong></p><ul><li><p>在数据更新前调用，当数据发生变化时，dom尚未更新，但响应式数据已经被更新</p></li><li><p>可用于在数据更强前进行某些操作，例如保存旧值或执行其他逻辑</p></li><li><pre><code class="vue">beforeUpdate() &#123;  console.log(&quot;beforeUpdate: 数据更新前，DOM 尚未更新&quot;);&#125;<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**updated**</span><br><br><span class="hljs-bullet">- </span>在数据更新后调用，dom也会随之更新<br><br><span class="hljs-bullet">- </span>在这个钩子中，可以执行dom操作或进行组件更新后的处理工作<br><br><span class="hljs-bullet">- </span><span class="hljs-code">```vue</span><br><span class="hljs-code">  updated() &#123;</span><br><span class="hljs-code">    console.log(&quot;updated: 数据更新后，DOM 已经更新&quot;);</span><br><span class="hljs-code">  &#125;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p><strong>卸载阶段</strong></p><p><strong>beforeUnmount</strong></p><ul><li><p>在组件销毁之前调用</p></li><li><p>可用于清理定时器，事件监听器等</p></li><li><pre><code class="vue">beforeUnmount() &#123;  console.log(&quot;beforeUnmount: 组件销毁前，可以执行清理工作&quot;);&#125;<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**unmounted**</span><br><br><span class="hljs-bullet">- </span>组件销毁后调用<br><br><span class="hljs-bullet">- </span>此时所有与该组件相关的事件监听和子组件都已销毁<br><br><span class="hljs-bullet">- </span><span class="hljs-code">```vue</span><br><span class="hljs-code">  unmounted() &#123;</span><br><span class="hljs-code">    console.log(&quot;unmounted: 组件销毁后，所有事件和子组件已销毁&quot;);</span><br><span class="hljs-code">  &#125;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h1 id="组合式API中的生命周期"><a href="#组合式API中的生命周期" class="headerlink" title="组合式API中的生命周期"></a>组合式API中的生命周期</h1><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted &#125; from &#x27;vue&#x27;;<br><br>// beforeMount 和 mounted<br>onBeforeMount(() =&gt; &#123;<br>  console.log(&quot;onBeforeMount: 组件挂载前&quot;);<br>&#125;);<br>onMounted(() =&gt; &#123;<br>  console.log(&quot;onMounted: 组件已挂载&quot;);<br>&#125;);<br><br>// beforeUpdate 和 updated<br>onBeforeUpdate(() =&gt; &#123;<br>  console.log(&quot;onBeforeUpdate: 数据更新前&quot;);<br>&#125;);<br>onUpdated(() =&gt; &#123;<br>  console.log(&quot;onUpdated: 数据更新后&quot;);<br>&#125;);<br><br>// beforeUnmount 和 unmounted<br>onBeforeUnmount(() =&gt; &#123;<br>  console.log(&quot;onBeforeUnmount: 组件销毁前&quot;);<br>&#125;);<br>onUnmounted(() =&gt; &#123;<br>  console.log(&quot;onUnmounted: 组件销毁后&quot;);<br>&#125;);<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装教程-Linux</title>
    <link href="/%E5%85%B6%E4%BB%96-Docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-Linux/"/>
    <url>/%E5%85%B6%E4%BB%96-Docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-Linux/</url>
    
    <content type="html"><![CDATA[<p>确保自己的yum是最新：sudo yum update</p><p><strong>1.卸载旧版本</strong>：如果你从未安装过则不用执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum remove docker \<br>                 docker-client \<br>                 docker-client-latest \<br>                 docker-common \<br>                 docker-latest \<br>                 docker-latest-logrotate \<br>                 docker-logrotate \<br>                 docker-engine<br></code></pre></td></tr></table></figure><p><strong>2.配置Docker的yum库</strong></p><p>首先安装yum工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y yum-utils \<br>           device-mapper-persistent-data \<br>           lvm2 --skip-broken<br></code></pre></td></tr></table></figure><p>安装成功后执行命令配置Docker的yum源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum-config-manager \<br>    --add-repo \<br>    https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><p><strong>3.安装Docker</strong></p><p>执行命令安装docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br></code></pre></td></tr></table></figure><p><strong>4.启动和校验docker</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动</span><br><span class="hljs-built_in">sudo</span> systemctl start docker<br><span class="hljs-comment"># 停止</span><br><span class="hljs-built_in">sudo</span> systemctl stop docker<br><span class="hljs-comment">#重启</span><br><span class="hljs-built_in">sudo</span> systemctl restart docker<br><span class="hljs-comment">#设置开机自启动</span><br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> docker<br><span class="hljs-comment">#执行docker ps命令，不报错则说明安装启动成功</span><br>docker ps<br></code></pre></td></tr></table></figure><p><strong>5.配置镜像加速器</strong>：以阿里云为例</p><ol><li>访问官网<a href="https://www.aliyun.com/">https://www.aliyun.com/</a>  注册账户</li><li>找到容器镜像服务<img src="/../img/Docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-Linux/image-20240801195441887.png" alt="image-20240801195441887"></li><li>点击管理控制台<img src="/../img/Docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-Linux/image-20240801195614707.png" alt="image-20240801195614707"></li><li>选择镜像工具找到镜像加速器<img src="/../img/Docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-Linux/image-20240801195746401.png" alt="image-20240801195746401"></li><li>参考文档命令配置<img src="/../img/Docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-Linux/image-20240801195946566.png" alt="image-20240801195946566"></li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GC垃圾回收</title>
    <link href="/java%E5%9F%BA%E7%A1%80-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/java%E5%9F%BA%E7%A1%80-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h1><p><strong>想要实现垃圾自动回收，我们需要考虑三件事：</strong></p><p><img src="/../img/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20240801123908708.png" alt="image-20240801123908708"></p><p><strong>GC的作用区域：方法区和堆</strong></p><p>JVM在进行GC时并不是对以下三个区统一回收，大部分时候都是回收新生区：</p><ul><li>新生区</li><li>幸存区</li><li>老年区</li></ul><p><strong>GC两种种类：轻GC（普通GC，一般是清理新生区，偶尔清理幸存区）和重GC（全局GC）</strong></p><p><strong>引用计数法（JVM一般不采用这种方式）</strong></p><p><img src="/../img/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20240801124535478.png" alt="image-20240801124535478"></p><p><strong>复制算法</strong></p><ul><li>每次GC都会将Eden中活的对象移到幸存区中，一旦Eden区被GC后，就会是空的</li><li>幸存区中的from和to区中，谁是空的谁为to区</li><li>当一个对象经历15次GC没死，可以进入老年区</li></ul><p><strong>复制算法的好处是没有内存的碎片，坏处是浪费了内存空间：多了一半空间永远是空的</strong><br><strong>复制算法最佳使用场景：对象存活度较低；也就是新生区</strong></p><p><strong>标记清除算法</strong></p><p><img src="/../img/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20240801130446501.png" alt="image-20240801130446501"></p><ul><li>优点：不需要额外的空间</li><li>缺点：两次扫描，严重浪费时间，会产生内存碎片</li></ul><p><strong>标记整理（标记压缩）</strong></p><p>上述再优化：先标记清除几次，再进行压缩</p><p><img src="/../img/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20240801130941518.png" alt="image-20240801130941518"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>内存效率：复制算法&gt;标记清除算法&gt;标记压缩算法（时间复杂度）</li><li>内存整齐度：复制算法&#x3D;标记压缩算法&gt;标记清除算法</li><li>内存利用率：标记压缩算法&#x3D;标记清除算法&gt;复制算法</li></ul><p><strong>没有最好的算法，只有最合适的算法—&gt;GC：分代收集算法</strong></p><p>年轻代：</p><ul><li>存活率低</li><li>复制算法</li></ul><p>老年代：</p><ul><li>存活率高，区域大</li><li>标记清除（内存碎片不是太多）+标记压缩混合实现</li></ul><p><strong>JVM调优就是选择合适的内存设置以及垃圾收集器GC的选择</strong></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM基本概念</title>
    <link href="/java%E5%9F%BA%E7%A1%80-JVM%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/java%E5%9F%BA%E7%A1%80-JVM%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Java虚拟机（JVM）简介"><a href="#Java虚拟机（JVM）简介" class="headerlink" title="Java虚拟机（JVM）简介"></a>Java虚拟机（JVM）简介</h1><p>Java虚拟机（Java Virtual Machine，简称JVM）是Java程序能够在各种不同平台上运行的关键。JVM的核心职责是将Java字节码翻译成机器码并执行。本文将深入浅出地介绍JVM的基本架构和工作原理。</p><h2 id="JVM的架构"><a href="#JVM的架构" class="headerlink" title="JVM的架构"></a>JVM的架构</h2><p>JVM主要由以下几个部分组成：</p><h3 id="1-类加载子系统"><a href="#1-类加载子系统" class="headerlink" title="1. 类加载子系统"></a>1. 类加载子系统</h3><p>类加载子系统负责加载Java类文件，将其转换为内存中的类对象。这一过程包括以下几个步骤：</p><ul><li><strong>加载</strong>：查找和加载类的二进制数据。</li><li><strong>连接</strong>：验证、准备和解析类的二进制数据。</li><li><strong>初始化</strong>：初始化类的静态变量和静态代码块。</li></ul><h3 id="2-运行时数据区"><a href="#2-运行时数据区" class="headerlink" title="2. 运行时数据区"></a>2. 运行时数据区</h3><p>运行时数据区是JVM运行Java程序时的内存模型，主要包括：</p><ul><li><strong>堆（Heap）</strong>：存储对象实例和数组，是垃圾回收的主要区域。</li><li><strong>栈（Stack）</strong>：存储方法调用和局部变量，每个线程都有自己的栈。</li><li><strong>方法区（Method Area）</strong>：存储已被JVM加载的类、常量、静态变量等。</li><li><strong>程序计数器（Program Counter Register）</strong>：每个线程都有一个程序计数器，指示下一条将要执行的字节码指令。</li><li><strong>本地方法栈（Native Method Stack）</strong>：为本地方法（如通过JNI调用的C&#x2F;C++代码）服务。</li></ul><h3 id="3-执行引擎"><a href="#3-执行引擎" class="headerlink" title="3. 执行引擎"></a>3. 执行引擎</h3><p>执行引擎是JVM的核心组件，负责执行字节码指令。它包含以下几个部分：</p><ul><li><strong>解释器</strong>：逐条解释执行字节码指令。</li><li><strong>即时编译器（JIT Compiler）</strong>：将字节码编译为机器码，提高执行速度。</li><li><strong>垃圾回收器</strong>：管理堆内存，自动回收不再使用的对象。</li></ul><h2 id="JVM的垃圾回收机制"><a href="#JVM的垃圾回收机制" class="headerlink" title="JVM的垃圾回收机制"></a>JVM的垃圾回收机制</h2><p>垃圾回收（Garbage Collection，简称GC）是JVM的一项重要功能，它自动管理堆内存，回收不再使用的对象。常见的垃圾回收算法包括：</p><ul><li><strong>标记-清除算法（Mark-and-Sweep）</strong>：标记活跃对象，然后清除未标记的对象。</li><li><strong>标记-压缩算法（Mark-and-Compact）</strong>：标记对象后，压缩存活对象到堆的一端，避免碎片化。</li><li><strong>分代收集算法</strong>：将堆分为新生代和老年代，根据对象的存活时间优化回收。</li></ul><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>JVM调优是提高Java应用性能的重要手段。常见的调优手段包括：</p><ul><li><p>内存设置</p><ul><li>堆内存大小：通过‘-Xms’和‘-Xmx’设置最小和最大堆内存大小。通常这两者设为相同大小</li><li>新生代和老年代大小：使用‘-xx:NewRatio’设置新生代和老年代比例。新生代应该足够大，以容纳所有短期对象，减少对象提升到老年代的频率</li></ul></li><li><p>垃圾收集器GC选择：不同垃圾选择器适用不同场景。如G1适合有较大堆内存且需要较短GC暂停时间的应用，Parallel GC适合需要高吞吐量的应用，CMS适合需要低延迟的应用</p></li></ul><p>以上是对JVM的基本介绍。理解JVM的工作原理有助于编写高效的Java程序，并在遇到性能问题时能够迅速定位和解决。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java对象在内存中的实例化过程</title>
    <link href="/java%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <url>/java%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="java对象在内存中实例化的过程"><a href="#java对象在内存中实例化的过程" class="headerlink" title="java对象在内存中实例化的过程"></a>java对象在内存中实例化的过程</h1><p>​在Java类的实例化过程中，内存会使用到三个区域：<strong>栈区、堆区、方法区</strong></p><ul><li>堆区：存储的全部都是对象，每个对象包含了一个与之对应的class类的信息。jvm只有一个堆区（steap），它会被所有线程共享，堆中不存放基本数据类型和对象引用，他只存放对象本身</li><li>栈区：每个线程都包含一个栈区，栈中只保存基本数据类型的值和对象以及基础数据的引用。每个栈中的数据都是私有的，其他栈无法访问</li><li>方法区：又被称为静态区，跟堆一样被所有线程共享，方法区包含所有class信息和static修饰的变量。方法区中包含的都是整个程序中永远唯一的元素，如class，static变量等</li></ul><p><strong>类实例化时内存中发生的变化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    String name; <span class="hljs-comment">// 定义一个成员变量 name</span><br>    <span class="hljs-type">int</span> age; <span class="hljs-comment">// 成员变量 age</span><br>    Double height; <span class="hljs-comment">// 成员变量 height</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;人的姓名：&quot;</span>+name);<br>        System.out.println(<span class="hljs-string">&quot;人的年龄：&quot;</span>+age);<br>        System.out.println(<span class="hljs-string">&quot;人的身高：&quot;</span>+height);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String name; <span class="hljs-comment">// 定义一个局部变量 name</span><br>    <span class="hljs-type">int</span> age; <span class="hljs-comment">// 局部变量 age</span><br>    Double height; <span class="hljs-comment">// 局部变量 height</span><br>        <br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>() ; <span class="hljs-comment">//实例化对象people</span><br>        people.name = <span class="hljs-string">&quot;张三&quot;</span> ;       <span class="hljs-comment">//赋值</span><br>        people.age = <span class="hljs-number">18</span>;             <span class="hljs-comment">//赋值</span><br>        people.stuid = <span class="hljs-number">180.0</span> ;   <span class="hljs-comment">//赋值</span><br>        people.sing();              <span class="hljs-comment">//调用方法sing</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>代码解析</strong>：首先定义了三个成员变量，但是都只声明，没有初始化，然后定义了一个成员方法。在main方法中定义了三个局部变量，然后实例化对象people，内存中在堆区会给实例化对象people分配一片地址，然后我们堆people进行赋值，people调用成员方法，main打印输出，系统执行完毕。下面我用图解法展示实例化过程中内存的变化：</p><p><img src="/../img/java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/image-20240801093850304.png" alt="image-20240801093850304"></p><p>首先类中的成员变量和方法体会进入到方法区，如图：</p><p><img src="/../img/java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/image-20240801094224361.png" alt="image-20240801094224361"></p><p>程序执行main方法时，main()函数会方法体会进入栈区，这一过程叫压栈，定义了一个用于指向Person实例的变量person。如图：</p><p><img src="/../img/java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/image-20240801094507538.png" alt="image-20240801094507538"></p><p>程序执行到Person person &#x3D; new Person()时就会在堆中开辟一块空间用来存放Person对象实例，然后将成员变量和成员方法放在new实例中，里面都是取成员变量或成员方法的地址值。如图：</p><p><img src="/../img/java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/image-20240801095300609.png" alt="image-20240801095300609"></p><p>接下来堆person对象进行赋值。如图：</p><p><img src="/../img/java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/image-20240801101009168.png" alt="image-20240801101009168"></p><p>当程序走到sing()方法时，先到栈区找到person这个引用变量，然后根据该地址值这种堆内存中找到new Person()进行方法调用。在方法体void sing()被调用完成后，就立马从栈内弹出。</p><p><img src="/../img/java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/image-20240801101521000.png" alt="image-20240801101521000"></p><p>以上就是Java对象在内存中实例化的全过程。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
