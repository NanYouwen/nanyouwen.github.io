<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>&lt;keep-alive&gt;的原理和使用场景</title>
    <link href="/vue-keep-alive%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/vue-keep-alive%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><keep-alive>是Vue的内置组件，用于对动态组件进行缓存，核心原理是通过缓存组件实例，避免不必要的销毁和重新创建,从而优化性能。</p><p><strong>1.关键机制:</strong></p><ul><li>缓存机制<ul><li>keep-alive对象内部维护了一个缓存对象（cache）,用于存储已经被渲染过的组件实例</li><li>当组件被换成时，其mounted钩子只会执行一次，而切换回来时只会触发activated钩子</li><li>被移除的组件不会销毁，而是保存在内存中</li></ul></li><li>匹配规则<ul><li>通过include和exclude属性控制需要缓存或者不需要缓存的组件</li><li>使用正则表达式、字符串或数组来匹配组件名</li></ul></li><li>生命周期钩子<ul><li>配合activated和deactivated钩子处理业务逻辑</li><li>activated：当组件从缓存中激活时触发</li><li>deactivated：当组件被缓存而不是销毁时触发</li></ul></li></ul><p>2.工作流程</p><ul><li>渲染时，keep-alive检查组件名是否需要缓存</li><li>如果需要：缓存实例，直接从缓存中读取，避免重复创建实例</li><li>如果不需要：销毁该组件，正常执行生命周期</li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p><strong>keep-alive通常用于需要频繁切换的组件场景，避免重复加载和渲染，从而提升性能</strong><br><strong>1.典型场景</strong></p><ul><li>多页签切换：例如后台管理系统中，多个tab页面之间的频繁切换，使用keep-alive可以避免每次切换时重新加载数据</li><li>表单场景：当填写表单后切换到其他组件再切回来时表单内容保持不变</li><li>性能优化：对数据量较大的组件，例如长列表或复杂图表组件进行缓存，减少渲染开销</li></ul><p><strong>2.注意事项</strong></p><ul><li>缓存大小：如果换成组件过多，可能导致内存占用过高</li><li>动态条件：include和exclude需要合理配置，避免缓存无用组件</li><li>生命周期管理:配合activated和deactivated管理组件状态，比如清理定时器、停止动画等</li></ul><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&#x27;HelloWorld&#x27;&gt;<br>    &lt;div class=&quot;nav-buttons&quot;&gt;<br>      &lt;button @click=&quot;currentView = &#x27;ViewA&#x27;&quot;&gt;视图A&lt;/button&gt;<br>      &lt;button @click=&quot;currentView = &#x27;ViewB&#x27;&quot;&gt;视图B&lt;/button&gt;<br>    &lt;/div&gt;<br><br>    &lt;keep-alive&gt;<br>      &lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;<br>    &lt;/keep-alive&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&#x27;ts&#x27;&gt;<br>import &#123; ref, defineComponent, h, computed &#125; from &#x27;vue&#x27;<br><br>// 定义两个示例组件<br>const ViewA = defineComponent(&#123;<br>  name: &#x27;ViewA&#x27;,<br>  setup() &#123;<br>    const count = ref(0)<br>    return () =&gt; h(&#x27;div&#x27;, &#123; class: &#x27;view&#x27; &#125;, [<br>      h(&#x27;h2&#x27;, &#x27;View A&#x27;),<br>      h(&#x27;p&#x27;, `计数器: $&#123;count.value&#125;`),<br>      h(&#x27;button&#x27;, &#123; onClick: () =&gt; count.value++ &#125;, &#x27;增加&#x27;)<br>    ])<br>  &#125;<br>&#125;)<br><br>const ViewB = defineComponent(&#123;<br>  name: &#x27;ViewB&#x27;,<br>  setup() &#123;<br>    const message = ref(&#x27;&#x27;)<br>    return () =&gt; h(&#x27;div&#x27;, &#123; class: &#x27;view&#x27; &#125;, [<br>      h(&#x27;h2&#x27;, &#x27;View B&#x27;),<br>      h(&#x27;input&#x27;, &#123;<br>        value: message.value,<br>        onInput: (e: Event) =&gt; &#123;<br>          message.value = (e.target as HTMLInputElement).value<br>        &#125;<br>      &#125;),<br>      h(&#x27;p&#x27;, `输入的内容: $&#123;message.value&#125;`)<br>    ])<br>  &#125;<br>&#125;)<br><br>// 当前视图<br>const currentView = ref&lt;&#x27;ViewA&#x27; | &#x27;ViewB&#x27;&gt;(&#x27;ViewA&#x27;)<br><br>// 视图映射<br>const views = &#123;<br>  ViewA,<br>  ViewB<br>&#125;<br><br>const currentComponent = computed(() =&gt; &#123;<br>  return views[currentView.value]<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.HelloWorld &#123;<br>  padding: 20px;<br>  max-width: 500px;<br>  margin: 0 auto;<br>&#125;<br><br>.nav-buttons &#123;<br>  margin-bottom: 20px;<br>  display: flex;<br>  gap: 10px;<br>  justify-content: center;<br>&#125;<br><br>button &#123;<br>  padding: 8px 16px;<br>  background-color: #4CAF50;<br>  color: white;<br>  border: none;<br>  border-radius: 4px;<br>  cursor: pointer;<br>&#125;<br><br>button:hover &#123;<br>  background-color: #45a049;<br>&#125;<br><br>.view &#123;<br>  padding: 20px;<br>  border: 1px solid #ddd;<br>  border-radius: 8px;<br>  margin-top: 20px;<br>&#125;<br><br>input &#123;<br>  padding: 8px;<br>  margin: 10px 0;<br>  width: 100%;<br>  border: 1px solid #ddd;<br>  border-radius: 4px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>条件渲染</title>
    <link href="/vue-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
    <url>/vue-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><p><code>v-for</code></p><p>​我们可以使用 <code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令的值需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据的数组，而 <code>item</code> 是迭代项的<strong>别名</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> items = <span class="hljs-title function_">ref</span>([&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;, &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125;])<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;item in items&quot;&gt;<br>  &#123;&#123; item.message &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>在 <code>v-for</code> 块中可以完整地访问父作用域内的属性和变量。<code>v-for</code> 也支持使用可选的第二个参数表示当前项的位置索引。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> parentMessage = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Parent&#x27;</span>)<br><span class="hljs-keyword">const</span> items = <span class="hljs-title function_">ref</span>([&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;, &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125;])<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;(item, index) in items&quot;&gt;<br>  &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNpdTsuqwjAQ/ZVDNlFQu5d64bpwJ7g3LopOJdAmIRlFCPl3p60PcDWcM+eV1X8Iq/uN1FrV6RxtYCTiW/gzzvbBR0ZGpBYFbfQ9tEi1ccadvUuM0ERyvKeUmithMyhn+jCSev4WWaY+vZ7HjH5Sr6F33muUhTR8uW0ThTuJua6mPbJEgGSErmEaENedxX3Z+rgxajbEL2DdhR5zOVOdUSIEDOf8M7IULCHsaPgiMa1eK4QcS6rOSkhdfapVeQLQEWnH">在演练场中尝试一下</a></p><p><code>v-for</code> 变量的作用域和下面的 JavaScript 代码很类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> parentMessage = <span class="hljs-string">&#x27;Parent&#x27;</span><br><span class="hljs-keyword">const</span> items = [<br>  <span class="hljs-comment">/* ... */</span><br>]<br><br>items.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 可以访问外层的 `parentMessage`</span><br>  <span class="hljs-comment">// 而 `item` 和 `index` 只在这个作用域可用</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parentMessage, item.<span class="hljs-property">message</span>, index)<br>&#125;)<br></code></pre></td></tr></table></figure><p>​注意 <code>v-for</code> 是如何对应 <code>forEach</code> 回调的函数签名的。实际上，你也可以在定义 <code>v-for</code> 的变量别名时使用解构，和解构函数参数类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;&#123; message &#125; in items&quot;&gt;<br>  &#123;&#123; message &#125;&#125;<br>&lt;/li&gt;<br><br>&lt;!-- 有 index 索引时 --&gt;<br>&lt;li v-for=&quot;(&#123; message &#125;, index) in items&quot;&gt;<br>  &#123;&#123; message &#125;&#125; &#123;&#123; index &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>对于多层嵌套的 <code>v-for</code>，作用域的工作方式和函数的作用域很类似。每个 <code>v-for</code> 作用域都可以访问到父级作用域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;item in items&quot;&gt;<br>  &lt;span v-for=&quot;childItem in item.children&quot;&gt;<br>    &#123;&#123; item.message &#125;&#125; &#123;&#123; childItem &#125;&#125;<br>  &lt;/span&gt;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>你也可以使用 <code>of</code> 作为分隔符来替代 <code>in</code>，这更接近 JavaScript 的迭代器语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><h2 id="v-for-与对象"><a href="#v-for-与对象" class="headerlink" title="v-for 与对象"></a><code>v-for</code> 与对象</h2><p>​你也可以使用 <code>v-for</code> 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 <code>Object.values()</code> 的返回值来决定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myObject = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;How to do lists in Vue&#x27;</span>,<br>  <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Jane Doe&#x27;</span>,<br>  <span class="hljs-attr">publishedAt</span>: <span class="hljs-string">&#x27;2016-04-10&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;ul&gt;<br>  &lt;li v-for=&quot;value in myObject&quot;&gt;<br>    &#123;&#123; value &#125;&#125;<br>  &lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>可以通过提供第二个参数表示属性名 (例如 key)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;(value, key) in myObject&quot;&gt;<br>  &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>第三个参数表示位置索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt;<br>  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNo9jjFvgzAQhf/KE0sSCQKpqg7IqRSpQ9WlWycvBC6KW2NbcKaNEP+9B7Tx4nt33917Y3IKYT9ESspE9XVnAqMnjuFZO9MG3zFGdFTVbAbChEvnW2yE32inXe1dz2hv7+dPqhnHO7kdtQPYsKUSm1f/DfZoPKzpuYdx+JAL6cxUka++E+itcoQX/9cO8SzslZoTy+yhODxlxWN2KMR22mmn8jWrpBTB1AZbMc2KVbTyQ56yBkN28d1RJ9uhspFSfNEtFf+GfnZzjP/oOll2NQPjuM4xTftZyIaU5VwuN0SsqMqtWZxUvliq/J4jmX4BTCp08A==">在演练场中尝试一下</a></p><h2 id="在-v-for-里使用范围值"><a href="#在-v-for-里使用范围值" class="headerlink" title="在 v-for 里使用范围值"></a>在 <code>v-for</code> 里使用范围值</h2><p><code>v-for</code> 可以直接接受一个整数值。在这种用例中，会将该模板基于 <code>1...n</code> 的取值范围重复多次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure><p>注意此处 <code>n</code> 的初值是从 <code>1</code> 开始而非 <code>0</code>。</p><h2 id="上的-v-for"><a href="#上的-v-for" class="headerlink" title="&lt;template&gt; 上的 v-for"></a><code>&lt;template&gt;</code> 上的 <code>v-for</code></h2><p>与模板上的 <code>v-if</code> 类似，你也可以在 <code>&lt;template&gt;</code> 标签上使用 <code>v-for</code> 来渲染一个包含多个元素的块。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;ul&gt;<br>  &lt;template v-for=&quot;item in items&quot;&gt;<br>    &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;<br>    &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt;<br>  &lt;/template&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><h2 id="v-for-与-v-if"><a href="#v-for-与-v-if" class="headerlink" title="v-for 与 v-if"></a><code>v-for</code> 与 <code>v-if</code></h2><p>​同时使用 <code>v-if</code> 和 <code>v-for</code> 是<strong>不推荐的</strong>，因为这样二者的优先级不明显。请转阅<a href="https://cn.vuejs.org/style-guide/rules-essential.html#avoid-v-if-with-v-for">风格指南</a>查看更多细节。</p><p>​当它们同时存在于一个节点上时，<code>v-if</code> 比 <code>v-for</code> 的优先级更高。这意味着 <code>v-if</code> 的条件将无法访问到 <code>v-for</code> 作用域内定义的变量别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!--<br> 这会抛出一个错误，因为属性 todo 此时<br> 没有在该实例上定义<br>--&gt;<br>&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;<br>  &#123;&#123; todo.name &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>在外先包装一层 <code>&lt;template&gt;</code> 再在其上使用 <code>v-for</code> 可以解决这个问题 (这也更加明显易读)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;template v-for=&quot;todo in todos&quot;&gt;<br>  &lt;li v-if=&quot;!todo.isComplete&quot;&gt;<br>    &#123;&#123; todo.name &#125;&#125;<br>  &lt;/li&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h2 id="通过-key-管理状态"><a href="#通过-key-管理状态" class="headerlink" title="通过 key 管理状态"></a>通过 key 管理状态</h2><p>​Vue 默认按照“就地更新”的策略来更新通过 <code>v-for</code> 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。</p><p>​默认模式是高效的，但<strong>只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况</strong>。</p><p>​为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 <code>key</code> attribute：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;<br>  &lt;!-- 内容 --&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>当你使用 <code>&lt;template v-for&gt;</code> 时，<code>key</code> 应该被放置在这个 <code>&lt;template&gt;</code> 容器上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;template v-for=&quot;todo in todos&quot; :key=&quot;todo.name&quot;&gt;<br>  &lt;li&gt;&#123;&#123; todo.name &#125;&#125;&lt;/li&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>注意</p><p>​<code>key</code> 在这里是一个通过 <code>v-bind</code> 绑定的特殊 attribute。请不要和<a href="https://cn.vuejs.org/guide/essentials/list.html#v-for-with-an-object">在 <code>v-for</code> 中使用对象</a>里所提到的对象属性名相混淆。</p><p>​<a href="https://cn.vuejs.org/style-guide/rules-essential.html#use-keyed-v-for">推荐</a>在任何可行的时候为 <code>v-for</code> 提供一个 <code>key</code> attribute，除非所迭代的 DOM 内容非常简单 (例如：不包含组件或有状态的 DOM 元素)，或者你想有意采用默认行为来提高性能。</p><p><code>key</code> 绑定的值期望是一个基础类型的值，例如字符串或 number 类型。不要用对象作为 <code>v-for</code> 的 key。关于 <code>key</code> attribute 的更多用途细节，请参阅 <a href="https://cn.vuejs.org/api/built-in-special-attributes.html#key"><code>key</code> API 文档</a>。</p><h2 id="组件上使用-v-for"><a href="#组件上使用-v-for" class="headerlink" title="组件上使用 v-for"></a>组件上使用 <code>v-for</code></h2><p>我们可以直接在组件上使用 <code>v-for</code>，和在一般的元素上使用没有区别 (别忘记提供一个 <code>key</code>)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent v-for=&quot;item in items&quot; :key=&quot;item.id&quot; /&gt;<br></code></pre></td></tr></table></figure><p>​但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还需要传递 props：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent<br>  v-for=&quot;(item, index) in items&quot;<br>  :item=&quot;item&quot;<br>  :index=&quot;index&quot;<br>  :key=&quot;item.id&quot;<br>/&gt;<br></code></pre></td></tr></table></figure><p>​不自动将 <code>item</code> 注入组件的原因是，这会使组件与 <code>v-for</code> 的工作方式紧密耦合。明确其数据的来源可以使组件在其他情况下重用。</p><p>​这里是一个简单的 <a href="https://play.vuejs.org/#eNp1U8Fu2zAM/RXCGGAHTWx02ylwgxZYB+ywYRhyq3dwLGYRYkuCJTsZjPz7KMmK3ay9JBQfH/meKA/Rk1Jp32G0jnJdtVwZ0Gg6tSkEb5RsDQzQ4h4usG9lAzGVxldoK5n8ZrAZsTQLCduRygAKUUmhDQg8WWyLZwMPtmESx4sAGkL0mH6xrMH+AHC2hvuljw03Na4h/iLBHBAY1wfUbsTFVcwoH28o2/KIIDuaQ0TTlvrwNu/TDe+7PDlKXZ6EZxTiN4kuRI3W0dk4u4yUf7bZfScqw6WAkrEf3m+y8AOcw7Qv6w5T1elDMhs7Nbq7e61gdmme60SQAvgfIhExiSSJeeb3SBukAy1D1aVBezL5XrYN9Csp1rrbNdykqsUehXkookl0EVGxlZHX5Q5rIBLhNHFlbRD6xBiUzlOeuZJQz4XqjI+BxjSSYe2pQWwRBZizV01DmsRWeJA1Qzv0Of2TwldE5hZRlVd+FkbuOmOksJLybIwtkmfWqg+7qz47asXpSiaN3lxikSVwwfC8oD+/sEnV+oh/qcxmU85mebepgLjDBD622Mg+oDrVquYVJm7IEu4XoXKTZ1dho3gnmdJhedEymn9ab3ysDPdc4M9WKp28xE5JbB+rzz/Trm3eK3LAu8/E7p2PNzYM/i3ChR7W7L7hsSIvR7L2Aal1EhqTp80vF95sw3WcG7r8A0XaeME=">Todo List 的例子</a>，展示了如何通过 <code>v-for</code> 来渲染一个组件列表，并向每个实例中传入不同的数据。</p><h2 id="数组变化侦测"><a href="#数组变化侦测" class="headerlink" title="数组变化侦测"></a>数组变化侦测</h2><h3 id="变更方法"><a href="#变更方法" class="headerlink" title="变更方法"></a>变更方法</h3><p>Vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括：</p><ul><li><code>push()</code></li><li><code>pop()</code></li><li><code>shift()</code></li><li><code>unshift()</code></li><li><code>splice()</code></li><li><code>sort()</code></li><li><code>reverse()</code></li></ul><h3 id="替换一个数组"><a href="#替换一个数组" class="headerlink" title="替换一个数组"></a>替换一个数组</h3><p>​变更方法，顾名思义，就是会对调用它们的原数组进行变更。相对地，也有一些不可变 (immutable) 方法，例如 <code>filter()</code>，<code>concat()</code> 和 <code>slice()</code>，这些都不会更改原数组，而总是<strong>返回一个新数组</strong>。当遇到的是非变更方法时，我们需要将旧的数组替换为新的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// `items` 是一个数组的 ref</span><br>items.<span class="hljs-property">value</span> = items.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">message</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/Foo/</span>))<br></code></pre></td></tr></table></figure><p>​你可能认为这将导致 Vue 丢弃现有的 DOM 并重新渲染整个列表——幸运的是，情况并非如此。Vue 实现了一些巧妙的方法来最大化对 DOM 元素的重用，因此用另一个包含部分重叠对象的数组来做替换，仍会是一种非常高效的操作。</p><h2 id="展示过滤或排序后的结果"><a href="#展示过滤或排序后的结果" class="headerlink" title="展示过滤或排序后的结果"></a>展示过滤或排序后的结果</h2><p>​有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性。</p><p>举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = <span class="hljs-title function_">ref</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-keyword">const</span> evenNumbers = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> numbers.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>在计算属性不可行的情况下 (例如在多层嵌套的 <code>v-for</code> 循环中)，你可以使用以下方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sets = <span class="hljs-title function_">ref</span>([<br>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],<br>  [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br>])<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">even</span>(<span class="hljs-params">numbers</span>) &#123;<br>  <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;ul v-for=&quot;numbers in sets&quot;&gt;<br>  &lt;li v-for=&quot;n in even(numbers)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>​在计算属性中使用 <code>reverse()</code> 和 <code>sort()</code> 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- return numbers.reverse()</span><br><span class="hljs-addition">+ return [...numbers].reverse()</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>条件渲染</title>
    <link href="/vue-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"/>
    <url>/vue-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><code>v-if</code></h2><p>​<code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回真值时才被渲染。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;<br></code></pre></td></tr></table></figure><h2 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a><code>v-else</code></h2><p>​你也可以使用 <code>v-else</code> 为 <code>v-if</code> 添加一个“else 区块”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;button @click=&quot;awesome = !awesome&quot;&gt;Toggle&lt;/button&gt;<br><br>&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;<br>&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNpFjkEOgjAQRa8ydIMulLA1hegJ3LnqBskAjdA27RQXhHu4M/GEHsEiKLv5mfdf/sBOxux7j+zAuCutNAQOyZtcKNkZbQkGsFjBCJXVHcQBjYUSqtTKERR3dLpDyCZmQ9bjViiezKKgCIGwM21BGBIAv3oireBYtrK8ZYKtgmg5BctJ13WLPJnhr0YQb1Lod7JaS4G8eATpfjMinjTphC8wtg7zcwNKw/v5eC1fnvwnsfEDwaha7w==">在演练场中尝试一下</a></p><p>一个 <code>v-else</code> 元素必须跟在一个 <code>v-if</code> 或者 <code>v-else-if</code> 元素后面，否则它将不会被识别。</p><h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a><code>v-else-if</code></h2><p>顾名思义，<code>v-else-if</code> 提供的是相应于 <code>v-if</code> 的“else if 区块”。它可以连续多次重复使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;<br>  A<br>&lt;/div&gt;<br>&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;<br>  B<br>&lt;/div&gt;<br>&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;<br>  C<br>&lt;/div&gt;<br>&lt;div v-else&gt;<br>  Not A/B/C<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>和 <code>v-else</code> 类似，一个使用 <code>v-else-if</code> 的元素必须紧跟在一个 <code>v-if</code> 或一个 <code>v-else-if</code> 元素后面。</p><h2 id="上的-v-if"><a href="#上的-v-if" class="headerlink" title="&lt;template&gt; 上的 v-if"></a><code>&lt;template&gt;</code> 上的 <code>v-if</code></h2><p>​因为 <code>v-if</code> 是一个指令，他必须依附于某个元素。但如果我们想要切换不止一个元素呢？在这种情况下我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-if</code>，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 <code>&lt;template&gt;</code> 元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;template v-if=&quot;ok&quot;&gt;<br>  &lt;h1&gt;Title&lt;/h1&gt;<br>  &lt;p&gt;Paragraph 1&lt;/p&gt;<br>  &lt;p&gt;Paragraph 2&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><code>v-else</code> 和 <code>v-else-if</code> 也可以在 <code>&lt;template&gt;</code> 上使用。</p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><code>v-show</code></h2><p>另一个可以用来按条件显示一个元素的指令是 <code>v-show</code>。其用法基本一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p>不同之处在于 <code>v-show</code> 会在 DOM 渲染中保留该元素；<code>v-show</code> 仅切换了该元素上名为 <code>display</code> 的 CSS 属性。</p><p><code>v-show</code> 不支持在 <code>&lt;template&gt;</code> 元素上使用，也不能和 <code>v-else</code> 搭配使用。</p><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs. v-show"></a><code>v-if</code> vs. <code>v-show</code></h2><ol><li><code>v-if</code> 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。</li><li><code>v-if</code> 也是<strong>惰性</strong>的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。</li><li>相比之下，<code>v-show</code> 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS <code>display</code> 属性会被切换。</li><li>总的来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 <code>v-show</code> 较好；如果在运行时绑定条件很少改变，则 <code>v-if</code> 会更合适。</li></ol><h2 id="v-if-和-v-for"><a href="#v-if-和-v-for" class="headerlink" title="v-if 和 v-for"></a><code>v-if</code> 和 <code>v-for</code></h2><ul><li>同时使用 <code>v-if</code> 和 <code>v-for</code> 是<strong>不推荐的</strong>，因为这样二者的优先级不明显。请查看<a href="https://cn.vuejs.org/style-guide/rules-essential.html#avoid-v-if-with-v-for">风格指南</a>获得更多信息。</li><li>当 <code>v-if</code> 和 <code>v-for</code> 同时存在于一个元素上的时候，<code>v-if</code> 会首先被执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>类与样式绑定</title>
    <link href="/vue-%E7%B1%BB%E4%B8%8E%E6%A0%B7%E5%BC%8F%E7%BB%91%E5%AE%9A/"/>
    <url>/vue-%E7%B1%BB%E4%B8%8E%E6%A0%B7%E5%BC%8F%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h1><p>​数据绑定的一个常见需求场景是操纵元素的 CSS class 列表和内联样式。因为 <code>class</code> 和 <code>style</code> 都是 attribute，我们可以和其他 attribute 一样使用 <code>v-bind</code> 将它们和动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易出错的。因此，Vue 专门为 <code>class</code> 和 <code>style</code> 的 <code>v-bind</code> 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。</p><h2 id="绑定-HTML-class"><a href="#绑定-HTML-class" class="headerlink" title="绑定 HTML class"></a>绑定 HTML class</h2><h3 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h3><p>​我们可以给 <code>:class</code> (<code>v-bind:class</code> 的缩写) 传递一个对象来动态切换 class：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>​上面的语法表示 <code>active</code> 是否存在取决于数据属性 <code>isActive</code> 的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">真假值</a>。</p><p>​你可以在对象中写多个字段来操作多个 class。此外，<code>:class</code> 指令也可以和一般的 <code>class</code> attribute 共存。举例来说，下面这样的状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> isActive = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">const</span> hasError = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><p>配合以下模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div<br>  class=&quot;static&quot;<br>  :class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;<br>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>渲染的结果会是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>​当 <code>isActive</code> 或者 <code>hasError</code> 改变时，class 列表会随之更新。举例来说，如果 <code>hasError</code> 变为 <code>true</code>，class 列表也会变成 <code>&quot;static active text-danger&quot;</code>。</p><p>​绑定的对象并不一定需要写成内联字面量的形式，也可以直接绑定一个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> classObject = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&#x27;text-danger&#x27;</span>: <span class="hljs-literal">false</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这将渲染：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div class=&quot;active&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>我们也可以绑定一个返回对象的<a href="https://cn.vuejs.org/guide/essentials/computed.html">计算属性</a>。这是一个常见且很有用的技巧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> isActive = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">const</span> error = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br><br><span class="hljs-keyword">const</span> classObject = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> (&#123;<br>  <span class="hljs-attr">active</span>: isActive.<span class="hljs-property">value</span> &amp;&amp; !error.<span class="hljs-property">value</span>,<br>  <span class="hljs-string">&#x27;text-danger&#x27;</span>: error.<span class="hljs-property">value</span> &amp;&amp; error.<span class="hljs-property">value</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;fatal&#x27;</span><br>&#125;))<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><h3 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h3><p>我们可以给 <code>:class</code> 绑定一个数组来渲染多个 CSS class：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> activeClass = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br><span class="hljs-keyword">const</span> errorClass = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;text-danger&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>渲染的结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>如果你也想在数组中有条件地渲染某个 class，你可以使用三元表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><code>errorClass</code> 会一直存在，但 <code>activeClass</code> 只会在 <code>isActive</code> 为真时才存在。</p><p>然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;[&#123; [activeClass]: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><h3 id="在组件上使用"><a href="#在组件上使用" class="headerlink" title="在组件上使用"></a>在组件上使用</h3><blockquote><p>本节假设你已经有 <a href="https://cn.vuejs.org/guide/essentials/component-basics.html">Vue 组件</a>的知识基础。如果没有，你也可以暂时跳过，以后再阅读。</p></blockquote><p>​对于只有一个根元素的组件，当你使用了 <code>class</code> attribute 时，这些 class 会被添加到根元素上并与该元素上已有的 class 合并。</p><p>举例来说，如果你声明了一个组件名叫 <code>MyComponent</code>，模板如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 子组件模板 --&gt;<br>&lt;p class=&quot;foo bar&quot;&gt;Hi!&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>在使用时添加一些 class：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 在使用组件时 --&gt;<br>&lt;MyComponent class=&quot;baz boo&quot; /&gt;<br></code></pre></td></tr></table></figure><p>渲染出的 HTML 为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi!&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>Class 的绑定也是同样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent :class=&quot;&#123; active: isActive &#125;&quot; /&gt;<br></code></pre></td></tr></table></figure><p>当 <code>isActive</code> 为真时，被渲染的 HTML 会是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p class=&quot;foo bar active&quot;&gt;Hi!&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>​如果你的组件有多个根元素，你将需要指定哪个根元素来接收这个 class。你可以通过组件的 <code>$attrs</code> 属性来指定接收的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- MyComponent 模板使用 $attrs 时 --&gt;<br>&lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;<br>&lt;span&gt;This is a child component&lt;/span&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent class=&quot;baz&quot; /&gt;<br></code></pre></td></tr></table></figure><p>这将被渲染为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;baz&quot;</span>&gt;</span>Hi!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>This is a child component<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>你可以在<a href="https://cn.vuejs.org/guide/components/attrs.html">透传 Attribute</a> 一章中了解更多组件的 attribute 继承的细节。</p><h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h2><h3 id="绑定对象-1"><a href="#绑定对象-1" class="headerlink" title="绑定对象"></a>绑定对象</h3><p><code>:style</code> 支持绑定 JavaScript 对象值，对应的是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style">HTML 元素的 <code>style</code> 属性</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> activeColor = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;red&#x27;</span>)<br><span class="hljs-keyword">const</span> fontSize = <span class="hljs-title function_">ref</span>(<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>尽管推荐使用 camelCase，但 <code>:style</code> 也支持 kebab-cased 形式的 CSS 属性 key (对应其 CSS 中的实际名称)，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;&#123; &#x27;font-size&#x27;: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>直接绑定一个样式对象通常是一个好主意，这样可以使模板更加简洁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> styleObject = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;30px&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>同样的，如果样式对象需要更复杂的逻辑，也可以使用返回样式对象的计算属性。</p><h3 id="绑定数组-1"><a href="#绑定数组-1" class="headerlink" title="绑定数组"></a>绑定数组</h3><p>我们还可以给 <code>:style</code> 绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><h3 id="自动前缀"><a href="#自动前缀" class="headerlink" title="自动前缀"></a>自动前缀</h3><p>​当你在 <code>:style</code> 中使用了需要<a href="https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix">浏览器特殊前缀</a>的 CSS 属性时，Vue 会自动为他们加上相应的前缀。Vue 是在运行时检查该属性是否支持在当前浏览器中使用。如果浏览器不支持某个属性，那么将尝试加上各个浏览器特殊前缀，以找到哪一个是被支持的。</p><h3 id="样式多值"><a href="#样式多值" class="headerlink" title="样式多值"></a>样式多值</h3><p>你可以对一个样式属性提供多个 (不同前缀的) 值，举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要特别前缀的浏览器中都会渲染为 <code>display: flex</code>。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算属性</title>
    <link href="/vue-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <url>/vue-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><h2 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h2><p>​模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> author = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John Doe&#x27;</span>,<br>  <span class="hljs-attr">books</span>: [<br>    <span class="hljs-string">&#x27;Vue 2 - Advanced Guide&#x27;</span>,<br>    <span class="hljs-string">&#x27;Vue 3 - Basic Guide&#x27;</span>,<br>    <span class="hljs-string">&#x27;Vue 4 - The Mystery&#x27;</span><br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>​我们想根据 <code>author</code> 是否已有一些书籍来展示不同的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p&gt;Has published books:&lt;/p&gt;<br>&lt;span&gt;&#123;&#123; author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure><p>​这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于 <code>author.books</code>。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。</p><p>​因此我们推荐使用<strong>计算属性</strong>来描述依赖响应式状态的复杂逻辑。这是重构后的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; reactive, computed &#125; from &#x27;vue&#x27;<br><br>const author = reactive(&#123;<br>  name: &#x27;John Doe&#x27;,<br>  books: [<br>    &#x27;Vue 2 - Advanced Guide&#x27;,<br>    &#x27;Vue 3 - Basic Guide&#x27;,<br>    &#x27;Vue 4 - The Mystery&#x27;<br>  ]<br>&#125;)<br><br>// 一个计算属性 ref<br>const publishedBooksMessage = computed(() =&gt; &#123;<br>  return author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27;<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;p&gt;Has published books:&lt;/p&gt;<br>  &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNp1kE9Lw0AQxb/KI5dtoTainkoaaREUoZ5EEONhm0ybYLO77J9CCfnuzta0vdjbzr6Zeb95XbIwZroPlMySzJW2MR6OfDB5oZrWaOvRwZIsfbOnCUrdmuCpQo+N1S0ET4pCFarUynnI4GttMT9PjLpCAUq2NIN41bXCkyYxiZ9rrX/cDF/xDYiPQLjDDRbVXqqSHZ5DUw2tg3zP8lK6pvxHe2DtvSasDs6TPTAT8F2ofhzh0hTygm5pc+I1Yb1rXE3VMsKsyDm5JcY/9Y5GY8xzHI+wnIpVw4nTI/10R2rra+S4xSPEJzkBvvNNs310ztK/RDlLLjy1Zic9cQVkJn+R7gIwxJGlMXiWnZEq77orhH3Pq2NH9DjvTfpfSBSbmA==">在演练场中尝试一下</a></p><p>​我们在这里定义了一个计算属性 <code>publishedBooksMessage</code>。<code>computed()</code> 方法期望接收一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description">getter 函数</a>，返回值为一个<strong>计算属性 ref</strong>。和其他一般的 ref 类似，你可以通过 <code>publishedBooksMessage.value</code> 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 <code>.value</code>。</p><p>​Vue 的计算属性会自动追踪响应式依赖。它会检测到 <code>publishedBooksMessage</code> 依赖于 <code>author.books</code>，所以当 <code>author.books</code> 改变时，任何依赖于 <code>publishedBooksMessage</code> 的绑定都会同时更新。</p><h2 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h2><p>​你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p&gt;&#123;&#123; calculateBooksMessage() &#125;&#125;&lt;/p&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 组件中</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateBooksMessage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> author.<span class="hljs-property">books</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;Yes&#x27;</span> : <span class="hljs-string">&#x27;No&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于<strong>计算属性值会基于其响应式依赖被缓存</strong>。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 <code>author.books</code> 不改变，无论多少次访问 <code>publishedBooksMessage</code> 都会立即返回先前的计算结果，而不用重复执行 getter 函数。</p><p>​这也解释了为什么下面的计算属性永远不会更新，因为 <code>Date.now()</code> 并不是一个响应式依赖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> now = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>())<br></code></pre></td></tr></table></figure><p>​相比之下，方法调用<strong>总是</strong>会在重渲染发生时再次执行函数。</p><p>​为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 <code>list</code>，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 <code>list</code>。没有缓存的话，我们会重复执行非常多次 <code>list</code> 的 getter，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。</p><h2 id="可写计算属性"><a href="#可写计算属性" class="headerlink" title="可写计算属性"></a>可写计算属性</h2><p>​计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, computed &#125; from &#x27;vue&#x27;<br><br>const firstName = ref(&#x27;John&#x27;)<br>const lastName = ref(&#x27;Doe&#x27;)<br><br>const fullName = computed(&#123;<br>  // getter<br>  get() &#123;<br>    return firstName.value + &#x27; &#x27; + lastName.value<br>  &#125;,<br>  // setter<br>  set(newValue) &#123;<br>    // 注意：我们这里使用的是解构赋值语法<br>    [firstName.value, lastName.value] = newValue.split(&#x27; &#x27;)<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​现在当你再运行 <code>fullName.value = &#39;John Doe&#39;</code> 时，setter 会被调用而 <code>firstName</code> 和 <code>lastName</code> 会随之更新。</p><h3 id="Getter-不应有副作用"><a href="#Getter-不应有副作用" class="headerlink" title="Getter 不应有副作用"></a>Getter 不应有副作用</h3><p>​计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，<strong>不要改变其他状态、在 getter 中做异步请求或者更改 DOM</strong>！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用<a href="https://cn.vuejs.org/guide/essentials/watchers.html">侦听器</a>根据其他响应式状态的变更来创建副作用。</p><h3 id="避免直接修改计算属性值"><a href="#避免直接修改计算属性值" class="headerlink" title="避免直接修改计算属性值"></a>避免直接修改计算属性值</h3><p>​从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>响应式基础</title>
    <link href="/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    <url>/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h1><h2 id="声明响应式状态"><a href="#声明响应式状态" class="headerlink" title="声明响应式状态"></a>声明响应式状态</h2><h3 id="ref"><a href="#ref" class="headerlink" title="ref()"></a><code>ref()</code></h3><p>在组合式 API 中，推荐使用 <a href="https://cn.vuejs.org/api/reactivity-core.html#ref"><code>ref()</code></a> 函数来声明响应式状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const count = ref(0)<br></code></pre></td></tr></table></figure><p><code>ref()</code> 接收参数，并将其包裹在一个带有 <code>.value</code> 属性的 ref 对象中返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">const count = ref(0)<br><br>console.log(count) // &#123; value: 0 &#125;<br>console.log(count.value) // 0<br><br>count.value++<br>console.log(count.value) // 1<br></code></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://cn.vuejs.org/guide/typescript/composition-api.html#typing-ref">为 refs 标注类型</a> </p></blockquote><p>要在组件模板中访问 ref，请从组件的 <code>setup()</code> 函数中声明并返回它们：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; ref &#125; from &#x27;vue&#x27;<br><br>export default &#123;<br>  // `setup` 是一个特殊的钩子，专门用于组合式 API。<br>  setup() &#123;<br>    const count = ref(0)<br><br>    // 将 ref 暴露给模板<br>    return &#123;<br>      count<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>​注意，在模板中使用 ref 时，我们<strong>不</strong>需要附加 <code>.value</code>。为了方便起见，当在模板中使用时，ref 会自动解包。也可以直接在事件监听器中改变一个 ref：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click=&quot;count++&quot;&gt;<br>  &#123;&#123; count &#125;&#125;<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>对于更复杂的逻辑，我们可以在同一作用域内声明更改 ref 的函数，并将它们作为方法与状态一起公开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; ref &#125; from &#x27;vue&#x27;<br><br>export default &#123;<br>  setup() &#123;<br>    const count = ref(0)<br><br>    function increment() &#123;<br>      // 在 JavaScript 中需要 .value<br>      count.value++<br>    &#125;<br><br>    // 不要忘记同时暴露 increment 函数<br>    return &#123;<br>      count,<br>      increment<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，暴露的方法可以被用作事件监听器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click=&quot;increment&quot;&gt;<br>  &#123;&#123; count &#125;&#125;<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>这里是 <a href="https://codepen.io/vuejs-examples/pen/WNYbaqo">Codepen</a> 上的例子，没有使用任何构建工具。</p><h3 id=""><a href="#" class="headerlink" title="&lt;script setup&gt;"></a><code>&lt;script setup&gt;</code></h3><p>在 <code>setup()</code> 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用<a href="https://cn.vuejs.org/guide/scaling-up/sfc.html">单文件组件 (SFC)</a> 来避免这种情况。我们可以使用 <code>&lt;script setup&gt;</code> 来大幅度地简化代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const count = ref(0)<br><br>function increment() &#123;<br>  count.value++<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;<br>    &#123;&#123; count &#125;&#125;<br>  &lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><a href="https://play.vuejs.org/#eNo9jUEKgzAQRa8yZKMiaNcllvYe2dgwQqiZhDhxE3L3jrW4/DPvv1/UK8Zhz6juSm82uciwIef4MOR8DImhQMIFKiwpeGgEbQwZsoE2BhsyMUwH0d66475ksuwCgSOb0CNx20ExBCc77POase8NVUN6PBdlSwKjj+vMKAlAvzOzWJ52dfYzGXXpjPoBAKX856uopDGeFfnq8XKp+gWq4FAi">在演练场中尝试一下</a></p><script setup> 中的顶层的导入、声明的变量和函数可在同一组件的模板中直接使用。你可以理解为模板是在同一作用域内声明的一个 JavaScript 函数——它自然可以访问与它一起声明的所有内容。### 为什么要使用 ref简单地讨论一下 Vue 的响应式系统是如何工作的。​当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue 会**追踪**在渲染过程中使用的每一个 ref。然后，当一个 ref 被修改时，它会**触发**追踪它的组件的一次重新渲染。​在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。​该 `.value` 属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。从概念上讲，你可以将 ref 看作是一个像这样的对象：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 伪代码，不是真正的实现<br>const myRef = &#123;<br>  _value: 0,<br>  get value() &#123;<br>    track()<br>    return this._value<br>  &#125;,<br>  set value(newValue) &#123;<br>    this._value = newValue<br>    trigger()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>​另一个 ref 的好处是，与普通变量不同，你可以将 ref 传递给函数，同时保留对最新值和响应式连接的访问。当将复杂的逻辑重构为可重用的代码时，这将非常有用。该响应性系统在[深入响应式原理](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html)章节中有更详细的讨论。### 深层响应性​Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构，比如 `Map`。​Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const obj = ref(&#123;<br>  nested: &#123; count: 0 &#125;,<br>  arr: [&#x27;foo&#x27;, &#x27;bar&#x27;]<br>&#125;)<br><br>function mutateDeeply() &#123;<br>  // 以下都会按照期望工作<br>  obj.value.nested.count++<br>  obj.value.arr.push(&#x27;baz&#x27;)<br>&#125;<br></code></pre></td></tr></table></figure>非原始值将通过 [`reactive()`](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#reactive) 转换为响应式代理，该函数将在后面讨论。​也可以通过 [shallow ref](https://cn.vuejs.org/api/reactivity-advanced.html#shallowref) 来放弃深层响应性。对于浅层 ref，只有 `.value` 的访问会被追踪。浅层 ref 可以用于避免对大型数据的响应性开销来优化性能、或者有外部库管理其内部状态的情况。### DOM 更新时机​当你修改了响应式状态时，DOM 会被自动更新。但是需要注意的是，DOM 更新不是同步的。Vue 会在“next tick”更新周期中缓冲所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。​要等待 DOM 更新完成后再执行额外的代码，可以使用 [nextTick()](https://cn.vuejs.org/api/general.html#nexttick) 全局 API：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; nextTick &#125; from &#x27;vue&#x27;<br><br>async function increment() &#123;<br>  count.value++<br>  await nextTick()<br>  // 现在 DOM 已经更新了<br>&#125;<br></code></pre></td></tr></table></figure>## `reactive()`​还有另一种声明响应式状态的方式，即使用 `reactive()` API。与将内部值包装在特殊对象中的 ref 不同，`reactive()` 将使对象本身具有响应性：js<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; reactive &#125; from &#x27;vue&#x27;<br><br>const state = reactive(&#123; count: 0 &#125;)<br></code></pre></td></tr></table></figure>> 参考：[为 `reactive()` 标注类型](https://cn.vuejs.org/guide/typescript/composition-api.html#typing-reactive) 在模板中使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click=&quot;state.count++&quot;&gt;<br>  &#123;&#123; state.count &#125;&#125;<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure>​响应式对象是 [JavaScript 代理](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，其行为就和普通对象一样。不同的是，Vue 能够拦截对响应式对象所有属性的访问和修改，以便进行依赖追踪和触发更新。​`reactive()` 将深层地转换对象：当访问嵌套对象时，它们也会被 `reactive()` 包装。当 ref 的值是一个对象时，`ref()` 也会在内部调用它。与浅层 ref 类似，这里也有一个 [`shallowReactive()`](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive) API 可以选择退出深层响应性。### Reactive Proxy vs. Original值得注意的是，`reactive()` 返回的是一个原始对象的 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，它和原始对象是不相等的：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">const raw = &#123;&#125;<br>const proxy = reactive(raw)<br><br>// 代理对象和原始对象不是全等的<br>console.log(proxy === raw) // false<br></code></pre></td></tr></table></figure>​只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用 Vue 的响应式系统的最佳实践是**仅使用你声明对象的代理版本**。​为保证访问代理的一致性，对同一个原始对象调用 `reactive()` 会总是返回同样的代理对象，而对一个已存在的代理对象调用 `reactive()` 会返回其本身：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 在同一个对象上调用 reactive() 会返回相同的代理<br>console.log(reactive(raw) === proxy) // true<br><br>// 在一个代理上调用 reactive() 会返回它自己<br>console.log(reactive(proxy) === proxy) // true<br></code></pre></td></tr></table></figure>​这个规则对嵌套对象也适用。依靠深层响应性，响应式对象内的嵌套对象依然是代理：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">const proxy = reactive(&#123;&#125;)<br><br>const raw = &#123;&#125;<br>proxy.nested = raw<br><br>console.log(proxy.nested === raw) // false<br></code></pre></td></tr></table></figure>### `reactive()` 的局限性`reactive()` API 有一些局限性：1. **有限的值类型**：它只能用于对象类型 (对象、数组和如 `Map`、`Set` 这样的[集合类型](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#keyed_collections))。它不能持有如 `string`、`number` 或 `boolean` 这样的[原始类型](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)。2. **不能替换整个对象**：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">let state = reactive(&#123; count: 0 &#125;)<br><br>// 上面的 (&#123; count: 0 &#125;) 引用将不再被追踪<br>// (响应性连接已丢失！)<br>state = reactive(&#123; count: 1 &#125;)<br></code></pre></td></tr></table></figure>3. **对解构操作不友好**：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">const state = reactive(&#123; count: 0 &#125;)<br><br>// 当解构时，count 已经与 state.count 断开连接<br>let &#123; count &#125; = state<br>// 不会影响原始的 state<br>count++<br><br>// 该函数接收到的是一个普通的数字<br>// 并且无法追踪 state.count 的变化<br>// 我们必须传入整个对象以保持响应性<br>callSomeFunction(state.count)<br></code></pre></td></tr></table></figure>由于这些限制，我们建议使用 `ref()` 作为声明响应式状态的主要 API。一个 ref 会在作为响应式对象的属性被访问或修改时自动解包。换句话说，它的行为就像一个普通的属性：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">const count = ref(0)<br>const state = reactive(&#123;<br>  count<br>&#125;)<br><br>console.log(state.count) // 0<br><br>state.count = 1<br>console.log(count.value) // 1<br></code></pre></td></tr></table></figure>如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">const otherCount = ref(2)<br><br>state.count = otherCount<br>console.log(state.count) // 2<br>// 原始 ref 现在已经和 state.count 失去联系<br>console.log(count.value) // 1<br></code></pre></td></tr></table></figure>只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为[浅层响应式对象](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive)的属性被访问时不会解包。### 数组和集合的注意事项与 reactive 对象不同的是，当 ref 作为响应式数组或原生集合类型 (如 `Map`) 中的元素被访问时，它**不会**被解包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">const books = reactive([ref(&#x27;Vue 3 Guide&#x27;)])<br>// 这里需要 .value<br>console.log(books[0].value)<br><br>const map = reactive(new Map([[&#x27;count&#x27;, ref(0)]]))<br>// 这里需要 .value<br>console.log(map.get(&#x27;count&#x27;).value)<br></code></pre></td></tr></table></figure>### 在模板中解包的注意事项在模板渲染上下文中，只有顶级的 ref 属性才会被解包。在下面的例子中，`count` 和 `object` 是顶级属性，但 `object.id` 不是：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">const count = ref(0)<br>const object = &#123; id: ref(1) &#125;<br></code></pre></td></tr></table></figure>因此，这个表达式按预期工作：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; count + 1 &#125;&#125;<br></code></pre></td></tr></table></figure>...但这个**不会**：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; object.id + 1 &#125;&#125;<br></code></pre></td></tr></table></figure>​渲染的结果将是 `[object Object]1`，因为在计算表达式时 `object.id` 没有被解包，仍然是一个 ref 对象。为了解决这个问题，我们可以将 `id` 解构为一个顶级属性：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">const &#123; id &#125; = object<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; id + 1 &#125;&#125;<br></code></pre></td></tr></table></figure>现在渲染的结果将是 `2`。]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模板语法</title>
    <link href="/vue-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/"/>
    <url>/vue-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><p>​Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。</p><p>​在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。</p><p>**文本插值:**双大括号标签会被替换为相应组件实例中 <code>msg</code> 属性的值。同时每次 <code>msg</code> 属性更改时它也会同步更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs VUE">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure><p>**原始 HTML:**双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 v-html 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs VUE">&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;<br>&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>​这里看到的 <code>v-html</code> attribute 被称为一个<strong>指令</strong>。将为渲染的 DOM 赋予特殊的响应式行为。在当前组件实例上，将此元素的 innerHTML 与 <code>rawHtml</code> 属性保持同步。</p><p>​<code>span</code> 的内容将会被替换为 <code>rawHtml</code> 属性的值，插值为纯 HTML——数据绑定将会被忽略。不能使用 <code>v-html</code> 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。</p><p>**Attribute 绑定:**双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 <a href="https://cn.vuejs.org/api/built-in-directives.html#v-bind"><code>v-bind</code> 指令</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;<br>&lt;!-- 因为 v-bind 非常常用，我们提供了特定的简写语法： --&gt;<br>&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;<br>&lt;!-- 如果attribute 的名称与绑定的JavaScript值的名称相同,那么可以进一步简化语法,省略 attribute 值：--&gt;<br>&lt;!-- 与 :id=&quot;id&quot; 相同 --&gt;<br>&lt;div :id&gt;&lt;/div&gt;<br>&lt;!-- 这也同样有效 --&gt;<br>&lt;div v-bind:id&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>​<code>v-bind</code> 指令指示 Vue 将元素的 <code>id</code> attribute 与组件的 <code>dynamicId</code> 属性保持一致。如果绑定的值是 <code>null</code> 或者 <code>undefined</code>，那么该 attribute 将会从渲染的元素上移除。</p><p><strong>使用 JavaScript 表达式</strong></p><p>​至此，我们仅在模板中绑定了一些简单的属性名。但是 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; number + 1 &#125;&#125;<br><br>&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;<br><br>&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<br><br>&lt;div :id=&quot;`list-$&#123;id&#125;`&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>​这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。</p><p>​在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：</p><ul><li>在文本插值中 (双大括号)</li><li>在任何 Vue 指令 (以 <code>v-</code> 开头的特殊 attribute) attribute 的值中</li></ul><p><strong>仅支持表达式</strong></p><p>​每个绑定仅支持<strong>单一表达式</strong>，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在 <code>return</code> 后面。</p><p>​因此，下面的例子都是<strong>无效</strong>的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs VUE">&lt;!-- 这是一个语句，而非表达式 --&gt;<br>&#123;&#123; var a = 1 &#125;&#125;<br><br>&lt;!-- 条件控制也不支持，请使用三元表达式 --&gt;<br>&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>调用函数</strong></p><p>可以在绑定的表达式中使用一个组件暴露的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;time :title=&quot;toTitleDate(date)&quot; :datetime=&quot;date&quot;&gt;<br>  &#123;&#123; formatDate(date) &#125;&#125;<br>&lt;/time&gt;<br></code></pre></td></tr></table></figure><p><strong>受限的全局访问</strong></p><p>​模板中的表达式将被沙盒化，仅能够访问到<a href="https://github.com/vuejs/core/blob/main/packages/shared/src/globalsAllowList.ts#L3">有限的全局对象列表</a>。该列表中会暴露常用的内置全局对象，比如 <code>Math</code> 和 <code>Date</code>。</p><p>​没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 <code>window</code> 上的属性。然而，你也可以自行在 <a href="https://cn.vuejs.org/api/application.html#app-config-globalproperties"><code>app.config.globalProperties</code></a> 上显式地添加它们，供所有的 Vue 表达式使用。</p><p><strong>指令 Directives</strong></p><p>​指令是带有 <code>v-</code> 前缀的特殊 attribute。Vue 提供了许多<a href="https://cn.vuejs.org/api/built-in-directives.html">内置指令</a>，包括上面我们所介绍的 <code>v-bind</code> 和 <code>v-html</code>。</p><p>​指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 <code>v-for</code>、<code>v-on</code> 和 <code>v-slot</code>)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 <a href="https://cn.vuejs.org/api/built-in-directives.html#v-if"><code>v-if</code></a> 为例：</p><p><strong>参数 Arguments</strong></p><p>​某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 <code>v-bind</code> 指令来响应式地更新一个 HTML attribute：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a :href=&quot;url&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure><p>​这里 <code>href</code> 就是一个参数，它告诉 <code>v-bind</code> 指令将表达式 <code>url</code> 的值绑定到元素的 <code>href</code> attribute 上。在简写中，参数前的一切 (例如 <code>v-bind:</code>) 都会被缩略为一个 <code>:</code> 字符。</p><p>​另一个例子是 <code>v-on</code> 指令，它将监听 DOM 事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure><p>​这里的参数是要监听的事件名称：<code>click</code>。<code>v-on</code> 有一个相应的缩写，即 <code>@</code> 字符。</p><p><strong>动态参数</strong></p><p>​同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--<br>注意，参数表达式有一些约束，<br>参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释<br>--&gt;<br>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure><p>​这里的 <code>attributeName</code> 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果组件实例有一个数据属性 <code>attributeName</code>，其值为 <code>&quot;href&quot;</code>，那么这个绑定就等价于 <code>v-bind:href</code>。</p><p>​相似地，还可以将一个函数绑定到动态的事件名称上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a @[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure><p>​在此示例中，当 <code>eventName</code> 的值是 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 就等价于 <code>v-on:focus</code>。</p><h4 id="动态参数值的限制"><a href="#动态参数值的限制" class="headerlink" title="动态参数值的限制"></a>动态参数值的限制</h4><p>动态参数中表达式的值应当是一个字符串，或者是 <code>null</code>。特殊值 <code>null</code> 意为显式移除该绑定。其他非字符串的值会触发警告。</p><h4 id="动态参数语法的限制"><a href="#动态参数语法的限制" class="headerlink" title="动态参数语法的限制"></a>动态参数语法的限制</h4><p>​动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 这会触发一个编译器警告 --&gt;<br>&lt;a :[&#x27;foo&#x27; + bar]=&quot;value&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure><p>​如果你需要传入一个复杂的动态参数，我们推荐使用<a href="https://cn.vuejs.org/guide/essentials/computed.html">计算属性</a>替换复杂的表达式，也是 Vue 最基础的概念之一，我们很快就会讲到。</p><p>​当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a :[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure><p>​上面的例子将会在 DOM 内嵌模板中被转换为 <code>:[someattr]</code>。如果你的组件拥有 “someAttr” 属性而非 “someattr”，这段代码将不会工作。单文件组件内的模板<strong>不</strong>受此限制。</p><p><strong>修饰符 Modifiers</strong></p><p>​修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 <code>.prevent</code> 修饰符会告知 <code>v-on</code> 指令对触发的事件调用 <code>event.preventDefault()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/z%E6%A8%A1%E6%9D%BF/"/>
    <url>/z%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>·</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3生命周期</title>
    <link href="/vue-vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/vue-vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="选项式API中的生命周期"><a href="#选项式API中的生命周期" class="headerlink" title="选项式API中的生命周期"></a>选项式API中的生命周期</h1><p>vue3的生命周期主要分为：</p><ol><li>创建阶段（Created）</li><li>挂载阶段（Mounted）</li><li>更新阶段（Updated）</li><li>销毁阶段（Destoryed）</li></ol><p><strong>在每个阶段，vue3都会触发一些生命周期钩子，允许我们在不同时间点执行特定的逻辑</strong></p><p><strong>创建阶段：</strong></p><p><strong>beforeCreate</strong></p><ul><li><p>在vue实例被初始化之后，数据观测和事件配置之前调用</p></li><li><p>此时，数据和事件尚未设置</p></li><li><p>一般不常用，通常用于调试或者需要手动设置某些操作时使用</p></li><li><pre><code class="vue">beforeCreate()&#123;    console.log(&quot;beforeCreate: Vue 实例尚未初始化，数据和事件未设置&quot;);&#125;<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**created**</span><br><br><span class="hljs-bullet">- </span>在实例创建后立即调用，数据观测、属性和方法的初始化已经完成，事件和侦听器也设置完毕<br><br><span class="hljs-bullet">- </span>但此时DOM还未挂载，$el属性还无法访问<br><br><span class="hljs-bullet">- </span><span class="hljs-code">```vue</span><br><span class="hljs-code">  beforeMount() &#123;</span><br><span class="hljs-code">    console.log(&quot;beforeMount: 组件模板已编译，挂载即将开始&quot;);</span><br><span class="hljs-code">  &#125;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p><strong>挂载阶段</strong></p><p><strong>beforeMount</strong></p><ul><li><p>在挂载开始前调用，此时模板已经编译，vue实例和dom元素都已存在，但dom尚未更新</p></li><li><p>在这个钩子中无法访问到最终的渲染内容</p></li><li><pre><code class="vue">beforeMount() &#123;  console.log(&quot;beforeMount: 组件模板已编译，挂载即将开始&quot;);&#125;<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**mounted**</span><br><br><span class="hljs-bullet">- </span>在挂载完成后调用，此时vue实例已经被挂载到真实的dom上，并且可以访问到dom<br><br><span class="hljs-bullet">- </span>常用于初始化dom相关操作，比如第三方插件的初始化等等<br><br><span class="hljs-bullet">- </span><span class="hljs-code">```vue</span><br><span class="hljs-code">  mounted() &#123;</span><br><span class="hljs-code">    console.log(&quot;mounted: 组件已挂载到 DOM 上，可以访问到 DOM&quot;);</span><br><span class="hljs-code">  &#125;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p><strong>更新阶段</strong></p><p><strong>beforeUpdate</strong></p><ul><li><p>在数据更新前调用，当数据发生变化时，dom尚未更新，但响应式数据已经被更新</p></li><li><p>可用于在数据更强前进行某些操作，例如保存旧值或执行其他逻辑</p></li><li><pre><code class="vue">beforeUpdate() &#123;  console.log(&quot;beforeUpdate: 数据更新前，DOM 尚未更新&quot;);&#125;<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**updated**</span><br><br><span class="hljs-bullet">- </span>在数据更新后调用，dom也会随之更新<br><br><span class="hljs-bullet">- </span>在这个钩子中，可以执行dom操作或进行组件更新后的处理工作<br><br><span class="hljs-bullet">- </span><span class="hljs-code">```vue</span><br><span class="hljs-code">  updated() &#123;</span><br><span class="hljs-code">    console.log(&quot;updated: 数据更新后，DOM 已经更新&quot;);</span><br><span class="hljs-code">  &#125;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p><strong>卸载阶段</strong></p><p><strong>beforeUnmount</strong></p><ul><li><p>在组件销毁之前调用</p></li><li><p>可用于清理定时器，事件监听器等</p></li><li><pre><code class="vue">beforeUnmount() &#123;  console.log(&quot;beforeUnmount: 组件销毁前，可以执行清理工作&quot;);&#125;<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**unmounted**</span><br><br><span class="hljs-bullet">- </span>组件销毁后调用<br><br><span class="hljs-bullet">- </span>此时所有与该组件相关的事件监听和子组件都已销毁<br><br><span class="hljs-bullet">- </span><span class="hljs-code">```vue</span><br><span class="hljs-code">  unmounted() &#123;</span><br><span class="hljs-code">    console.log(&quot;unmounted: 组件销毁后，所有事件和子组件已销毁&quot;);</span><br><span class="hljs-code">  &#125;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h1 id="组合式API中的生命周期"><a href="#组合式API中的生命周期" class="headerlink" title="组合式API中的生命周期"></a>组合式API中的生命周期</h1><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted &#125; from &#x27;vue&#x27;;<br><br>// beforeMount 和 mounted<br>onBeforeMount(() =&gt; &#123;<br>  console.log(&quot;onBeforeMount: 组件挂载前&quot;);<br>&#125;);<br>onMounted(() =&gt; &#123;<br>  console.log(&quot;onMounted: 组件已挂载&quot;);<br>&#125;);<br><br>// beforeUpdate 和 updated<br>onBeforeUpdate(() =&gt; &#123;<br>  console.log(&quot;onBeforeUpdate: 数据更新前&quot;);<br>&#125;);<br>onUpdated(() =&gt; &#123;<br>  console.log(&quot;onUpdated: 数据更新后&quot;);<br>&#125;);<br><br>// beforeUnmount 和 unmounted<br>onBeforeUnmount(() =&gt; &#123;<br>  console.log(&quot;onBeforeUnmount: 组件销毁前&quot;);<br>&#125;);<br>onUnmounted(() =&gt; &#123;<br>  console.log(&quot;onUnmounted: 组件销毁后&quot;);<br>&#125;);<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装教程-Linux</title>
    <link href="/%E5%85%B6%E4%BB%96-Docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-Linux/"/>
    <url>/%E5%85%B6%E4%BB%96-Docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-Linux/</url>
    
    <content type="html"><![CDATA[<p>确保自己的yum是最新：sudo yum update</p><p><strong>1.卸载旧版本</strong>：如果你从未安装过则不用执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum remove docker \<br>                 docker-client \<br>                 docker-client-latest \<br>                 docker-common \<br>                 docker-latest \<br>                 docker-latest-logrotate \<br>                 docker-logrotate \<br>                 docker-engine<br></code></pre></td></tr></table></figure><p><strong>2.配置Docker的yum库</strong></p><p>首先安装yum工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y yum-utils \<br>           device-mapper-persistent-data \<br>           lvm2 --skip-broken<br></code></pre></td></tr></table></figure><p>安装成功后执行命令配置Docker的yum源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum-config-manager \<br>    --add-repo \<br>    https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><p><strong>3.安装Docker</strong></p><p>执行命令安装docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br></code></pre></td></tr></table></figure><p><strong>4.启动和校验docker</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动</span><br><span class="hljs-built_in">sudo</span> systemctl start docker<br><span class="hljs-comment"># 停止</span><br><span class="hljs-built_in">sudo</span> systemctl stop docker<br><span class="hljs-comment">#重启</span><br><span class="hljs-built_in">sudo</span> systemctl restart docker<br><span class="hljs-comment">#设置开机自启动</span><br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> docker<br><span class="hljs-comment">#执行docker ps命令，不报错则说明安装启动成功</span><br>docker ps<br></code></pre></td></tr></table></figure><p><strong>5.配置镜像加速器</strong>：以阿里云为例</p><ol><li>访问官网<a href="https://www.aliyun.com/">https://www.aliyun.com/</a>  注册账户</li><li>找到容器镜像服务<img src="/../img/Docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-Linux/image-20240801195441887.png" alt="image-20240801195441887"></li><li>点击管理控制台<img src="/../img/Docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-Linux/image-20240801195614707.png" alt="image-20240801195614707"></li><li>选择镜像工具找到镜像加速器<img src="/../img/Docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-Linux/image-20240801195746401.png" alt="image-20240801195746401"></li><li>参考文档命令配置<img src="/../img/Docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-Linux/image-20240801195946566.png" alt="image-20240801195946566"></li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GC垃圾回收</title>
    <link href="/java-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/java-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h1><p><strong>想要实现垃圾自动回收，我们需要考虑三件事：</strong></p><p><img src="/../img/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20240801123908708.png" alt="image-20240801123908708"></p><p><strong>GC的作用区域：方法区和堆</strong></p><p>JVM在进行GC时并不是对以下三个区统一回收，大部分时候都是回收新生区：</p><ul><li>新生区</li><li>幸存区</li><li>老年区</li></ul><p><strong>GC两种种类：轻GC（普通GC，一般是清理新生区，偶尔清理幸存区）和重GC（全局GC）</strong></p><p><strong>引用计数法（JVM一般不采用这种方式）</strong></p><p><img src="/../img/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20240801124535478.png" alt="image-20240801124535478"></p><p><strong>复制算法</strong></p><ul><li>每次GC都会将Eden中活的对象移到幸存区中，一旦Eden区被GC后，就会是空的</li><li>幸存区中的from和to区中，谁是空的谁为to区</li><li>当一个对象经历15次GC没死，可以进入老年区</li></ul><p><strong>复制算法的好处是没有内存的碎片，坏处是浪费了内存空间：多了一半空间永远是空的</strong><br><strong>复制算法最佳使用场景：对象存活度较低；也就是新生区</strong></p><p><strong>标记清除算法</strong></p><p><img src="/../img/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20240801130446501.png" alt="image-20240801130446501"></p><ul><li>优点：不需要额外的空间</li><li>缺点：两次扫描，严重浪费时间，会产生内存碎片</li></ul><p><strong>标记整理（标记压缩）</strong></p><p>上述再优化：先标记清除几次，再进行压缩</p><p><img src="/../img/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20240801130941518.png" alt="image-20240801130941518"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>内存效率：复制算法&gt;标记清除算法&gt;标记压缩算法（时间复杂度）</li><li>内存整齐度：复制算法&#x3D;标记压缩算法&gt;标记清除算法</li><li>内存利用率：标记压缩算法&#x3D;标记清除算法&gt;复制算法</li></ul><p><strong>没有最好的算法，只有最合适的算法—&gt;GC：分代收集算法</strong></p><p>年轻代：</p><ul><li>存活率低</li><li>复制算法</li></ul><p>老年代：</p><ul><li>存活率高，区域大</li><li>标记清除（内存碎片不是太多）+标记压缩混合实现</li></ul><p><strong>JVM调优就是选择合适的内存设置以及垃圾收集器GC的选择</strong></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM基本概念</title>
    <link href="/java-JVM%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/java-JVM%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Java虚拟机（JVM）简介"><a href="#Java虚拟机（JVM）简介" class="headerlink" title="Java虚拟机（JVM）简介"></a>Java虚拟机（JVM）简介</h1><p>Java虚拟机（Java Virtual Machine，简称JVM）是Java程序能够在各种不同平台上运行的关键。JVM的核心职责是将Java字节码翻译成机器码并执行。本文将深入浅出地介绍JVM的基本架构和工作原理。</p><h2 id="JVM的架构"><a href="#JVM的架构" class="headerlink" title="JVM的架构"></a>JVM的架构</h2><p>JVM主要由以下几个部分组成：</p><h3 id="1-类加载子系统"><a href="#1-类加载子系统" class="headerlink" title="1. 类加载子系统"></a>1. 类加载子系统</h3><p>类加载子系统负责加载Java类文件，将其转换为内存中的类对象。这一过程包括以下几个步骤：</p><ul><li><strong>加载</strong>：查找和加载类的二进制数据。</li><li><strong>连接</strong>：验证、准备和解析类的二进制数据。</li><li><strong>初始化</strong>：初始化类的静态变量和静态代码块。</li></ul><h3 id="2-运行时数据区"><a href="#2-运行时数据区" class="headerlink" title="2. 运行时数据区"></a>2. 运行时数据区</h3><p>运行时数据区是JVM运行Java程序时的内存模型，主要包括：</p><ul><li><strong>堆（Heap）</strong>：存储对象实例和数组，是垃圾回收的主要区域。</li><li><strong>栈（Stack）</strong>：存储方法调用和局部变量，每个线程都有自己的栈。</li><li><strong>方法区（Method Area）</strong>：存储已被JVM加载的类、常量、静态变量等。</li><li><strong>程序计数器（Program Counter Register）</strong>：每个线程都有一个程序计数器，指示下一条将要执行的字节码指令。</li><li><strong>本地方法栈（Native Method Stack）</strong>：为本地方法（如通过JNI调用的C&#x2F;C++代码）服务。</li></ul><h3 id="3-执行引擎"><a href="#3-执行引擎" class="headerlink" title="3. 执行引擎"></a>3. 执行引擎</h3><p>执行引擎是JVM的核心组件，负责执行字节码指令。它包含以下几个部分：</p><ul><li><strong>解释器</strong>：逐条解释执行字节码指令。</li><li><strong>即时编译器（JIT Compiler）</strong>：将字节码编译为机器码，提高执行速度。</li><li><strong>垃圾回收器</strong>：管理堆内存，自动回收不再使用的对象。</li></ul><h2 id="JVM的垃圾回收机制"><a href="#JVM的垃圾回收机制" class="headerlink" title="JVM的垃圾回收机制"></a>JVM的垃圾回收机制</h2><p>垃圾回收（Garbage Collection，简称GC）是JVM的一项重要功能，它自动管理堆内存，回收不再使用的对象。常见的垃圾回收算法包括：</p><ul><li><strong>标记-清除算法（Mark-and-Sweep）</strong>：标记活跃对象，然后清除未标记的对象。</li><li><strong>标记-压缩算法（Mark-and-Compact）</strong>：标记对象后，压缩存活对象到堆的一端，避免碎片化。</li><li><strong>分代收集算法</strong>：将堆分为新生代和老年代，根据对象的存活时间优化回收。</li></ul><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>JVM调优是提高Java应用性能的重要手段。常见的调优手段包括：</p><ul><li><p>内存设置</p><ul><li>堆内存大小：通过‘-Xms’和‘-Xmx’设置最小和最大堆内存大小。通常这两者设为相同大小</li><li>新生代和老年代大小：使用‘-xx:NewRatio’设置新生代和老年代比例。新生代应该足够大，以容纳所有短期对象，减少对象提升到老年代的频率</li></ul></li><li><p>垃圾收集器GC选择：不同垃圾选择器适用不同场景。如G1适合有较大堆内存且需要较短GC暂停时间的应用，Parallel GC适合需要高吞吐量的应用，CMS适合需要低延迟的应用</p></li></ul><p>以上是对JVM的基本介绍。理解JVM的工作原理有助于编写高效的Java程序，并在遇到性能问题时能够迅速定位和解决。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java对象在内存中的实例化过程</title>
    <link href="/java-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <url>/java-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="java对象在内存中实例化的过程"><a href="#java对象在内存中实例化的过程" class="headerlink" title="java对象在内存中实例化的过程"></a>java对象在内存中实例化的过程</h1><p>​在Java类的实例化过程中，内存会使用到三个区域：<strong>栈区、堆区、方法区</strong></p><ul><li>堆区：存储的全部都是对象，每个对象包含了一个与之对应的class类的信息。jvm只有一个堆区（steap），它会被所有线程共享，堆中不存放基本数据类型和对象引用，他只存放对象本身</li><li>栈区：每个线程都包含一个栈区，栈中只保存基本数据类型的值和对象以及基础数据的引用。每个栈中的数据都是私有的，其他栈无法访问</li><li>方法区：又被称为静态区，跟堆一样被所有线程共享，方法区包含所有class信息和static修饰的变量。方法区中包含的都是整个程序中永远唯一的元素，如class，static变量等</li></ul><p><strong>类实例化时内存中发生的变化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    String name; <span class="hljs-comment">// 定义一个成员变量 name</span><br>    <span class="hljs-type">int</span> age; <span class="hljs-comment">// 成员变量 age</span><br>    Double height; <span class="hljs-comment">// 成员变量 height</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;人的姓名：&quot;</span>+name);<br>        System.out.println(<span class="hljs-string">&quot;人的年龄：&quot;</span>+age);<br>        System.out.println(<span class="hljs-string">&quot;人的身高：&quot;</span>+height);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String name; <span class="hljs-comment">// 定义一个局部变量 name</span><br>    <span class="hljs-type">int</span> age; <span class="hljs-comment">// 局部变量 age</span><br>    Double height; <span class="hljs-comment">// 局部变量 height</span><br>        <br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>() ; <span class="hljs-comment">//实例化对象people</span><br>        people.name = <span class="hljs-string">&quot;张三&quot;</span> ;       <span class="hljs-comment">//赋值</span><br>        people.age = <span class="hljs-number">18</span>;             <span class="hljs-comment">//赋值</span><br>        people.stuid = <span class="hljs-number">180.0</span> ;   <span class="hljs-comment">//赋值</span><br>        people.sing();              <span class="hljs-comment">//调用方法sing</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>代码解析</strong>：首先定义了三个成员变量，但是都只声明，没有初始化，然后定义了一个成员方法。在main方法中定义了三个局部变量，然后实例化对象people，内存中在堆区会给实例化对象people分配一片地址，然后我们堆people进行赋值，people调用成员方法，main打印输出，系统执行完毕。下面我用图解法展示实例化过程中内存的变化：</p><p><img src="/../img/java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/image-20240801093850304.png" alt="image-20240801093850304"></p><p>首先类中的成员变量和方法体会进入到方法区，如图：</p><p><img src="/../img/java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/image-20240801094224361.png" alt="image-20240801094224361"></p><p>程序执行main方法时，main()函数会方法体会进入栈区，这一过程叫压栈，定义了一个用于指向Person实例的变量person。如图：</p><p><img src="/../img/java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/image-20240801094507538.png" alt="image-20240801094507538"></p><p>程序执行到Person person &#x3D; new Person()时就会在堆中开辟一块空间用来存放Person对象实例，然后将成员变量和成员方法放在new实例中，里面都是取成员变量或成员方法的地址值。如图：</p><p><img src="/../img/java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/image-20240801095300609.png" alt="image-20240801095300609"></p><p>接下来堆person对象进行赋值。如图：</p><p><img src="/../img/java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/image-20240801101009168.png" alt="image-20240801101009168"></p><p>当程序走到sing()方法时，先到栈区找到person这个引用变量，然后根据该地址值这种堆内存中找到new Person()进行方法调用。在方法体void sing()被调用完成后，就立马从栈内弹出。</p><p><img src="/../img/java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/image-20240801101521000.png" alt="image-20240801101521000"></p><p>以上就是Java对象在内存中实例化的全过程。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
